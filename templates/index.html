<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f7;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #1d1d1f;
            margin-bottom: 10px;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        .controls h3 {
            margin-top: 0;
            color: #1d1d1f;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #424245;
        }
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        .form-group input:focus {
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }
        .btn {
            background: #007aff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .btn:hover {
            background: #0056cc;
        }
        .btn:disabled {
            background: #d2d2d7;
            cursor: not-allowed;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .chart-container h3 {
            margin: 0 0 20px 0;
            color: #1d1d1f;
            font-size: 18px;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .current-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .value-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .value-card .label {
            font-size: 12px;
            color: #86868b;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        .value-card .value {
            font-size: 24px;
            font-weight: 600;
            color: #1d1d1f;
        }
        .hidden {
            display: none;
        }
        .scene-controls {
            background: #f0f8ff;
            border: 1px solid #007aff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .scene-controls h4 {
            margin: 0 0 10px 0;
            color: #007aff;
        }
        .scene-list {
            margin-top: 15px;
        }
        .scene-item {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: between;
            align-items: center;
            font-size: 14px;
        }
        .scene-item .scene-info {
            flex: 1;
        }
        .scene-item .scene-time {
            color: #86868b;
            font-size: 12px;
        }
        .scene-item .scene-actions {
            margin-left: 10px;
        }
        .scene-item button {
            background: #ff3b30;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        .chart-selection-overlay {
            position: absolute;
            background: rgba(0, 122, 255, 0.2);
            border: 2px solid #007aff;
            pointer-events: none;
            display: none;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
            cursor: crosshair;
        }
        .selecting .chart-wrapper {
            cursor: crosshair;
        }
        .tag-controls {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .tag-controls h4 {
            margin: 0 0 10px 0;
            color: #856404;
        }
        .tag-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }
        .tag-item .tag-info {
            flex: 1;
        }
        .tag-item .tag-time {
            color: #6c757d;
            font-size: 12px;
        }
        .tag-item .tag-note {
            color: #495057;
            font-style: italic;
            margin-top: 3px;
        }
        .tag-item .tag-actions {
            margin-left: 10px;
        }
        .tag-item button {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        .chart-tag-marker {
            position: absolute;
            width: 2px;
            background: #ffc107;
            top: 0;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .chart-tag-marker::after {
            content: 'ğŸ·ï¸';
            position: absolute;
            top: -5px;
            left: -8px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“± iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–</h1>
            <p>åŸºäºåŸå§‹main.pyé€»è¾‘çš„å®æ—¶æ€§èƒ½å›¾è¡¨æ˜¾ç¤º</p>
        </div>

        <div class="controls">
            <h3>ğŸ”§ ç›‘æ§é…ç½®</h3>
            <div class="form-group">
                <label for="udid">è®¾å¤‡UDIDï¼ˆå¯é€‰ï¼‰:</label>
                <input type="text" id="udid" placeholder="ç•™ç©ºä½¿ç”¨é»˜è®¤è®¾å¤‡">
            </div>
            <div class="form-group">
                <label for="bundleId">åº”ç”¨Bundle ID:</label>
                <input type="text" id="bundleId" value="com.newleaf.app.ios.vic" placeholder="é»˜è®¤åº”ç”¨">
            </div>
            <button class="btn" id="startBtn" onclick="startMonitoring()">å¼€å§‹ç›‘æ§</button>
            <button class="btn" id="stopBtn" onclick="stopMonitoring()" disabled>åœæ­¢ç›‘æ§</button>
            <button class="btn" id="saveBtn" onclick="saveData()" disabled>ä¿å­˜æ•°æ®</button>
            <button class="btn" id="importBtn" onclick="document.getElementById('fileInput').click()">å¯¼å…¥æ•°æ®</button>
            <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="importData(event)">
        </div>

        <div id="status" class="status hidden"></div>

        <!-- æ—¶é—´èŒƒå›´æ§åˆ¶ -->
        <div class="controls" id="timeControls" style="display: none;">
            <h3>â° æ—¶é—´èŒƒå›´æ§åˆ¶</h3>
            <div style="display: flex; gap: 15px; align-items: center;">
                <div style="flex: 1;">
                    <label for="windowSize">æ˜¾ç¤ºçª—å£å¤§å°:</label>
                    <input type="number" id="windowSize" min="10" max="500" value="50" step="10" oninput="updateWindowSize(this.value)" style="width: 80px; padding: 4px;">
                    <span id="windowSizeValue">50ä¸ªç‚¹</span>
                </div>
                <div style="flex: 2;">
                    <label for="timeSlider">æ—¶é—´è½´æ‹–åŠ¨:</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="timeSlider" min="0" max="100" value="100" oninput="updateTimePosition(this.value)" style="flex: 1;">
                        <span id="timePosition">æœ€æ–°</span>
                        <button onclick="goToLatest()" style="padding: 4px 8px; background: #007aff; color: white; border: none; border-radius: 4px; font-size: 12px;">è·³åˆ°æœ€æ–°</button>
                    </div>
                </div>
                <div class="form-group" style="flex: 1; margin-bottom: 0;">
                    <label for="updateInterval">æ›´æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰:</label>
                    <input type="range" id="updateInterval" min="500" max="5000" value="1000" oninput="updateInterval(this.value)">
                    <span id="intervalValue">1000ms</span>
                </div>
            </div>
        </div>

        <!-- åœºæ™¯æ ‡è®°æ§åˆ¶ -->
        <div class="scene-controls" id="sceneControls" style="display: none;">
            <h4>ğŸ¬ åœºæ™¯æ ‡è®°</h4>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <button class="btn" id="startSelectionBtn" onclick="toggleSelection()">å¼€å§‹é€‰æ‹©æ—¶é—´åŒºåŸŸ</button>
                <input type="text" id="sceneNameInput" placeholder="åœºæ™¯åç§°" style="padding: 8px; border: 1px solid #d2d2d7; border-radius: 6px; width: 200px;">
                <button class="btn" id="saveSceneBtn" onclick="saveScene()" disabled>ä¿å­˜åœºæ™¯</button>
                <button class="btn" id="clearScenesBtn" onclick="clearAllScenes()">æ¸…ç©ºæ‰€æœ‰åœºæ™¯</button>
            </div>
            <div id="selectionStatus" style="font-size: 14px; color: #86868b; margin-bottom: 10px;"></div>
            <div class="scene-list" id="sceneList"></div>
        </div>

        <!-- å•ç‚¹æ ‡ç­¾æ§åˆ¶ -->
        <div class="tag-controls" id="tagControls" style="display: none;">
            <h4>ğŸ·ï¸ å•ç‚¹æ ‡ç­¾</h4>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <span style="font-size: 14px; color: #856404;">åŒå‡»å›¾è¡¨ä»»æ„ä½ç½®æ·»åŠ æ ‡ç­¾</span>
                <button class="btn" id="clearTagsBtn" onclick="clearAllTags()">æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾</button>
            </div>
            <div class="scene-list" id="tagList"></div>
        </div>

        <div class="current-values" id="currentValues" style="display: none;">
            <div class="value-card">
                <div class="label">CPUä½¿ç”¨ç‡</div>
                <div class="value" id="currentCpu">0%</div>
            </div>
            <div class="value-card">
                <div class="label">å†…å­˜ä½¿ç”¨</div>
                <div class="value" id="currentMemory">0MB</div>
            </div>
            <div class="value-card">
                <div class="label">å¸§ç‡</div>
                <div class="value" id="currentFps">0FPS</div>
            </div>
            <div class="value-card">
                <div class="label">çº¿ç¨‹æ•°</div>
                <div class="value" id="currentThreads">0</div>
            </div>
        </div>

        <div class="charts-grid" id="chartsGrid" style="display: none;">
            <div class="chart-container">
                <h3>ğŸ“Š CPUä½¿ç”¨ç‡</h3>
                <div class="chart-wrapper" data-chart="cpu">
                    <canvas id="cpuChart"></canvas>
                    <div class="chart-selection-overlay" id="cpuOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ’¾ å†…å­˜ä½¿ç”¨é‡</h3>
                <div class="chart-wrapper" data-chart="memory">
                    <canvas id="memoryChart"></canvas>
                    <div class="chart-selection-overlay" id="memoryOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ® å¸§ç‡(FPS)</h3>
                <div class="chart-wrapper" data-chart="fps">
                    <canvas id="fpsChart"></canvas>
                    <div class="chart-selection-overlay" id="fpsOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ§µ çº¿ç¨‹æ•°é‡</h3>
                <div class="chart-wrapper" data-chart="threads">
                    <canvas id="threadsChart"></canvas>
                    <div class="chart-selection-overlay" id="threadsOverlay"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WebSocketè¿æ¥
        const socket = io();
        
        // å›¾è¡¨å®ä¾‹
        let cpuChart, memoryChart, fpsChart, threadsChart;
        
        // æ•°æ®å­˜å‚¨
        let isMonitoring = false;
        let windowSize = 50; // æ˜¾ç¤ºçª—å£å¤§å°
        let timePosition = 100; // æ—¶é—´ä½ç½®ç™¾åˆ†æ¯”ï¼Œ100è¡¨ç¤ºæœ€æ–°
        let allPerformanceData = []; // å­˜å‚¨æ‰€æœ‰æ€§èƒ½æ•°æ®ç”¨äºä¿å­˜
        let allTimeLabels = []; // å­˜å‚¨æ‰€æœ‰æ—¶é—´æ ‡ç­¾
        let allCpuData = []; // å­˜å‚¨æ‰€æœ‰CPUæ•°æ®
        let allMemoryData = []; // å­˜å‚¨æ‰€æœ‰å†…å­˜æ•°æ®
        let allFpsData = []; // å­˜å‚¨æ‰€æœ‰FPSæ•°æ®
        let allThreadsData = []; // å­˜å‚¨æ‰€æœ‰çº¿ç¨‹æ•°æ®
        let currentUpdateInterval = 1000; // å½“å‰æ›´æ–°é—´éš”
        let isFollowingLatest = true; // æ˜¯å¦è·Ÿéšæœ€æ–°æ•°æ®
        
        // åœºæ™¯é€‰æ‹©ç›¸å…³å˜é‡
        let isSelecting = false;
        let selectionStart = null;
        let selectionEnd = null;
        let currentSelection = null;
        let savedScenes = []; // ä¿å­˜çš„åœºæ™¯åˆ—è¡¨
        let isMouseDown = false;
        let selectionStartX = 0;
        
        // æ ‡ç­¾ç›¸å…³å˜é‡
        let savedTags = []; // ä¿å­˜çš„æ ‡ç­¾åˆ—è¡¨
        
        // å›¾è¡¨é…ç½®
        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: 'æ—¶é—´'
                    }
                },
                y: {
                    display: true,
                    beginAtZero: true
                }
            },
            elements: {
                line: {
                    tension: 0.4
                },
                point: {
                    radius: 3
                }
            }
        };

        // åˆå§‹åŒ–å›¾è¡¨
        function initCharts() {
            const cpuCtx = document.getElementById('cpuChart').getContext('2d');
            cpuChart = new Chart(cpuCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'CPUä½¿ç”¨ç‡ (%)',
                        data: [],
                        borderColor: '#ff3b30',
                        backgroundColor: 'rgba(255, 59, 48, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'CPUä½¿ç”¨ç‡ (%)'
                            }
                        }
                    }
                }
            });

            const memoryCtx = document.getElementById('memoryChart').getContext('2d');
            memoryChart = new Chart(memoryCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å†…å­˜ä½¿ç”¨ (MB)',
                        data: [],
                        borderColor: '#007aff',
                        backgroundColor: 'rgba(0, 122, 255, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'å†…å­˜ä½¿ç”¨ (MB)'
                            }
                        }
                    }
                }
            });

            const fpsCtx = document.getElementById('fpsChart').getContext('2d');
            fpsChart = new Chart(fpsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å¸§ç‡ (FPS)',
                        data: [],
                        borderColor: '#34c759',
                        backgroundColor: 'rgba(52, 199, 89, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'å¸§ç‡ (FPS)'
                            },
                            max: 60
                        }
                    }
                }
            });

            const threadsCtx = document.getElementById('threadsChart').getContext('2d');
            threadsChart = new Chart(threadsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'çº¿ç¨‹æ•°é‡',
                        data: [],
                        borderColor: '#ff9500',
                        backgroundColor: 'rgba(255, 149, 0, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'çº¿ç¨‹æ•°é‡'
                            }
                        }
                    }
                }
            });
        }

        // æ·»åŠ æ•°æ®åˆ°å›¾è¡¨
        function addDataToChart(chart, label, data) {
            // å­˜å‚¨åˆ°å…¨å±€æ•°ç»„
            if (chart === cpuChart) {
                allTimeLabels.push(label);
                allCpuData.push(data);
            } else if (chart === memoryChart) {
                allMemoryData.push(data);
            } else if (chart === fpsChart) {
                allFpsData.push(data);
            } else if (chart === threadsChart) {
                allThreadsData.push(data);
            }
            
            // å¦‚æœæ­£åœ¨è·Ÿéšæœ€æ–°æ•°æ®ï¼Œæ›´æ–°æ˜¾ç¤º
            if (isFollowingLatest) {
                updateChartDisplay();
            }
            
            // æ›´æ–°æ ‡ç­¾ä½ç½®ï¼ˆä»…åœ¨CPUå›¾è¡¨æ›´æ–°æ—¶æ‰§è¡Œï¼Œé¿å…é‡å¤ï¼‰
            if (chart === cpuChart && savedTags.length > 0) {
                updateAllTagMarkers();
                updateTagList(); // æ›´æ–°æ ‡ç­¾åˆ—è¡¨çŠ¶æ€
            }
        }

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.classList.remove('hidden');
        }

        // éšè—çŠ¶æ€æ¶ˆæ¯
        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        // çª—å£å¤§å°å’Œæ—¶é—´ä½ç½®æ§åˆ¶å‡½æ•°
        function updateWindowSize(value) {
            windowSize = parseInt(value);
            document.getElementById('windowSizeValue').textContent = windowSize + 'ä¸ªç‚¹';
            updateChartDisplay();
        }

        function updateTimePosition(value) {
            timePosition = parseInt(value);
            isFollowingLatest = (timePosition === 100);
            
            if (isFollowingLatest) {
                document.getElementById('timePosition').textContent = 'æœ€æ–°';
            } else {
                const totalData = allTimeLabels.length;
                const endIndex = Math.floor((timePosition / 100) * totalData);
                const startIndex = Math.max(0, endIndex - windowSize);
                document.getElementById('timePosition').textContent = `${startIndex}-${endIndex}`;
            }
            
            updateChartDisplay();
        }

        function goToLatest() {
            timePosition = 100;
            isFollowingLatest = true;
            document.getElementById('timeSlider').value = 100;
            document.getElementById('timePosition').textContent = 'æœ€æ–°';
            updateChartDisplay();
        }

        function updateChartDisplay() {
            if (allTimeLabels.length === 0) return;

            let startIndex, endIndex;
            
            if (isFollowingLatest) {
                // è·Ÿéšæœ€æ–°æ•°æ®
                endIndex = allTimeLabels.length;
                startIndex = Math.max(0, endIndex - windowSize);
            } else {
                // æ ¹æ®æ—¶é—´ä½ç½®è®¡ç®—æ˜¾ç¤ºèŒƒå›´
                const totalData = allTimeLabels.length;
                endIndex = Math.floor((timePosition / 100) * totalData);
                startIndex = Math.max(0, endIndex - windowSize);
                endIndex = Math.min(totalData, startIndex + windowSize);
            }

            // æ›´æ–°æ‰€æœ‰å›¾è¡¨çš„æ˜¾ç¤ºæ•°æ®
            updateChartData(cpuChart, allTimeLabels.slice(startIndex, endIndex), allCpuData.slice(startIndex, endIndex));
            updateChartData(memoryChart, allTimeLabels.slice(startIndex, endIndex), allMemoryData.slice(startIndex, endIndex));
            updateChartData(fpsChart, allTimeLabels.slice(startIndex, endIndex), allFpsData.slice(startIndex, endIndex));
            updateChartData(threadsChart, allTimeLabels.slice(startIndex, endIndex), allThreadsData.slice(startIndex, endIndex));

            // æ›´æ–°æ‹–åŠ¨æ¡çš„èŒƒå›´
            if (allTimeLabels.length > windowSize) {
                const maxSliderValue = Math.floor(((allTimeLabels.length - windowSize) / allTimeLabels.length) * 100);
                document.getElementById('timeSlider').max = 100;
                if (!isFollowingLatest && timePosition > maxSliderValue) {
                    timePosition = maxSliderValue;
                    document.getElementById('timeSlider').value = timePosition;
                }
            }
            
            // æ›´æ–°æ ‡ç­¾ä½ç½®
            updateAllTagMarkers();
        }

        function updateChartData(chart, labels, data) {
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update('none');
        }

        function updateInterval(value) {
            currentUpdateInterval = parseInt(value);
            document.getElementById('intervalValue').textContent = value + 'ms';
        }

        // æ ‡ç­¾åŠŸèƒ½
        function enableDoubleClickTags() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('dblclick', onDoubleClickTag);
            });
        }

        function onDoubleClickTag(e) {
            if (isSelecting) return; // é€‰æ‹©æ¨¡å¼ä¸‹ä¸æ·»åŠ æ ‡ç­¾
            
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // è®¡ç®—æ—¶é—´ç´¢å¼•
            const clickIndex = Math.floor((clickX / chartWidth) * (cpuChart.data.labels.length));
            const timeLabel = cpuChart.data.labels[clickIndex];
            
            if (timeLabel) {
                // å¼¹å‡ºè¾“å…¥æ¡†è®©ç”¨æˆ·è¾“å…¥æ ‡ç­¾å†…å®¹
                const tagNote = prompt('è¯·è¾“å…¥æ ‡ç­¾å¤‡æ³¨:', '');
                if (tagNote !== null && tagNote.trim() !== '') {
                    addTag(timeLabel, tagNote.trim(), clickX, chartWidth);
                }
            }
        }

        function addTag(timeLabel, note, clickX, chartWidth) {
            const tag = {
                id: Date.now(),
                time: timeLabel,
                note: note,
                createdAt: new Date().toISOString()
            };

            savedTags.push(tag);
            updateTagList();
            
            // åœ¨æ‰€æœ‰å›¾è¡¨ä¸Šæ·»åŠ æ ‡ç­¾æ ‡è®°
            addTagMarkersToAllCharts(tag);
            
            showStatus(`æ ‡ç­¾ "${note}" å·²æ·»åŠ åˆ° ${timeLabel}`, 'success');
        }

        function addTagMarkersToAllCharts(tag) {
            // ä¸åœ¨è¿™é‡Œç›´æ¥æ·»åŠ DOMå…ƒç´ ï¼Œè€Œæ˜¯åœ¨updateAllTagMarkersä¸­ç»Ÿä¸€å¤„ç†
            updateAllTagMarkers();
        }

        function updateAllTagMarkers() {
            // åˆ é™¤æ‰€æœ‰ç°æœ‰çš„æ ‡è®°
            const existingMarkers = document.querySelectorAll('.chart-tag-marker');
            existingMarkers.forEach(marker => marker.remove());

            // é‡æ–°æ·»åŠ æ‰€æœ‰æ ‡ç­¾æ ‡è®°
            if (cpuChart && cpuChart.data.labels.length > 0) {
                savedTags.forEach(tag => {
                    // æ‰¾åˆ°æ ‡ç­¾æ—¶é—´åœ¨å½“å‰å›¾è¡¨ä¸­çš„ä½ç½®
                    const timeIndex = cpuChart.data.labels.findIndex(label => label === tag.time);
                    if (timeIndex !== -1 && timeIndex >= 0 && timeIndex < cpuChart.data.labels.length) {
                        // ç¡®ä¿ä½ç½®åœ¨0-100%èŒƒå›´å†…
                        const position = Math.max(0, Math.min(100, (timeIndex / Math.max(1, cpuChart.data.labels.length - 1)) * 100));
                        
                        const chartWrappers = document.querySelectorAll('.chart-wrapper');
                        chartWrappers.forEach(wrapper => {
                            const marker = document.createElement('div');
                            marker.className = 'chart-tag-marker';
                            marker.style.left = position + '%';
                            marker.title = `${tag.time}: ${tag.note}`;
                            marker.setAttribute('data-tag-id', tag.id);
                            wrapper.appendChild(marker);
                        });
                    }
                });
            }
        }

        function updateTagList() {
            const tagList = document.getElementById('tagList');
            tagList.innerHTML = '';
            
            savedTags.forEach(tag => {
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-item';
                
                // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦åœ¨å½“å‰æ—¶é—´çª—å£å†…
                const isVisible = cpuChart && cpuChart.data.labels.includes(tag.time);
                const statusText = isVisible ? '' : ' (å·²ç§»å‡ºæ—¶é—´çª—å£)';
                const statusStyle = isVisible ? '' : 'opacity: 0.6; font-style: italic;';
                
                tagItem.innerHTML = `
                    <div class="tag-info" style="${statusStyle}">
                        <div class="tag-time">${tag.time}${statusText}</div>
                        <div class="tag-note">${tag.note}</div>
                    </div>
                    <div class="tag-actions">
                        <button onclick="deleteTag(${tag.id})">åˆ é™¤</button>
                    </div>
                `;
                tagList.appendChild(tagItem);
            });
        }

        function deleteTag(tagId) {
            savedTags = savedTags.filter(tag => tag.id !== tagId);
            updateTagList();
            
            // é‡æ–°æ›´æ–°æ‰€æœ‰æ ‡ç­¾ä½ç½®
            updateAllTagMarkers();
            
            showStatus('æ ‡ç­¾å·²åˆ é™¤', 'info');
        }

        function clearAllTags() {
            if (savedTags.length === 0) return;
            if (confirm('ç¡®è®¤æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾ï¼Ÿ')) {
                savedTags = [];
                updateTagList();
                
                // é‡æ–°æ›´æ–°æ ‡ç­¾ï¼ˆä¼šæ¸…ç©ºæ‰€æœ‰ï¼‰
                updateAllTagMarkers();
                
                showStatus('æ‰€æœ‰æ ‡ç­¾å·²æ¸…ç©º', 'info');
            }
        }

        // ä¿å­˜æ•°æ®å‡½æ•°ï¼ˆè°ƒç”¨æ–°çš„åŒ…å«åœºæ™¯çš„ä¿å­˜åŠŸèƒ½ï¼‰
        function saveData() {
            saveDataWithScenes();
        }

        // å¯¼å…¥æ•°æ®å‡½æ•°
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.data || !Array.isArray(importedData.data)) {
                        showStatus('æ— æ•ˆçš„æ•°æ®æ–‡ä»¶æ ¼å¼', 'error');
                        return;
                    }

                    // åœæ­¢å½“å‰ç›‘æ§
                    if (isMonitoring) {
                        stopMonitoring();
                    }

                    // æ¸…ç©ºç°æœ‰å›¾è¡¨
                    clearAllCharts();
                    
                    // æ˜¾ç¤ºå›¾è¡¨åŒºåŸŸ
                    document.getElementById('chartsGrid').style.display = 'grid';
                    document.getElementById('currentValues').style.display = 'grid';
                    document.getElementById('timeControls').style.display = 'block';
                    document.getElementById('sceneControls').style.display = 'block';
                    document.getElementById('tagControls').style.display = 'block';
                    initCharts();
                    enableDoubleClickTags(); // å¯ç”¨åŒå‡»æ ‡ç­¾åŠŸèƒ½

                    // æ¢å¤è®¾ç½®
                    if (importedData.settings) {
                        if (importedData.settings.isUnlimited) {
                            setUnlimited();
                        } else if (importedData.settings.maxDataPoints) {
                            document.getElementById('timeRange').value = importedData.settings.maxDataPoints;
                            updateTimeRange(importedData.settings.maxDataPoints);
                        }
                    }

                    // æ‰¹é‡æ·»åŠ å¯¼å…¥çš„æ•°æ®
                    let dataCount = 0;
                    importedData.data.forEach(item => {
                        if (item.type === 'performance') {
                            addDataToChart(cpuChart, item.time, item.cpu);
                            addDataToChart(memoryChart, item.time, item.memory);
                            addDataToChart(threadsChart, item.time, item.threads);
                            
                            // æ›´æ–°å½“å‰å€¼æ˜¾ç¤º
                            document.getElementById('currentCpu').textContent = `${item.cpu}%`;
                            document.getElementById('currentMemory').textContent = `${item.memory.toFixed(1)}MB`;
                            document.getElementById('currentThreads').textContent = item.threads;
                            dataCount++;
                        } else if (item.type === 'fps') {
                            addDataToChart(fpsChart, item.time, item.fps);
                            document.getElementById('currentFps').textContent = `${item.fps}FPS`;
                        }
                    });

                    // å¯¼å…¥åœºæ™¯æ•°æ®
                    if (importedData.scenes && Array.isArray(importedData.scenes)) {
                        savedScenes = importedData.scenes;
                        updateSceneList();
                    }

                    // å¯¼å…¥æ ‡ç­¾æ•°æ®
                    if (importedData.tags && Array.isArray(importedData.tags)) {
                        savedTags = importedData.tags;
                        updateTagList();
                        // æ¢å¤æ ‡ç­¾æ ‡è®°
                        updateAllTagMarkers();
                    }

                    let statusMessage = `æˆåŠŸå¯¼å…¥ ${dataCount} æ¡æ€§èƒ½è®°å½•`;
                    if (importedData.scenes && importedData.scenes.length > 0) {
                        statusMessage += `ï¼Œ${importedData.scenes.length} ä¸ªåœºæ™¯`;
                    }
                    if (importedData.tags && importedData.tags.length > 0) {
                        statusMessage += `ï¼Œ${importedData.tags.length} ä¸ªæ ‡ç­¾`;
                    }
                    statusMessage += `ï¼Œæ¥è‡ª ${importedData.timestamp}`;
                    showStatus(statusMessage, 'success');
                    
                } catch (error) {
                    showStatus('æ–‡ä»¶è§£æå¤±è´¥: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
            
            // æ¸…ç©ºfile input
            event.target.value = '';
        }

        function clearAllCharts() {
            if (cpuChart) {
                cpuChart.data.labels = [];
                cpuChart.data.datasets[0].data = [];
                cpuChart.update();
                
                memoryChart.data.labels = [];
                memoryChart.data.datasets[0].data = [];
                memoryChart.update();
                
                fpsChart.data.labels = [];
                fpsChart.data.datasets[0].data = [];
                fpsChart.update();
                
                threadsChart.data.labels = [];
                threadsChart.data.datasets[0].data = [];
                threadsChart.update();
                
                // æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾æ ‡è®°
                const existingMarkers = document.querySelectorAll('.chart-tag-marker');
                existingMarkers.forEach(marker => marker.remove());
            }
        }

        // å¼€å§‹ç›‘æ§
        function startMonitoring() {
            const udid = document.getElementById('udid').value.trim();
            const bundleId = document.getElementById('bundleId').value.trim();
            
            showStatus('æ­£åœ¨å¯åŠ¨ç›‘æ§...', 'info');
            
            // æ¸…ç©ºä¹‹å‰çš„æ•°æ®
            allPerformanceData = [];
            
            socket.emit('start_monitoring', {
                udid: udid,
                bundle_id: bundleId
            });
            
            isMonitoring = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('saveBtn').disabled = false;
        }

        // åœæ­¢ç›‘æ§
        function stopMonitoring() {
            isMonitoring = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            showStatus('ç›‘æ§å·²åœæ­¢', 'info');
            // ä¿æŒå›¾è¡¨æ˜¾ç¤ºï¼Œä¸éšè—
        }

        // Socket.IOäº‹ä»¶å¤„ç†
        // åœºæ™¯ç®¡ç†åŠŸèƒ½
        function toggleSelection() {
            isSelecting = !isSelecting;
            const btn = document.getElementById('startSelectionBtn');
            const statusEl = document.getElementById('selectionStatus');
            
            if (isSelecting) {
                btn.textContent = 'å–æ¶ˆé€‰æ‹©';
                btn.style.background = '#ff3b30';
                statusEl.textContent = 'è¯·åœ¨ä»»æ„å›¾è¡¨ä¸Šæ‹–æ‹½é€‰æ‹©æ—¶é—´åŒºåŸŸ';
                document.body.classList.add('selecting');
                enableChartSelection();
            } else {
                btn.textContent = 'å¼€å§‹é€‰æ‹©æ—¶é—´åŒºåŸŸ';
                btn.style.background = '#007aff';
                statusEl.textContent = '';
                document.body.classList.remove('selecting');
                disableChartSelection();
                clearCurrentSelection();
            }
        }

        function enableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('mousedown', onSelectionStart);
                wrapper.addEventListener('mousemove', onSelectionMove);
                wrapper.addEventListener('mouseup', onSelectionEnd);
                wrapper.addEventListener('mouseleave', onSelectionEnd);
            });
        }

        function disableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.removeEventListener('mousedown', onSelectionStart);
                wrapper.removeEventListener('mousemove', onSelectionMove);
                wrapper.removeEventListener('mouseup', onSelectionEnd);
                wrapper.removeEventListener('mouseleave', onSelectionEnd);
            });
        }

        function onSelectionStart(e) {
            if (!isSelecting) return;
            isMouseDown = true;
            const rect = e.currentTarget.getBoundingClientRect();
            selectionStartX = e.clientX - rect.left;
            clearCurrentSelection();
        }

        function onSelectionMove(e) {
            if (!isSelecting || !isMouseDown) return;
            const rect = e.currentTarget.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const width = Math.abs(currentX - selectionStartX);
            const left = Math.min(selectionStartX, currentX);
            
            // åŒæ­¥æ˜¾ç¤ºé€‰æ‹©åŒºåŸŸåˆ°æ‰€æœ‰å›¾è¡¨
            updateAllSelectionOverlays(left, width);
        }

        function onSelectionEnd(e) {
            if (!isSelecting || !isMouseDown) return;
            isMouseDown = false;
            
            const rect = e.currentTarget.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // è®¡ç®—æ—¶é—´ç´¢å¼•
            const startIndex = Math.floor((Math.min(selectionStartX, endX) / chartWidth) * maxDataPoints);
            const endIndex = Math.floor((Math.max(selectionStartX, endX) / chartWidth) * maxDataPoints);
            
            if (Math.abs(endX - selectionStartX) > 10) { // æœ€å°é€‰æ‹©å®½åº¦
                // è·å–æ—¶é—´æ ‡ç­¾
                const timeLabels = cpuChart.data.labels;
                selectionStart = timeLabels[Math.max(0, startIndex)] || '';
                selectionEnd = timeLabels[Math.min(timeLabels.length - 1, endIndex)] || '';
                
                if (selectionStart && selectionEnd) {
                    document.getElementById('saveSceneBtn').disabled = false;
                    document.getElementById('selectionStatus').textContent = 
                        `å·²é€‰æ‹©æ—¶é—´æ®µ: ${selectionStart} - ${selectionEnd}`;
                }
            }
        }

        function updateAllSelectionOverlays(left, width) {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                const overlay = document.getElementById(overlayId);
                overlay.style.display = 'block';
                overlay.style.left = left + 'px';
                overlay.style.width = width + 'px';
                overlay.style.top = '0px';
                overlay.style.height = '100%';
            });
        }

        function clearCurrentSelection() {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                document.getElementById(overlayId).style.display = 'none';
            });
            selectionStart = null;
            selectionEnd = null;
            document.getElementById('saveSceneBtn').disabled = true;
        }

        function saveScene() {
            const sceneName = document.getElementById('sceneNameInput').value.trim();
            if (!sceneName) {
                showStatus('è¯·è¾“å…¥åœºæ™¯åç§°', 'error');
                return;
            }
            
            if (!selectionStart || !selectionEnd) {
                showStatus('è¯·å…ˆé€‰æ‹©æ—¶é—´åŒºåŸŸ', 'error');
                return;
            }

            // è·å–é€‰æ‹©æ—¶é—´æ®µå†…çš„æ€§èƒ½æ•°æ®
            const sceneData = allPerformanceData.filter(item => {
                return item.time >= selectionStart && item.time <= selectionEnd;
            });

            const scene = {
                id: Date.now(),
                name: sceneName,
                startTime: selectionStart,
                endTime: selectionEnd,
                data: sceneData,
                createdAt: new Date().toISOString(),
                summary: generateSceneSummary(sceneData)
            };

            savedScenes.push(scene);
            updateSceneList();
            
            // åœ¨æ‰€æœ‰å›¾è¡¨ä¸Šæ·»åŠ æ°¸ä¹…æ ‡è®°
            addSceneMarkersToAllCharts(scene);
            
            // æ¸…ç©ºè¾“å…¥å’Œé€‰æ‹©
            document.getElementById('sceneNameInput').value = '';
            clearCurrentSelection();
            toggleSelection(); // é€€å‡ºé€‰æ‹©æ¨¡å¼
            
            showStatus(`åœºæ™¯ "${sceneName}" å·²ä¿å­˜`, 'success');
        }

        function generateSceneSummary(sceneData) {
            const perfData = sceneData.filter(item => item.type === 'performance');
            const fpsData = sceneData.filter(item => item.type === 'fps');
            
            if (perfData.length === 0) return {};
            
            const cpuValues = perfData.map(item => item.cpu);
            const memoryValues = perfData.map(item => item.memory);
            const fpsValues = fpsData.map(item => item.fps);
            
            return {
                duration: perfData.length,
                avgCpu: (cpuValues.reduce((a, b) => a + b, 0) / cpuValues.length).toFixed(2),
                maxCpu: Math.max(...cpuValues).toFixed(2),
                avgMemory: (memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length).toFixed(1),
                maxMemory: Math.max(...memoryValues).toFixed(1),
                avgFps: fpsValues.length > 0 ? (fpsValues.reduce((a, b) => a + b, 0) / fpsValues.length).toFixed(1) : 0,
                minFps: fpsValues.length > 0 ? Math.min(...fpsValues) : 0
            };
        }

        function addSceneMarkersToAllCharts(scene) {
            // è¿™é‡Œæ·»åŠ æ°¸ä¹…çš„åœºæ™¯æ ‡è®°åˆ°æ‰€æœ‰å›¾è¡¨
            // Chart.jsæ’ä»¶å¯ä»¥å®ç°ï¼Œä½†ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å…ˆåœ¨åœºæ™¯åˆ—è¡¨ä¸­æ˜¾ç¤º
        }

        function updateSceneList() {
            const sceneList = document.getElementById('sceneList');
            sceneList.innerHTML = '';
            
            savedScenes.forEach(scene => {
                const sceneItem = document.createElement('div');
                sceneItem.className = 'scene-item';
                sceneItem.innerHTML = `
                    <div class="scene-info">
                        <div><strong>${scene.name}</strong></div>
                        <div class="scene-time">${scene.startTime} - ${scene.endTime}</div>
                        <div style="font-size: 11px; color: #86868b;">
                            å¹³å‡CPU: ${scene.summary.avgCpu}% | å¹³å‡å†…å­˜: ${scene.summary.avgMemory}MB | å¹³å‡FPS: ${scene.summary.avgFps}
                        </div>
                    </div>
                    <div class="scene-actions">
                        <button onclick="deleteScene(${scene.id})">åˆ é™¤</button>
                    </div>
                `;
                sceneList.appendChild(sceneItem);
            });
        }

        function deleteScene(sceneId) {
            savedScenes = savedScenes.filter(scene => scene.id !== sceneId);
            updateSceneList();
            showStatus('åœºæ™¯å·²åˆ é™¤', 'info');
        }

        function clearAllScenes() {
            if (savedScenes.length === 0) return;
            if (confirm('ç¡®è®¤æ¸…ç©ºæ‰€æœ‰åœºæ™¯æ ‡è®°ï¼Ÿ')) {
                savedScenes = [];
                updateSceneList();
                showStatus('æ‰€æœ‰åœºæ™¯å·²æ¸…ç©º', 'info');
            }
        }

        // ä¿®æ”¹ä¿å­˜æ•°æ®å‡½æ•°ï¼ŒåŒ…å«åœºæ™¯å’Œæ ‡ç­¾ä¿¡æ¯
        function saveDataWithScenes() {
            if (allTimeLabels.length === 0 && savedScenes.length === 0 && savedTags.length === 0) {
                showStatus('æ²¡æœ‰æ•°æ®ã€åœºæ™¯æˆ–æ ‡ç­¾å¯ä¿å­˜', 'error');
                return;
            }

            // é‡æ–°æ„å»ºæ€§èƒ½æ•°æ®æ•°ç»„
            const performanceData = [];
            for (let i = 0; i < allTimeLabels.length; i++) {
                performanceData.push({
                    timestamp: allTimeLabels[i],
                    cpu: allCpuData[i] || 0,
                    memory: allMemoryData[i] || 0,
                    fps: allFpsData[i] || 0,
                    threads: allThreadsData[i] || 0
                });
            }

            const now = new Date();
            const filename = `ios_performance_complete_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}.json`;
            
            const dataToSave = {
                timestamp: now.toISOString(),
                device_udid: document.getElementById('udid').value.trim(),
                bundle_id: document.getElementById('bundleId').value.trim(),
                data: performanceData,
                scenes: savedScenes, // åŒ…å«åœºæ™¯ä¿¡æ¯
                tags: savedTags, // åŒ…å«æ ‡ç­¾ä¿¡æ¯
                settings: {
                    windowSize: windowSize,
                    timePosition: timePosition
                },
                summary: {
                    total_records: performanceData.length,
                    total_scenes: savedScenes.length,
                    total_tags: savedTags.length,
                    duration_seconds: performanceData.length > 0 ? 
                        Math.round((new Date(performanceData[performanceData.length-1].timestamp) - new Date(performanceData[0].timestamp)) / 1000) : 0
                }
            };

            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`æ•°æ®å’Œåœºæ™¯å·²ä¿å­˜åˆ° ${filename}`, 'success');
        }

        socket.on('monitoring_started', function(data) {
            if (data.status === 'success') {
                showStatus('ç›‘æ§å·²å¯åŠ¨ï¼Œæ­£åœ¨æ”¶é›†æ•°æ®...', 'success');
                document.getElementById('chartsGrid').style.display = 'grid';
                document.getElementById('currentValues').style.display = 'grid';
                document.getElementById('timeControls').style.display = 'block';
                document.getElementById('sceneControls').style.display = 'block';
                document.getElementById('tagControls').style.display = 'block';
                initCharts();
                enableDoubleClickTags(); // å¯ç”¨åŒå‡»æ ‡ç­¾åŠŸèƒ½
            }
        });

        socket.on('performance_data', function(data) {
            if (!isMonitoring) return;
            
            // ä¿å­˜åˆ°allPerformanceDataç”¨äºå¯¼å‡º
            allPerformanceData.push({
                type: 'performance',
                timestamp: new Date().toISOString(),
                time: data.time,
                cpu: data.cpu,
                memory: data.memory,
                threads: data.threads,
                pid: data.pid,
                name: data.name
            });
            
            // æ›´æ–°å½“å‰å€¼æ˜¾ç¤º
            document.getElementById('currentCpu').textContent = `${data.cpu}%`;
            document.getElementById('currentMemory').textContent = `${data.memory.toFixed(1)}MB`;
            document.getElementById('currentThreads').textContent = data.threads;
            
            // æ·»åŠ æ•°æ®åˆ°å›¾è¡¨
            addDataToChart(cpuChart, data.time, data.cpu);
            addDataToChart(memoryChart, data.time, data.memory);
            addDataToChart(threadsChart, data.time, data.threads);
        });

        socket.on('fps_data', function(data) {
            if (!isMonitoring) return;
            
            // ä¿å­˜åˆ°allPerformanceDataç”¨äºå¯¼å‡º
            allPerformanceData.push({
                type: 'fps',
                timestamp: new Date().toISOString(),
                time: data.time,
                fps: data.fps
            });
            
            // æ›´æ–°å½“å‰FPSæ˜¾ç¤º
            document.getElementById('currentFps').textContent = `${data.fps}FPS`;
            
            // æ·»åŠ FPSæ•°æ®åˆ°å›¾è¡¨
            addDataToChart(fpsChart, data.time, data.fps);
        });

        socket.on('connect', function() {
            console.log('å·²è¿æ¥åˆ°æœåŠ¡å™¨');
        });

        socket.on('disconnect', function() {
            console.log('ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥');
            if (isMonitoring) {
                showStatus('ä¸æœåŠ¡å™¨è¿æ¥æ–­å¼€', 'error');
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–ç•Œé¢å·²åŠ è½½');
        });
    </script>
</body>
</html>
