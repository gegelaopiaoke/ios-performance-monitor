<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f7;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #1d1d1f;
            margin-bottom: 10px;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        .controls h3 {
            margin-top: 0;
            color: #1d1d1f;
        }
        
        /* æ€§èƒ½é˜ˆå€¼å’Œå‘Šè­¦æ ·å¼ */
        .alert-panel {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .alert-item {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 6px;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .alert-item.warning {
            background: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }
        .alert-item.critical {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
            animation: pulse 2s infinite;
        }
        
        /* æ€§èƒ½è¯„åˆ†æ ·å¼ */
        .score-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .score-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .score-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }
        .score-value {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .score-value.grade-a { color: #28a745; }
        .score-value.grade-b { color: #17a2b8; }
        .score-value.grade-c { color: #ffc107; }
        .score-value.grade-d { color: #fd7e14; }
        .score-value.grade-f { color: #dc3545; }
        .score-number {
            font-size: 12px;
            color: #999;
        }
        
        /* æ•°æ®ç»Ÿè®¡å¡ç‰‡æ ·å¼ */
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            z-index: 1;
        }
        .stat-card > * {
            position: relative;
            z-index: 2;
        }
        .stat-title {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 10px;
        }
        .stat-current {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .stat-details {
            font-size: 12px;
            opacity: 0.8;
            display: flex;
            justify-content: space-between;
        }
        .stat-card:nth-child(1) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .stat-card:nth-child(2) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .stat-card:nth-child(3) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        .stat-card:nth-child(4) {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }
        
        /* åŠ¨ç”»æ•ˆæœ */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* é˜ˆå€¼è¶…æ ‡æ—¶çš„å›¾è¡¨é«˜äº® */
        .chart-wrapper.threshold-exceeded {
            border: 3px solid #dc3545;
            box-shadow: 0 0 15px rgba(220, 53, 69, 0.3);
            animation: pulse 2s infinite;
        }
        
        /* å†…å­˜æ³„æ¼æ£€æµ‹æ ·å¼ */
        .leak-status, .leak-trend, .leak-rate, .leak-duration {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }
        .status-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }
        .status-value {
            font-size: 18px;
            font-weight: bold;
        }
        .leak-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .leak-warning.active {
            background: #f8d7da;
            border-color: #f5c6cb;
            animation: pulse 2s infinite;
        }
        
        /* æµ‹è¯•åœºæ™¯æ ·å¼ */
        .scenario-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        .scenario-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        .scenario-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            z-index: 1;
        }
        .scenario-card > * {
            position: relative;
            z-index: 2;
        }
        .scenario-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .scenario-desc {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        .scenario-duration {
            font-size: 12px;
            opacity: 0.7;
        }
        .scenario-card:nth-child(1) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .scenario-card:nth-child(2) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .scenario-card:nth-child(3) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        .scenario-card:nth-child(4) {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }
        
        /* å½“å‰æµ‹è¯•åœºæ™¯æ ·å¼ */
        .current-scenario {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .scenario-progress {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }
        .progress-bar {
            flex: 1;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50 0%, #2196f3 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        .btn-stop {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
        }
        .btn-stop:hover {
            background: #d32f2f;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #424245;
        }
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        .form-group input:focus {
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }
        .btn {
            background: #007aff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .btn:hover {
            background: #0056cc;
        }
        .btn:disabled {
            background: #d2d2d7;
            cursor: not-allowed;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .chart-container h3 {
            margin: 0 0 20px 0;
            color: #1d1d1f;
            font-size: 18px;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .current-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .value-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .value-card .label {
            font-size: 12px;
            color: #86868b;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        .value-card .value {
            font-size: 24px;
            font-weight: 600;
            color: #1d1d1f;
        }
        .hidden {
            display: none;
        }
        .scene-controls {
            background: #f0f8ff;
            border: 1px solid #007aff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .scene-controls h4 {
            margin: 0 0 10px 0;
            color: #007aff;
        }
        .scene-list {
            margin-top: 15px;
        }
        .scene-item {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: between;
            align-items: center;
            font-size: 14px;
        }
        .scene-item .scene-info {
            flex: 1;
        }
        .scene-item .scene-time {
            color: #86868b;
            font-size: 12px;
        }
        .scene-item .scene-actions {
            margin-left: 10px;
        }
        .scene-item button {
            background: #ff3b30;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        .chart-selection-overlay {
            position: absolute;
            background: rgba(0, 122, 255, 0.2);
            border: 2px solid #007aff;
            pointer-events: none;
            display: none;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
            cursor: crosshair;
        }
        .selecting .chart-wrapper {
            cursor: crosshair;
        }
        .tag-controls {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .tag-controls h4 {
            margin: 0 0 10px 0;
            color: #856404;
        }
        .tag-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }
        .tag-item .tag-info {
            flex: 1;
        }
        .tag-item .tag-time {
            color: #6c757d;
            font-size: 12px;
        }
        .tag-item .tag-note {
            color: #495057;
            font-style: italic;
            margin-top: 3px;
        }
        .tag-item .tag-actions {
            margin-left: 10px;
        }
        .tag-item button {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        .chart-tag-marker {
            position: absolute;
            width: 2px;
            background: #ffc107;
            top: 0;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .chart-tag-marker::after {
            content: 'ğŸ·ï¸';
            position: absolute;
            top: -5px;
            left: -8px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“± iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–</h1>
            <p>åŸºäºåŸå§‹main.pyé€»è¾‘çš„å®æ—¶æ€§èƒ½å›¾è¡¨æ˜¾ç¤º</p>
        </div>

        <div class="controls">
            <h3>ğŸ”§ ç›‘æ§é…ç½®</h3>
            <div class="form-group">
                <label for="udid">è®¾å¤‡UDIDï¼ˆå¯é€‰ï¼‰:</label>
                <input type="text" id="udid" placeholder="ç•™ç©ºä½¿ç”¨é»˜è®¤è®¾å¤‡">
            </div>
            <div class="form-group">
                <label for="bundleId">åº”ç”¨Bundle ID:</label>
                <input type="text" id="bundleId" value="com.newleaf.app.ios.vic" placeholder="é»˜è®¤åº”ç”¨">
            </div>
            <button class="btn" id="startBtn" onclick="startMonitoring()">å¼€å§‹ç›‘æ§</button>
            <button class="btn" id="stopBtn" onclick="stopMonitoring()" disabled>åœæ­¢ç›‘æ§</button>
            <button class="btn" id="saveBtn" onclick="saveData()" disabled>ä¿å­˜æ•°æ®</button>
            <button class="btn" id="importBtn" onclick="document.getElementById('fileInput').click()">å¯¼å…¥æ•°æ®</button>
            <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="importData(event)">
        </div>

        <div id="status" class="status hidden"></div>

        <!-- æ€§èƒ½é˜ˆå€¼è®¾ç½® -->
        <div class="controls" id="thresholdControls" style="display: none;">
            <h3>âš ï¸ æ€§èƒ½é˜ˆå€¼å‘Šè­¦</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                <div>
                    <label for="cpuThreshold">CPUå‘Šè­¦é˜ˆå€¼ (%):</label>
                    <input type="number" id="cpuThreshold" min="0" max="100" value="80" style="width: 80px; padding: 4px;">
                </div>
                <div>
                    <label for="memoryThreshold">å†…å­˜å‘Šè­¦é˜ˆå€¼ (MB):</label>
                    <input type="number" id="memoryThreshold" min="0" max="2048" value="500" style="width: 80px; padding: 4px;">
                </div>
                <div>
                    <label for="fpsThreshold">FPSå‘Šè­¦é˜ˆå€¼:</label>
                    <input type="number" id="fpsThreshold" min="0" max="120" value="30" style="width: 80px; padding: 4px;">
                </div>
                <div>
                    <label for="threadsThreshold">çº¿ç¨‹æ•°å‘Šè­¦é˜ˆå€¼:</label>
                    <input type="number" id="threadsThreshold" min="0" max="200" value="50" style="width: 80px; padding: 4px;">
                </div>
            </div>
            <div id="performanceAlerts" class="alert-panel" style="display: none;">
                <h4>ğŸš¨ æ€§èƒ½å‘Šè­¦</h4>
                <div id="alertList"></div>
            </div>
        </div>

        <!-- æ€§èƒ½è¯„åˆ†é¢æ¿ -->
        <div class="controls" id="scoringPanel" style="display: none;">
            <h3>ğŸ“Š å®æ—¶æ€§èƒ½è¯„åˆ†</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                <div class="score-item">
                    <div class="score-label">ç»¼åˆè¯„åˆ†</div>
                    <div class="score-value" id="overallScore">A+</div>
                    <div class="score-number" id="overallScoreNumber">95</div>
                </div>
                <div class="score-item">
                    <div class="score-label">CPUæ€§èƒ½</div>
                    <div class="score-value" id="cpuScore">A</div>
                </div>
                <div class="score-item">
                    <div class="score-label">å†…å­˜ä½¿ç”¨</div>
                    <div class="score-value" id="memoryScore">A</div>
                </div>
                <div class="score-item">
                    <div class="score-label">æµç•…åº¦</div>
                    <div class="score-value" id="fpsScore">B+</div>
                </div>
            </div>
        </div>

        <!-- å†…å­˜æ³„æ¼æ£€æµ‹é¢æ¿ -->
        <div class="controls" id="memoryLeakPanel" style="display: none;">
            <h3>ğŸ” å†…å­˜æ³„æ¼æ£€æµ‹</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                <div class="leak-status">
                    <div class="status-label">æ£€æµ‹çŠ¶æ€</div>
                    <div class="status-value" id="leakStatus">æ­£å¸¸</div>
                </div>
                <div class="leak-trend">
                    <div class="status-label">å†…å­˜è¶‹åŠ¿</div>
                    <div class="status-value" id="memoryTrend">ç¨³å®š</div>
                </div>
                <div class="leak-rate">
                    <div class="status-label">å¢é•¿ç‡</div>
                    <div class="status-value" id="leakRate">0 MB/min</div>
                </div>
                <div class="leak-duration">
                    <div class="status-label">ç›‘æ§æ—¶é•¿</div>
                    <div class="status-value" id="monitorDuration">0åˆ†é’Ÿ</div>
                </div>
            </div>
            <div id="leakWarning" class="leak-warning" style="display: none;">
                <h4>âš ï¸ ç–‘ä¼¼å†…å­˜æ³„æ¼</h4>
                <div id="leakDetails"></div>
            </div>
        </div>

        <!-- æµ‹è¯•åœºæ™¯é¢æ¿ -->
        <div class="controls" id="testScenariosPanel" style="display: none;">
            <h3>ğŸ¯ æµ‹è¯•åœºæ™¯</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                <div class="scenario-card" onclick="startScenario('app_launch')">
                    <div class="scenario-title">ğŸ“± åº”ç”¨å¯åŠ¨æµ‹è¯•</div>
                    <div class="scenario-desc">ç›‘æ§åº”ç”¨å¯åŠ¨æ—¶çš„æ€§èƒ½è¡¨ç°</div>
                    <div class="scenario-duration">æµ‹è¯•æ—¶é•¿: 30ç§’</div>
                </div>
                <div class="scenario-card" onclick="startScenario('stability_test')">
                    <div class="scenario-title">ğŸ”„ ç¨³å®šæ€§æµ‹è¯•</div>
                    <div class="scenario-desc">é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§æ£€æµ‹</div>
                    <div class="scenario-duration">æµ‹è¯•æ—¶é•¿: 10åˆ†é’Ÿ</div>
                </div>
                <div class="scenario-card" onclick="startScenario('memory_stress')">
                    <div class="scenario-title">ğŸ’¾ å†…å­˜å‹åŠ›æµ‹è¯•</div>
                    <div class="scenario-desc">æ¨¡æ‹Ÿé«˜å†…å­˜ä½¿ç”¨åœºæ™¯</div>
                    <div class="scenario-duration">æµ‹è¯•æ—¶é•¿: 5åˆ†é’Ÿ</div>
                </div>
                <div class="scenario-card" onclick="startScenario('fps_performance')">
                    <div class="scenario-title">ğŸ® FPSæ€§èƒ½æµ‹è¯•</div>
                    <div class="scenario-desc">æ£€æµ‹å¸§ç‡æ€§èƒ½è¡¨ç°</div>
                    <div class="scenario-duration">æµ‹è¯•æ—¶é•¿: 2åˆ†é’Ÿ</div>
                </div>
            </div>
            <div id="currentScenario" class="current-scenario" style="display: none;">
                <h4>ğŸ”„ å½“å‰æµ‹è¯•: <span id="scenarioName"></span></h4>
                <div class="scenario-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="scenarioProgress"></div>
                    </div>
                    <span id="scenarioTime">00:00 / 00:30</span>
                </div>
                <button onclick="stopCurrentScenario()" class="btn btn-stop">åœæ­¢æµ‹è¯•</button>
            </div>
        </div>

        <!-- æ•°æ®ç»Ÿè®¡é¢æ¿ -->
        <div class="controls" id="statisticsPanel" style="display: none;">
            <h3>ğŸ“ˆ æ•°æ®ç»Ÿè®¡</h3>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                <div class="stat-card">
                    <div class="stat-title">CPUä½¿ç”¨ç‡</div>
                    <div class="stat-current" id="cpuCurrent">0%</div>
                    <div class="stat-details">
                        <span>å¹³å‡: <span id="cpuAvg">0%</span></span>
                        <span>æœ€å¤§: <span id="cpuMax">0%</span></span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">å†…å­˜ä½¿ç”¨</div>
                    <div class="stat-current" id="memoryCurrent">0MB</div>
                    <div class="stat-details">
                        <span>å¹³å‡: <span id="memoryAvg">0MB</span></span>
                        <span>æœ€å¤§: <span id="memoryMax">0MB</span></span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">å¸§ç‡</div>
                    <div class="stat-current" id="fpsCurrent">0fps</div>
                    <div class="stat-details">
                        <span>å¹³å‡: <span id="fpsAvg">0fps</span></span>
                        <span>æœ€å°: <span id="fpsMin">0fps</span></span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">çº¿ç¨‹æ•°</div>
                    <div class="stat-current" id="threadsCurrent">0</div>
                    <div class="stat-details">
                        <span>å¹³å‡: <span id="threadsAvg">0</span></span>
                        <span>æœ€å¤§: <span id="threadsMax">0</span></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- æ—¶é—´èŒƒå›´æ§åˆ¶ -->
        <div class="controls" id="timeControls" style="display: none;">
            <h3>â° æ—¶é—´èŒƒå›´æ§åˆ¶</h3>
            <div style="display: flex; gap: 15px; align-items: center;">
                <div style="flex: 1;">
                    <label for="windowSize">æ˜¾ç¤ºçª—å£å¤§å°:</label>
                    <input type="number" id="windowSize" min="10" max="500" value="50" step="10" oninput="updateWindowSize(this.value)" style="width: 80px; padding: 4px;">
                    <span id="windowSizeValue">50ä¸ªç‚¹</span>
                </div>
                <div style="flex: 2;">
                    <label for="timeSlider">æ—¶é—´è½´æ‹–åŠ¨:</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="timeSlider" min="0" max="100" value="100" oninput="updateTimePosition(this.value)" style="flex: 1;">
                        <span id="timePosition">æœ€æ–°</span>
                        <button onclick="goToLatest()" style="padding: 4px 8px; background: #007aff; color: white; border: none; border-radius: 4px; font-size: 12px;">è·³åˆ°æœ€æ–°</button>
                    </div>
                </div>
                <div class="form-group" style="flex: 1; margin-bottom: 0;">
                    <label for="updateInterval">æ›´æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰:</label>
                    <input type="range" id="updateInterval" min="500" max="5000" value="1000" oninput="updateInterval(this.value)">
                    <span id="intervalValue">1000ms</span>
                </div>
            </div>
        </div>

        <!-- åœºæ™¯æ ‡è®°æ§åˆ¶ -->
        <div class="scene-controls" id="sceneControls" style="display: none;">
            <h4>ğŸ¬ åœºæ™¯æ ‡è®°</h4>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <button class="btn" id="startSelectionBtn" onclick="toggleSelection()">å¼€å§‹é€‰æ‹©æ—¶é—´åŒºåŸŸ</button>
                <input type="text" id="sceneNameInput" placeholder="åœºæ™¯åç§°" style="padding: 8px; border: 1px solid #d2d2d7; border-radius: 6px; width: 200px;">
                <button class="btn" id="saveSceneBtn" onclick="saveScene()" disabled>ä¿å­˜åœºæ™¯</button>
                <button class="btn" id="clearScenesBtn" onclick="clearAllScenes()">æ¸…ç©ºæ‰€æœ‰åœºæ™¯</button>
            </div>
            <div id="selectionStatus" style="font-size: 14px; color: #86868b; margin-bottom: 10px;"></div>
            <div class="scene-list" id="sceneList"></div>
        </div>

        <!-- å•ç‚¹æ ‡ç­¾æ§åˆ¶ -->
        <div class="tag-controls" id="tagControls" style="display: none;">
            <h4>ğŸ·ï¸ å•ç‚¹æ ‡ç­¾</h4>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <span style="font-size: 14px; color: #856404;">åŒå‡»å›¾è¡¨ä»»æ„ä½ç½®æ·»åŠ æ ‡ç­¾</span>
                <button class="btn" id="clearTagsBtn" onclick="clearAllTags()">æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾</button>
            </div>
            <div class="scene-list" id="tagList"></div>
        </div>

        <div class="current-values" id="currentValues" style="display: none;">
            <div class="value-card">
                <div class="label">CPUä½¿ç”¨ç‡</div>
                <div class="value" id="currentCpu">0%</div>
            </div>
            <div class="value-card">
                <div class="label">å†…å­˜ä½¿ç”¨</div>
                <div class="value" id="currentMemory">0MB</div>
            </div>
            <div class="value-card">
                <div class="label">å¸§ç‡</div>
                <div class="value" id="currentFps">0FPS</div>
            </div>
            <div class="value-card">
                <div class="label">çº¿ç¨‹æ•°</div>
                <div class="value" id="currentThreads">0</div>
            </div>
        </div>

        <div class="charts-grid" id="chartsGrid" style="display: none;">
            <div class="chart-container">
                <h3>ğŸ“Š CPUä½¿ç”¨ç‡</h3>
                <div class="chart-wrapper" data-chart="cpu">
                    <canvas id="cpuChart"></canvas>
                    <div class="chart-selection-overlay" id="cpuOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ’¾ å†…å­˜ä½¿ç”¨é‡</h3>
                <div class="chart-wrapper" data-chart="memory">
                    <canvas id="memoryChart"></canvas>
                    <div class="chart-selection-overlay" id="memoryOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ® å¸§ç‡(FPS)</h3>
                <div class="chart-wrapper" data-chart="fps">
                    <canvas id="fpsChart"></canvas>
                    <div class="chart-selection-overlay" id="fpsOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ§µ çº¿ç¨‹æ•°é‡</h3>
                <div class="chart-wrapper" data-chart="threads">
                    <canvas id="threadsChart"></canvas>
                    <div class="chart-selection-overlay" id="threadsOverlay"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WebSocketè¿æ¥
        const socket = io();
        
        // å›¾è¡¨å®ä¾‹
        let cpuChart, memoryChart, fpsChart, threadsChart;
        
        // æ€§èƒ½åˆ†æå…¨å±€å˜é‡
        let performanceStats = {
            cpu: { values: [], sum: 0, max: 0, min: 100, avg: 0 },
            memory: { values: [], sum: 0, max: 0, min: Infinity, avg: 0 },
            fps: { values: [], sum: 0, max: 0, min: Infinity, avg: 0 },
            threads: { values: [], sum: 0, max: 0, min: Infinity, avg: 0 }
        };
        
        let activeAlerts = new Set();
        let lastAlertCheck = 0;
        
        // å†…å­˜æ³„æ¼æ£€æµ‹å˜é‡
        let memoryLeakDetection = {
            startTime: null,
            initialMemory: 0,
            memoryHistory: [],
            leakThreshold: 2, // MB/min
            detectionWindow: 300000, // 5åˆ†é’Ÿæ£€æµ‹çª—å£
            isLeaking: false
        };
        
        // æµ‹è¯•åœºæ™¯å˜é‡
        let currentTestScenario = null;
        let scenarioStartTime = null;
        let scenarioTimer = null;
        
        // æ•°æ®å­˜å‚¨
        let isMonitoring = false;
        let windowSize = 50; // æ˜¾ç¤ºçª—å£å¤§å°
        let timePosition = 100; // æ—¶é—´ä½ç½®ç™¾åˆ†æ¯”ï¼Œ100è¡¨ç¤ºæœ€æ–°
        let allPerformanceData = []; // å­˜å‚¨æ‰€æœ‰æ€§èƒ½æ•°æ®ç”¨äºä¿å­˜
        let allTimeLabels = []; // å­˜å‚¨æ‰€æœ‰æ—¶é—´æ ‡ç­¾
        let allCpuData = []; // å­˜å‚¨æ‰€æœ‰CPUæ•°æ®
        let allMemoryData = []; // å­˜å‚¨æ‰€æœ‰å†…å­˜æ•°æ®
        let allFpsData = []; // å­˜å‚¨æ‰€æœ‰FPSæ•°æ®
        let allThreadsData = []; // å­˜å‚¨æ‰€æœ‰çº¿ç¨‹æ•°æ®
        let currentUpdateInterval = 1000; // å½“å‰æ›´æ–°é—´éš”
        let isFollowingLatest = true; // æ˜¯å¦è·Ÿéšæœ€æ–°æ•°æ®
        
        // åœºæ™¯é€‰æ‹©ç›¸å…³å˜é‡
        let isSelecting = false;
        let selectionStart = null;
        let selectionEnd = null;
        let currentSelection = null;
        let savedScenes = []; // ä¿å­˜çš„åœºæ™¯åˆ—è¡¨
        let isMouseDown = false;
        let selectionStartX = 0;
        
        // æ ‡ç­¾ç›¸å…³å˜é‡
        let savedTags = []; // ä¿å­˜çš„æ ‡ç­¾åˆ—è¡¨
        
        // å›¾è¡¨é…ç½®
        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: 'æ—¶é—´'
                    }
                },
                y: {
                    display: true,
                    beginAtZero: true
                }
            },
            elements: {
                line: {
                    tension: 0.4
                },
                point: {
                    radius: 3
                }
            }
        };

        // åˆå§‹åŒ–å›¾è¡¨
        function initCharts() {
            const cpuCtx = document.getElementById('cpuChart').getContext('2d');
            cpuChart = new Chart(cpuCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'CPUä½¿ç”¨ç‡ (%)',
                        data: [],
                        borderColor: '#ff3b30',
                        backgroundColor: 'rgba(255, 59, 48, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'CPUä½¿ç”¨ç‡ (%)'
                            }
                        }
                    }
                }
            });

            const memoryCtx = document.getElementById('memoryChart').getContext('2d');
            memoryChart = new Chart(memoryCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å†…å­˜ä½¿ç”¨ (MB)',
                        data: [],
                        borderColor: '#007aff',
                        backgroundColor: 'rgba(0, 122, 255, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'å†…å­˜ä½¿ç”¨ (MB)'
                            }
                        }
                    }
                }
            });

            const fpsCtx = document.getElementById('fpsChart').getContext('2d');
            fpsChart = new Chart(fpsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å¸§ç‡ (FPS)',
                        data: [],
                        borderColor: '#34c759',
                        backgroundColor: 'rgba(52, 199, 89, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'å¸§ç‡ (FPS)'
                            },
                            max: 60
                        }
                    }
                }
            });

            const threadsCtx = document.getElementById('threadsChart').getContext('2d');
            threadsChart = new Chart(threadsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'çº¿ç¨‹æ•°é‡',
                        data: [],
                        borderColor: '#ff9500',
                        backgroundColor: 'rgba(255, 149, 0, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'çº¿ç¨‹æ•°é‡'
                            }
                        }
                    }
                }
            });
        }

        // æ·»åŠ æ•°æ®åˆ°å›¾è¡¨
        function addDataToChart(chart, label, data) {
            // å­˜å‚¨åˆ°å…¨å±€æ•°ç»„
            if (chart === cpuChart) {
                allTimeLabels.push(label);
                allCpuData.push(data);
            } else if (chart === memoryChart) {
                allMemoryData.push(data);
            } else if (chart === fpsChart) {
                allFpsData.push(data);
            } else if (chart === threadsChart) {
                allThreadsData.push(data);
            }
            
            // å¦‚æœæ­£åœ¨è·Ÿéšæœ€æ–°æ•°æ®ï¼Œæ›´æ–°æ˜¾ç¤º
            if (isFollowingLatest) {
                updateChartDisplay();
            }
            
            // æ›´æ–°æ ‡ç­¾ä½ç½®ï¼ˆä»…åœ¨CPUå›¾è¡¨æ›´æ–°æ—¶æ‰§è¡Œï¼Œé¿å…é‡å¤ï¼‰
            if (chart === cpuChart && savedTags.length > 0) {
                updateAllTagMarkers();
                updateTagList(); // æ›´æ–°æ ‡ç­¾åˆ—è¡¨çŠ¶æ€
            }
        }

        // æ›´æ–°æ€§èƒ½ç»Ÿè®¡æ•°æ®
        function updatePerformanceStats(cpu, memory, fps, threads) {
            // æ›´æ–°CPUç»Ÿè®¡
            updateStat('cpu', cpu);
            updateStat('memory', memory);
            updateStat('fps', fps);
            updateStat('threads', threads);
            
            // æ›´æ–°UIæ˜¾ç¤º
            updateStatisticsDisplay();
            updatePerformanceScoring();
            checkPerformanceThresholds(cpu, memory, fps, threads);
            updateMemoryLeakDetection(memory);
        }

        function updateStat(metric, value) {
            const stat = performanceStats[metric];
            stat.values.push(value);
            stat.sum += value;
            stat.max = Math.max(stat.max, value);
            stat.min = Math.min(stat.min, value);
            stat.avg = stat.sum / stat.values.length;
            
            // ä¿æŒæœ€è¿‘1000ä¸ªæ•°æ®ç‚¹
            if (stat.values.length > 1000) {
                const removed = stat.values.shift();
                stat.sum -= removed;
                stat.avg = stat.sum / stat.values.length;
            }
        }

        // æ›´æ–°ç»Ÿè®¡é¢æ¿æ˜¾ç¤º
        function updateStatisticsDisplay() {
            // CPUç»Ÿè®¡
            document.getElementById('cpuCurrent').textContent = `${performanceStats.cpu.values[performanceStats.cpu.values.length - 1] || 0}%`;
            document.getElementById('cpuAvg').textContent = `${performanceStats.cpu.avg.toFixed(1)}%`;
            document.getElementById('cpuMax').textContent = `${performanceStats.cpu.max}%`;
            
            // å†…å­˜ç»Ÿè®¡
            document.getElementById('memoryCurrent').textContent = `${(performanceStats.memory.values[performanceStats.memory.values.length - 1] || 0).toFixed(1)}MB`;
            document.getElementById('memoryAvg').textContent = `${performanceStats.memory.avg.toFixed(1)}MB`;
            document.getElementById('memoryMax').textContent = `${performanceStats.memory.max.toFixed(1)}MB`;
            
            // FPSç»Ÿè®¡
            document.getElementById('fpsCurrent').textContent = `${Math.round(performanceStats.fps.values[performanceStats.fps.values.length - 1] || 0)}fps`;
            document.getElementById('fpsAvg').textContent = `${performanceStats.fps.avg.toFixed(1)}fps`;
            document.getElementById('fpsMin').textContent = `${performanceStats.fps.min === Infinity ? 0 : performanceStats.fps.min.toFixed(1)}fps`;
            
            // çº¿ç¨‹ç»Ÿè®¡
            document.getElementById('threadsCurrent').textContent = `${performanceStats.threads.values[performanceStats.threads.values.length - 1] || 0}`;
            document.getElementById('threadsAvg').textContent = `${performanceStats.threads.avg.toFixed(1)}`;
            document.getElementById('threadsMax').textContent = `${performanceStats.threads.max}`;
        }

        // æ€§èƒ½è¯„åˆ†ç³»ç»Ÿ
        function updatePerformanceScoring() {
            const scores = calculatePerformanceScores();
            
            // æ›´æ–°UIæ˜¾ç¤º
            updateScoreDisplay('cpuScore', scores.cpu);
            updateScoreDisplay('memoryScore', scores.memory);
            updateScoreDisplay('fpsScore', scores.fps);
            
            // è®¡ç®—ç»¼åˆè¯„åˆ†
            const overallScore = (scores.cpu.score + scores.memory.score + scores.fps.score) / 3;
            const overallGrade = getGradeFromScore(overallScore);
            
            document.getElementById('overallScore').textContent = overallGrade;
            document.getElementById('overallScore').className = 'score-value ' + getGradeClass(overallGrade);
            document.getElementById('overallScoreNumber').textContent = Math.round(overallScore);
        }

        function calculatePerformanceScores() {
            const cpu = performanceStats.cpu.avg;
            const memory = performanceStats.memory.avg;
            const fps = performanceStats.fps.avg;
            
            return {
                cpu: {
                    score: Math.max(0, 100 - cpu), // CPUä½¿ç”¨ç‡è¶Šä½è¶Šå¥½
                    grade: cpu < 20 ? 'A+' : cpu < 40 ? 'A' : cpu < 60 ? 'B+' : cpu < 80 ? 'B' : 'C'
                },
                memory: {
                    score: Math.max(0, 100 - (memory / 10)), // å†…å­˜ä½¿ç”¨é‡è¯„åˆ†
                    grade: memory < 200 ? 'A+' : memory < 400 ? 'A' : memory < 600 ? 'B+' : memory < 800 ? 'B' : 'C'
                },
                fps: {
                    score: Math.min(100, fps * 2), // FPSè¶Šé«˜è¶Šå¥½
                    grade: fps >= 55 ? 'A+' : fps >= 45 ? 'A' : fps >= 35 ? 'B+' : fps >= 25 ? 'B' : 'C'
                }
            };
        }

        function updateScoreDisplay(elementId, scoreData) {
            const element = document.getElementById(elementId);
            element.textContent = scoreData.grade;
            element.className = 'score-value ' + getGradeClass(scoreData.grade);
        }

        function getGradeFromScore(score) {
            if (score >= 90) return 'A+';
            if (score >= 80) return 'A';
            if (score >= 70) return 'B+';
            if (score >= 60) return 'B';
            if (score >= 50) return 'C';
            return 'D';
        }

        function getGradeClass(grade) {
            if (grade.includes('A')) return 'grade-a';
            if (grade.includes('B')) return 'grade-b';
            if (grade.includes('C')) return 'grade-c';
            if (grade.includes('D')) return 'grade-d';
            return 'grade-f';
        }

        // æ€§èƒ½é˜ˆå€¼æ£€æŸ¥å’Œå‘Šè­¦
        function checkPerformanceThresholds(cpu, memory, fps, threads) {
            const now = Date.now();
            if (now - lastAlertCheck < 2000) return; // é™åˆ¶æ£€æŸ¥é¢‘ç‡
            lastAlertCheck = now;
            
            const thresholds = {
                cpu: parseInt(document.getElementById('cpuThreshold').value),
                memory: parseInt(document.getElementById('memoryThreshold').value),
                fps: parseInt(document.getElementById('fpsThreshold').value),
                threads: parseInt(document.getElementById('threadsThreshold').value)
            };
            
            const alerts = [];
            
            // CPUæ£€æŸ¥
            if (cpu > thresholds.cpu) {
                alerts.push({
                    type: 'critical',
                    metric: 'CPU',
                    value: cpu,
                    threshold: thresholds.cpu,
                    message: `CPUä½¿ç”¨ç‡è¿‡é«˜: ${cpu}% (é˜ˆå€¼: ${thresholds.cpu}%)`
                });
                highlightChart('cpu', true);
            } else {
                highlightChart('cpu', false);
            }
            
            // å†…å­˜æ£€æŸ¥
            if (memory > thresholds.memory) {
                alerts.push({
                    type: 'critical',
                    metric: 'å†…å­˜',
                    value: memory.toFixed(1),
                    threshold: thresholds.memory,
                    message: `å†…å­˜ä½¿ç”¨è¿‡é«˜: ${memory.toFixed(1)}MB (é˜ˆå€¼: ${thresholds.memory}MB)`
                });
                highlightChart('memory', true);
            } else {
                highlightChart('memory', false);
            }
            
            // FPSæ£€æŸ¥
            if (fps < thresholds.fps) {
                alerts.push({
                    type: 'warning',
                    metric: 'FPS',
                    value: fps,
                    threshold: thresholds.fps,
                    message: `å¸§ç‡è¿‡ä½: ${fps}fps (é˜ˆå€¼: ${thresholds.fps}fps)`
                });
                highlightChart('fps', true);
            } else {
                highlightChart('fps', false);
            }
            
            // çº¿ç¨‹æ•°æ£€æŸ¥
            if (threads > thresholds.threads) {
                alerts.push({
                    type: 'warning',
                    metric: 'çº¿ç¨‹',
                    value: threads,
                    threshold: thresholds.threads,
                    message: `çº¿ç¨‹æ•°è¿‡å¤š: ${threads} (é˜ˆå€¼: ${thresholds.threads})`
                });
                highlightChart('threads', true);
            } else {
                highlightChart('threads', false);
            }
            
            updateAlertDisplay(alerts);
        }

        function highlightChart(chartType, highlight) {
            const chartWrapper = document.querySelector(`[data-chart="${chartType}"]`);
            if (chartWrapper) {
                if (highlight) {
                    chartWrapper.classList.add('threshold-exceeded');
                } else {
                    chartWrapper.classList.remove('threshold-exceeded');
                }
            }
        }

        function updateAlertDisplay(alerts) {
            const alertPanel = document.getElementById('performanceAlerts');
            const alertList = document.getElementById('alertList');
            
            if (alerts.length > 0) {
                alertPanel.style.display = 'block';
                alertList.innerHTML = alerts.map(alert => `
                    <div class="alert-item ${alert.type}">
                        <span>${alert.message}</span>
                        <span>${new Date().toLocaleTimeString()}</span>
                    </div>
                `).join('');
            } else {
                alertPanel.style.display = 'none';
            }
        }

        // å†…å­˜æ³„æ¼æ£€æµ‹åŠŸèƒ½
        function updateMemoryLeakDetection(currentMemory) {
            const now = Date.now();
            
            // åˆå§‹åŒ–æ£€æµ‹
            if (!memoryLeakDetection.startTime) {
                memoryLeakDetection.startTime = now;
                memoryLeakDetection.initialMemory = currentMemory;
                updateMonitorDuration();
                return;
            }
            
            // æ›´æ–°ç›‘æ§æ—¶é•¿
            updateMonitorDuration();
            
            // æ·»åŠ åˆ°å†å²è®°å½•
            memoryLeakDetection.memoryHistory.push({
                time: now,
                memory: currentMemory
            });
            
            // ä¿æŒæœ€è¿‘5åˆ†é’Ÿçš„æ•°æ®
            const cutoffTime = now - memoryLeakDetection.detectionWindow;
            memoryLeakDetection.memoryHistory = memoryLeakDetection.memoryHistory.filter(
                record => record.time > cutoffTime
            );
            
            // å†…å­˜æ³„æ¼åˆ†æ
            analyzeMemoryLeak();
        }

        function updateMonitorDuration() {
            if (!memoryLeakDetection.startTime) return;
            
            const duration = Date.now() - memoryLeakDetection.startTime;
            const minutes = Math.floor(duration / 60000);
            const seconds = Math.floor((duration % 60000) / 1000);
            document.getElementById('monitorDuration').textContent = `${minutes}åˆ†${seconds}ç§’`;
        }

        function analyzeMemoryLeak() {
            const history = memoryLeakDetection.memoryHistory;
            if (history.length < 10) return; // éœ€è¦è¶³å¤Ÿçš„æ•°æ®ç‚¹
            
            // è®¡ç®—å†…å­˜å¢é•¿è¶‹åŠ¿
            const recent = history.slice(-10); // æœ€è¿‘10ä¸ªæ•°æ®ç‚¹
            const older = history.slice(0, 10); // è¾ƒæ—©çš„10ä¸ªæ•°æ®ç‚¹
            
            if (older.length === 0) return;
            
            const recentAvg = recent.reduce((sum, item) => sum + item.memory, 0) / recent.length;
            const olderAvg = older.reduce((sum, item) => sum + item.memory, 0) / older.length;
            
            const memoryIncrease = recentAvg - olderAvg;
            const timeSpan = (recent[recent.length - 1].time - older[0].time) / 60000; // åˆ†é’Ÿ
            const leakRate = timeSpan > 0 ? memoryIncrease / timeSpan : 0;
            
            // æ›´æ–°UI
            document.getElementById('leakRate').textContent = `${leakRate.toFixed(2)} MB/min`;
            
            // åˆ¤æ–­å†…å­˜è¶‹åŠ¿
            let trend, status;
            if (leakRate > memoryLeakDetection.leakThreshold) {
                trend = 'æŒç»­å¢é•¿';
                status = 'ç–‘ä¼¼æ³„æ¼';
                memoryLeakDetection.isLeaking = true;
                showMemoryLeakWarning(leakRate, memoryIncrease);
            } else if (leakRate > 0.5) {
                trend = 'ç¼“æ…¢å¢é•¿';
                status = 'éœ€è¦è§‚å¯Ÿ';
                memoryLeakDetection.isLeaking = false;
                hideMemoryLeakWarning();
            } else if (leakRate < -0.5) {
                trend = 'ä¸‹é™';
                status = 'æ­£å¸¸';
                memoryLeakDetection.isLeaking = false;
                hideMemoryLeakWarning();
            } else {
                trend = 'ç¨³å®š';
                status = 'æ­£å¸¸';
                memoryLeakDetection.isLeaking = false;
                hideMemoryLeakWarning();
            }
            
            document.getElementById('memoryTrend').textContent = trend;
            document.getElementById('leakStatus').textContent = status;
            
            // æ›´æ–°çŠ¶æ€é¢œè‰²
            const statusEl = document.getElementById('leakStatus');
            statusEl.style.color = status === 'ç–‘ä¼¼æ³„æ¼' ? '#dc3545' : status === 'éœ€è¦è§‚å¯Ÿ' ? '#ffc107' : '#28a745';
        }

        function showMemoryLeakWarning(leakRate, totalIncrease) {
            const warningEl = document.getElementById('leakWarning');
            const detailsEl = document.getElementById('leakDetails');
            
            warningEl.style.display = 'block';
            warningEl.classList.add('active');
            
            detailsEl.innerHTML = `
                <p>æ£€æµ‹åˆ°æŒç»­çš„å†…å­˜å¢é•¿æ¨¡å¼:</p>
                <ul>
                    <li>å¢é•¿ç‡: ${leakRate.toFixed(2)} MB/åˆ†é’Ÿ</li>
                    <li>æ€»å¢é•¿: ${totalIncrease.toFixed(1)} MB</li>
                    <li>å»ºè®®: æ£€æŸ¥ä»£ç ä¸­çš„å†…å­˜é‡Šæ”¾</li>
                </ul>
            `;
        }

        function hideMemoryLeakWarning() {
            const warningEl = document.getElementById('leakWarning');
            warningEl.style.display = 'none';
            warningEl.classList.remove('active');
        }

        // æµ‹è¯•åœºæ™¯åŠŸèƒ½
        function startScenario(scenarioType) {
            if (currentTestScenario) {
                alert('å·²æœ‰æµ‹è¯•åœºæ™¯åœ¨è¿è¡Œä¸­ï¼Œè¯·å…ˆåœæ­¢å½“å‰æµ‹è¯•');
                return;
            }
            
            const scenarios = {
                'app_launch': { name: 'åº”ç”¨å¯åŠ¨æµ‹è¯•', duration: 30 },
                'stability_test': { name: 'ç¨³å®šæ€§æµ‹è¯•', duration: 600 },
                'memory_stress': { name: 'å†…å­˜å‹åŠ›æµ‹è¯•', duration: 300 },
                'fps_performance': { name: 'FPSæ€§èƒ½æµ‹è¯•', duration: 120 }
            };
            
            const scenario = scenarios[scenarioType];
            if (!scenario) return;
            
            currentTestScenario = {
                type: scenarioType,
                name: scenario.name,
                duration: scenario.duration,
                startTime: Date.now()
            };
            
            // é‡ç½®æ€§èƒ½ç»Ÿè®¡
            resetPerformanceStats();
            
            // æ˜¾ç¤ºå½“å‰æµ‹è¯•ç•Œé¢
            document.getElementById('currentScenario').style.display = 'block';
            document.getElementById('scenarioName').textContent = scenario.name;
            
            // å¯åŠ¨å®šæ—¶å™¨
            updateScenarioProgress();
            scenarioTimer = setInterval(updateScenarioProgress, 1000);
            
            showStatus(`å¼€å§‹${scenario.name}`, 'info');
        }

        function updateScenarioProgress() {
            if (!currentTestScenario) return;
            
            const elapsed = (Date.now() - currentTestScenario.startTime) / 1000;
            const progress = Math.min(100, (elapsed / currentTestScenario.duration) * 100);
            
            document.getElementById('scenarioProgress').style.width = `${progress}%`;
            
            const elapsedMin = Math.floor(elapsed / 60);
            const elapsedSec = Math.floor(elapsed % 60);
            const totalMin = Math.floor(currentTestScenario.duration / 60);
            const totalSec = currentTestScenario.duration % 60;
            
            document.getElementById('scenarioTime').textContent = 
                `${elapsedMin.toString().padStart(2, '0')}:${elapsedSec.toString().padStart(2, '0')} / ${totalMin.toString().padStart(2, '0')}:${totalSec.toString().padStart(2, '0')}`;
            
            // æµ‹è¯•å®Œæˆ
            if (elapsed >= currentTestScenario.duration) {
                stopCurrentScenario();
                generateScenarioReport();
            }
        }

        function stopCurrentScenario() {
            if (scenarioTimer) {
                clearInterval(scenarioTimer);
                scenarioTimer = null;
            }
            
            if (currentTestScenario) {
                showStatus(`${currentTestScenario.name}å·²å®Œæˆ`, 'success');
            }
            
            currentTestScenario = null;
            document.getElementById('currentScenario').style.display = 'none';
        }

        function generateScenarioReport() {
            if (!currentTestScenario) return;
            
            const report = {
                scenarioName: currentTestScenario.name,
                duration: currentTestScenario.duration,
                averageCpu: performanceStats.cpu.avg.toFixed(1),
                maxCpu: performanceStats.cpu.max,
                averageMemory: performanceStats.memory.avg.toFixed(1),
                maxMemory: performanceStats.memory.max.toFixed(1),
                averageFps: performanceStats.fps.avg.toFixed(1),
                minFps: performanceStats.fps.min === Infinity ? 0 : performanceStats.fps.min.toFixed(1),
                performanceScore: calculateOverallScore()
            };
            
            // è¿™é‡Œå¯ä»¥å¼¹çª—æ˜¾ç¤ºæŠ¥å‘Šæˆ–è€…ä¿å­˜åˆ°æ–‡ä»¶
            alert(`æµ‹è¯•æŠ¥å‘Š:\n` +
                  `åœºæ™¯: ${report.scenarioName}\n` +
                  `å¹³å‡CPU: ${report.averageCpu}%\n` +
                  `å¹³å‡å†…å­˜: ${report.averageMemory}MB\n` +
                  `å¹³å‡FPS: ${report.averageFps}\n` +
                  `æ€§èƒ½è¯„åˆ†: ${report.performanceScore}`);
        }

        function calculateOverallScore() {
            const scores = calculatePerformanceScores();
            return Math.round((scores.cpu.score + scores.memory.score + scores.fps.score) / 3);
        }

        function resetPerformanceStats() {
            Object.keys(performanceStats).forEach(key => {
                performanceStats[key] = { values: [], sum: 0, max: 0, min: key === 'cpu' ? 100 : Infinity, avg: 0 };
            });
            
            // é‡ç½®å†…å­˜æ³„æ¼æ£€æµ‹
            memoryLeakDetection.startTime = null;
            memoryLeakDetection.memoryHistory = [];
            memoryLeakDetection.isLeaking = false;
        }

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.classList.remove('hidden');
        }

        // éšè—çŠ¶æ€æ¶ˆæ¯
        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        // çª—å£å¤§å°å’Œæ—¶é—´ä½ç½®æ§åˆ¶å‡½æ•°
        function updateWindowSize(value) {
            windowSize = parseInt(value);
            document.getElementById('windowSizeValue').textContent = windowSize + 'ä¸ªç‚¹';
            updateChartDisplay();
        }

        function updateTimePosition(value) {
            timePosition = parseInt(value);
            isFollowingLatest = (timePosition === 100);
            
            if (isFollowingLatest) {
                document.getElementById('timePosition').textContent = 'æœ€æ–°';
            } else {
                const totalData = allTimeLabels.length;
                const endIndex = Math.floor((timePosition / 100) * totalData);
                const startIndex = Math.max(0, endIndex - windowSize);
                document.getElementById('timePosition').textContent = `${startIndex}-${endIndex}`;
            }
            
            updateChartDisplay();
        }

        function goToLatest() {
            timePosition = 100;
            isFollowingLatest = true;
            document.getElementById('timeSlider').value = 100;
            document.getElementById('timePosition').textContent = 'æœ€æ–°';
            updateChartDisplay();
        }

        function updateChartDisplay() {
            if (allTimeLabels.length === 0) return;

            let startIndex, endIndex;
            
            if (isFollowingLatest) {
                // è·Ÿéšæœ€æ–°æ•°æ®
                endIndex = allTimeLabels.length;
                startIndex = Math.max(0, endIndex - windowSize);
            } else {
                // æ ¹æ®æ—¶é—´ä½ç½®è®¡ç®—æ˜¾ç¤ºèŒƒå›´
                const totalData = allTimeLabels.length;
                endIndex = Math.floor((timePosition / 100) * totalData);
                startIndex = Math.max(0, endIndex - windowSize);
                endIndex = Math.min(totalData, startIndex + windowSize);
            }

            // æ›´æ–°æ‰€æœ‰å›¾è¡¨çš„æ˜¾ç¤ºæ•°æ®
            updateChartData(cpuChart, allTimeLabels.slice(startIndex, endIndex), allCpuData.slice(startIndex, endIndex));
            updateChartData(memoryChart, allTimeLabels.slice(startIndex, endIndex), allMemoryData.slice(startIndex, endIndex));
            updateChartData(fpsChart, allTimeLabels.slice(startIndex, endIndex), allFpsData.slice(startIndex, endIndex));
            updateChartData(threadsChart, allTimeLabels.slice(startIndex, endIndex), allThreadsData.slice(startIndex, endIndex));

            // æ›´æ–°æ‹–åŠ¨æ¡çš„èŒƒå›´
            if (allTimeLabels.length > windowSize) {
                const maxSliderValue = Math.floor(((allTimeLabels.length - windowSize) / allTimeLabels.length) * 100);
                document.getElementById('timeSlider').max = 100;
                if (!isFollowingLatest && timePosition > maxSliderValue) {
                    timePosition = maxSliderValue;
                    document.getElementById('timeSlider').value = timePosition;
                }
            }
            
            // æ›´æ–°æ ‡ç­¾ä½ç½®
            updateAllTagMarkers();
        }

        function updateChartData(chart, labels, data) {
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update('none');
        }

        function updateInterval(value) {
            currentUpdateInterval = parseInt(value);
            document.getElementById('intervalValue').textContent = value + 'ms';
        }

        // æ ‡ç­¾åŠŸèƒ½
        function enableDoubleClickTags() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('dblclick', onDoubleClickTag);
            });
        }

        function onDoubleClickTag(e) {
            if (isSelecting) return; // é€‰æ‹©æ¨¡å¼ä¸‹ä¸æ·»åŠ æ ‡ç­¾
            
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // è®¡ç®—æ—¶é—´ç´¢å¼•
            const clickIndex = Math.floor((clickX / chartWidth) * (cpuChart.data.labels.length));
            const timeLabel = cpuChart.data.labels[clickIndex];
            
            if (timeLabel) {
                // å¼¹å‡ºè¾“å…¥æ¡†è®©ç”¨æˆ·è¾“å…¥æ ‡ç­¾å†…å®¹
                const tagNote = prompt('è¯·è¾“å…¥æ ‡ç­¾å¤‡æ³¨:', '');
                if (tagNote !== null && tagNote.trim() !== '') {
                    addTag(timeLabel, tagNote.trim(), clickX, chartWidth);
                }
            }
        }

        function addTag(timeLabel, note, clickX, chartWidth) {
            const tag = {
                id: Date.now(),
                time: timeLabel,
                note: note,
                createdAt: new Date().toISOString()
            };

            savedTags.push(tag);
            updateTagList();
            
            // åœ¨æ‰€æœ‰å›¾è¡¨ä¸Šæ·»åŠ æ ‡ç­¾æ ‡è®°
            addTagMarkersToAllCharts(tag);
            
            showStatus(`æ ‡ç­¾ "${note}" å·²æ·»åŠ åˆ° ${timeLabel}`, 'success');
        }

        function addTagMarkersToAllCharts(tag) {
            // ä¸åœ¨è¿™é‡Œç›´æ¥æ·»åŠ DOMå…ƒç´ ï¼Œè€Œæ˜¯åœ¨updateAllTagMarkersä¸­ç»Ÿä¸€å¤„ç†
            updateAllTagMarkers();
        }

        function updateAllTagMarkers() {
            // åˆ é™¤æ‰€æœ‰ç°æœ‰çš„æ ‡è®°
            const existingMarkers = document.querySelectorAll('.chart-tag-marker');
            existingMarkers.forEach(marker => marker.remove());

            // é‡æ–°æ·»åŠ æ‰€æœ‰æ ‡ç­¾æ ‡è®°
            if (cpuChart && cpuChart.data.labels.length > 0) {
                savedTags.forEach(tag => {
                    // æ‰¾åˆ°æ ‡ç­¾æ—¶é—´åœ¨å½“å‰å›¾è¡¨ä¸­çš„ä½ç½®
                    const timeIndex = cpuChart.data.labels.findIndex(label => label === tag.time);
                    if (timeIndex !== -1 && timeIndex >= 0 && timeIndex < cpuChart.data.labels.length) {
                        // ç¡®ä¿ä½ç½®åœ¨0-100%èŒƒå›´å†…
                        const position = Math.max(0, Math.min(100, (timeIndex / Math.max(1, cpuChart.data.labels.length - 1)) * 100));
                        
                        const chartWrappers = document.querySelectorAll('.chart-wrapper');
                        chartWrappers.forEach(wrapper => {
                            const marker = document.createElement('div');
                            marker.className = 'chart-tag-marker';
                            marker.style.left = position + '%';
                            marker.title = `${tag.time}: ${tag.note}`;
                            marker.setAttribute('data-tag-id', tag.id);
                            wrapper.appendChild(marker);
                        });
                    }
                });
            }
        }

        function updateTagList() {
            const tagList = document.getElementById('tagList');
            tagList.innerHTML = '';
            
            savedTags.forEach(tag => {
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-item';
                
                // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦åœ¨å½“å‰æ—¶é—´çª—å£å†…
                const isVisible = cpuChart && cpuChart.data.labels.includes(tag.time);
                const statusText = isVisible ? '' : ' (å·²ç§»å‡ºæ—¶é—´çª—å£)';
                const statusStyle = isVisible ? '' : 'opacity: 0.6; font-style: italic;';
                
                tagItem.innerHTML = `
                    <div class="tag-info" style="${statusStyle}">
                        <div class="tag-time">${tag.time}${statusText}</div>
                        <div class="tag-note">${tag.note}</div>
                    </div>
                    <div class="tag-actions">
                        <button onclick="deleteTag(${tag.id})">åˆ é™¤</button>
                    </div>
                `;
                tagList.appendChild(tagItem);
            });
        }

        function deleteTag(tagId) {
            savedTags = savedTags.filter(tag => tag.id !== tagId);
            updateTagList();
            
            // é‡æ–°æ›´æ–°æ‰€æœ‰æ ‡ç­¾ä½ç½®
            updateAllTagMarkers();
            
            showStatus('æ ‡ç­¾å·²åˆ é™¤', 'info');
        }

        function clearAllTags() {
            if (savedTags.length === 0) return;
            if (confirm('ç¡®è®¤æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾ï¼Ÿ')) {
                savedTags = [];
                updateTagList();
                
                // é‡æ–°æ›´æ–°æ ‡ç­¾ï¼ˆä¼šæ¸…ç©ºæ‰€æœ‰ï¼‰
                updateAllTagMarkers();
                
                showStatus('æ‰€æœ‰æ ‡ç­¾å·²æ¸…ç©º', 'info');
            }
        }

        // ä¿å­˜æ•°æ®å‡½æ•°ï¼ˆè°ƒç”¨æ–°çš„åŒ…å«åœºæ™¯çš„ä¿å­˜åŠŸèƒ½ï¼‰
        function saveData() {
            saveDataWithScenes();
        }

        // å¯¼å…¥æ•°æ®å‡½æ•°
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.data || !Array.isArray(importedData.data)) {
                        showStatus('æ— æ•ˆçš„æ•°æ®æ–‡ä»¶æ ¼å¼', 'error');
                        return;
                    }

                    // åœæ­¢å½“å‰ç›‘æ§
                    if (isMonitoring) {
                        stopMonitoring();
                    }

                    // æ¸…ç©ºç°æœ‰å›¾è¡¨
                    clearAllCharts();
                    
                    // æ˜¾ç¤ºå›¾è¡¨åŒºåŸŸ
                    document.getElementById('chartsGrid').style.display = 'grid';
                    document.getElementById('currentValues').style.display = 'grid';
                    document.getElementById('timeControls').style.display = 'block';
                    document.getElementById('sceneControls').style.display = 'block';
                    document.getElementById('tagControls').style.display = 'block';
                    initCharts();
                    enableDoubleClickTags(); // å¯ç”¨åŒå‡»æ ‡ç­¾åŠŸèƒ½

                    // æ¢å¤è®¾ç½®
                    if (importedData.settings) {
                        if (importedData.settings.isUnlimited) {
                            setUnlimited();
                        } else if (importedData.settings.maxDataPoints) {
                            document.getElementById('timeRange').value = importedData.settings.maxDataPoints;
                            updateTimeRange(importedData.settings.maxDataPoints);
                        }
                    }

                    // æ‰¹é‡æ·»åŠ å¯¼å…¥çš„æ•°æ®
                    let dataCount = 0;
                    importedData.data.forEach(item => {
                        if (item.type === 'performance') {
                            addDataToChart(cpuChart, item.time, item.cpu);
                            addDataToChart(memoryChart, item.time, item.memory);
                            addDataToChart(threadsChart, item.time, item.threads);
                            
                            // æ›´æ–°å½“å‰å€¼æ˜¾ç¤º
                            document.getElementById('currentCpu').textContent = `${item.cpu}%`;
                            document.getElementById('currentMemory').textContent = `${item.memory.toFixed(1)}MB`;
                            document.getElementById('currentThreads').textContent = item.threads;
                            dataCount++;
                        } else if (item.type === 'fps') {
                            addDataToChart(fpsChart, item.time, item.fps);
                            document.getElementById('currentFps').textContent = `${item.fps}FPS`;
                        }
                    });

                    // å¯¼å…¥åœºæ™¯æ•°æ®
                    if (importedData.scenes && Array.isArray(importedData.scenes)) {
                        savedScenes = importedData.scenes;
                        updateSceneList();
                    }

                    // å¯¼å…¥æ ‡ç­¾æ•°æ®
                    if (importedData.tags && Array.isArray(importedData.tags)) {
                        savedTags = importedData.tags;
                        updateTagList();
                        // æ¢å¤æ ‡ç­¾æ ‡è®°
                        updateAllTagMarkers();
                    }

                    let statusMessage = `æˆåŠŸå¯¼å…¥ ${dataCount} æ¡æ€§èƒ½è®°å½•`;
                    if (importedData.scenes && importedData.scenes.length > 0) {
                        statusMessage += `ï¼Œ${importedData.scenes.length} ä¸ªåœºæ™¯`;
                    }
                    if (importedData.tags && importedData.tags.length > 0) {
                        statusMessage += `ï¼Œ${importedData.tags.length} ä¸ªæ ‡ç­¾`;
                    }
                    statusMessage += `ï¼Œæ¥è‡ª ${importedData.timestamp}`;
                    showStatus(statusMessage, 'success');
                    
                } catch (error) {
                    showStatus('æ–‡ä»¶è§£æå¤±è´¥: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
            
            // æ¸…ç©ºfile input
            event.target.value = '';
        }

        function clearAllCharts() {
            if (cpuChart) {
                cpuChart.data.labels = [];
                cpuChart.data.datasets[0].data = [];
                cpuChart.update();
                
                memoryChart.data.labels = [];
                memoryChart.data.datasets[0].data = [];
                memoryChart.update();
                
                fpsChart.data.labels = [];
                fpsChart.data.datasets[0].data = [];
                fpsChart.update();
                
                threadsChart.data.labels = [];
                threadsChart.data.datasets[0].data = [];
                threadsChart.update();
                
                // æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾æ ‡è®°
                const existingMarkers = document.querySelectorAll('.chart-tag-marker');
                existingMarkers.forEach(marker => marker.remove());
            }
        }

        // å¼€å§‹ç›‘æ§
        function startMonitoring() {
            const udid = document.getElementById('udid').value.trim();
            const bundleId = document.getElementById('bundleId').value.trim();
            
            showStatus('æ­£åœ¨å¯åŠ¨ç›‘æ§...', 'info');
            
            // æ¸…ç©ºä¹‹å‰çš„æ•°æ®
            allPerformanceData = [];
            
            socket.emit('start_monitoring', {
                udid: udid,
                bundle_id: bundleId
            });
            
            isMonitoring = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('saveBtn').disabled = false;
        }

        // åœæ­¢ç›‘æ§
        function stopMonitoring() {
            if (!isMonitoring) return;
            
            // å‘é€åœæ­¢ä¿¡å·åˆ°åç«¯
            socket.emit('stop_monitoring');
            
            showStatus('æ­£åœ¨åœæ­¢ç›‘æ§...', 'info');
        }

        // Socket.IOäº‹ä»¶å¤„ç†
        // åœºæ™¯ç®¡ç†åŠŸèƒ½
        function toggleSelection() {
            isSelecting = !isSelecting;
            const btn = document.getElementById('startSelectionBtn');
            const statusEl = document.getElementById('selectionStatus');
            
            if (isSelecting) {
                btn.textContent = 'å–æ¶ˆé€‰æ‹©';
                btn.style.background = '#ff3b30';
                statusEl.textContent = 'è¯·åœ¨ä»»æ„å›¾è¡¨ä¸Šæ‹–æ‹½é€‰æ‹©æ—¶é—´åŒºåŸŸ';
                document.body.classList.add('selecting');
                enableChartSelection();
            } else {
                btn.textContent = 'å¼€å§‹é€‰æ‹©æ—¶é—´åŒºåŸŸ';
                btn.style.background = '#007aff';
                statusEl.textContent = '';
                document.body.classList.remove('selecting');
                disableChartSelection();
                clearCurrentSelection();
            }
        }

        function enableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('mousedown', onSelectionStart);
                wrapper.addEventListener('mousemove', onSelectionMove);
                wrapper.addEventListener('mouseup', onSelectionEnd);
                wrapper.addEventListener('mouseleave', onSelectionEnd);
            });
        }

        function disableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.removeEventListener('mousedown', onSelectionStart);
                wrapper.removeEventListener('mousemove', onSelectionMove);
                wrapper.removeEventListener('mouseup', onSelectionEnd);
                wrapper.removeEventListener('mouseleave', onSelectionEnd);
            });
        }

        function onSelectionStart(e) {
            if (!isSelecting) return;
            isMouseDown = true;
            const rect = e.currentTarget.getBoundingClientRect();
            selectionStartX = e.clientX - rect.left;
            clearCurrentSelection();
        }

        function onSelectionMove(e) {
            if (!isSelecting || !isMouseDown) return;
            const rect = e.currentTarget.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const width = Math.abs(currentX - selectionStartX);
            const left = Math.min(selectionStartX, currentX);
            
            // åŒæ­¥æ˜¾ç¤ºé€‰æ‹©åŒºåŸŸåˆ°æ‰€æœ‰å›¾è¡¨
            updateAllSelectionOverlays(left, width);
        }

        function onSelectionEnd(e) {
            if (!isSelecting || !isMouseDown) return;
            isMouseDown = false;
            
            const rect = e.currentTarget.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // è®¡ç®—æ—¶é—´ç´¢å¼•
            const startIndex = Math.floor((Math.min(selectionStartX, endX) / chartWidth) * maxDataPoints);
            const endIndex = Math.floor((Math.max(selectionStartX, endX) / chartWidth) * maxDataPoints);
            
            if (Math.abs(endX - selectionStartX) > 10) { // æœ€å°é€‰æ‹©å®½åº¦
                // è·å–æ—¶é—´æ ‡ç­¾
                const timeLabels = cpuChart.data.labels;
                selectionStart = timeLabels[Math.max(0, startIndex)] || '';
                selectionEnd = timeLabels[Math.min(timeLabels.length - 1, endIndex)] || '';
                
                if (selectionStart && selectionEnd) {
                    document.getElementById('saveSceneBtn').disabled = false;
                    document.getElementById('selectionStatus').textContent = 
                        `å·²é€‰æ‹©æ—¶é—´æ®µ: ${selectionStart} - ${selectionEnd}`;
                }
            }
        }

        function updateAllSelectionOverlays(left, width) {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                const overlay = document.getElementById(overlayId);
                overlay.style.display = 'block';
                overlay.style.left = left + 'px';
                overlay.style.width = width + 'px';
                overlay.style.top = '0px';
                overlay.style.height = '100%';
            });
        }

        function clearCurrentSelection() {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                document.getElementById(overlayId).style.display = 'none';
            });
            selectionStart = null;
            selectionEnd = null;
            document.getElementById('saveSceneBtn').disabled = true;
        }

        function saveScene() {
            const sceneName = document.getElementById('sceneNameInput').value.trim();
            if (!sceneName) {
                showStatus('è¯·è¾“å…¥åœºæ™¯åç§°', 'error');
                return;
            }
            
            if (!selectionStart || !selectionEnd) {
                showStatus('è¯·å…ˆé€‰æ‹©æ—¶é—´åŒºåŸŸ', 'error');
                return;
            }

            // è·å–é€‰æ‹©æ—¶é—´æ®µå†…çš„æ€§èƒ½æ•°æ®
            const sceneData = allPerformanceData.filter(item => {
                return item.time >= selectionStart && item.time <= selectionEnd;
            });

            const scene = {
                id: Date.now(),
                name: sceneName,
                startTime: selectionStart,
                endTime: selectionEnd,
                data: sceneData,
                createdAt: new Date().toISOString(),
                summary: generateSceneSummary(sceneData)
            };

            savedScenes.push(scene);
            updateSceneList();
            
            // åœ¨æ‰€æœ‰å›¾è¡¨ä¸Šæ·»åŠ æ°¸ä¹…æ ‡è®°
            addSceneMarkersToAllCharts(scene);
            
            // æ¸…ç©ºè¾“å…¥å’Œé€‰æ‹©
            document.getElementById('sceneNameInput').value = '';
            clearCurrentSelection();
            toggleSelection(); // é€€å‡ºé€‰æ‹©æ¨¡å¼
            
            showStatus(`åœºæ™¯ "${sceneName}" å·²ä¿å­˜`, 'success');
        }

        function generateSceneSummary(sceneData) {
            const perfData = sceneData.filter(item => item.type === 'performance');
            const fpsData = sceneData.filter(item => item.type === 'fps');
            
            if (perfData.length === 0) return {};
            
            const cpuValues = perfData.map(item => item.cpu);
            const memoryValues = perfData.map(item => item.memory);
            const fpsValues = fpsData.map(item => item.fps);
            
            return {
                duration: perfData.length,
                avgCpu: (cpuValues.reduce((a, b) => a + b, 0) / cpuValues.length).toFixed(2),
                maxCpu: Math.max(...cpuValues).toFixed(2),
                avgMemory: (memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length).toFixed(1),
                maxMemory: Math.max(...memoryValues).toFixed(1),
                avgFps: fpsValues.length > 0 ? (fpsValues.reduce((a, b) => a + b, 0) / fpsValues.length).toFixed(1) : 0,
                minFps: fpsValues.length > 0 ? Math.min(...fpsValues) : 0
            };
        }

        function addSceneMarkersToAllCharts(scene) {
            // è¿™é‡Œæ·»åŠ æ°¸ä¹…çš„åœºæ™¯æ ‡è®°åˆ°æ‰€æœ‰å›¾è¡¨
            // Chart.jsæ’ä»¶å¯ä»¥å®ç°ï¼Œä½†ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å…ˆåœ¨åœºæ™¯åˆ—è¡¨ä¸­æ˜¾ç¤º
        }

        function updateSceneList() {
            const sceneList = document.getElementById('sceneList');
            sceneList.innerHTML = '';
            
            savedScenes.forEach(scene => {
                const sceneItem = document.createElement('div');
                sceneItem.className = 'scene-item';
                sceneItem.innerHTML = `
                    <div class="scene-info">
                        <div><strong>${scene.name}</strong></div>
                        <div class="scene-time">${scene.startTime} - ${scene.endTime}</div>
                        <div style="font-size: 11px; color: #86868b;">
                            å¹³å‡CPU: ${scene.summary.avgCpu}% | å¹³å‡å†…å­˜: ${scene.summary.avgMemory}MB | å¹³å‡FPS: ${scene.summary.avgFps}
                        </div>
                    </div>
                    <div class="scene-actions">
                        <button onclick="deleteScene(${scene.id})">åˆ é™¤</button>
                    </div>
                `;
                sceneList.appendChild(sceneItem);
            });
        }

        function deleteScene(sceneId) {
            savedScenes = savedScenes.filter(scene => scene.id !== sceneId);
            updateSceneList();
            showStatus('åœºæ™¯å·²åˆ é™¤', 'info');
        }

        function clearAllScenes() {
            if (savedScenes.length === 0) return;
            if (confirm('ç¡®è®¤æ¸…ç©ºæ‰€æœ‰åœºæ™¯æ ‡è®°ï¼Ÿ')) {
                savedScenes = [];
                updateSceneList();
                showStatus('æ‰€æœ‰åœºæ™¯å·²æ¸…ç©º', 'info');
            }
        }

        // ä¿®æ”¹ä¿å­˜æ•°æ®å‡½æ•°ï¼ŒåŒ…å«åœºæ™¯å’Œæ ‡ç­¾ä¿¡æ¯
        function saveDataWithScenes() {
            if (allTimeLabels.length === 0 && savedScenes.length === 0 && savedTags.length === 0) {
                showStatus('æ²¡æœ‰æ•°æ®ã€åœºæ™¯æˆ–æ ‡ç­¾å¯ä¿å­˜', 'error');
                return;
            }

            // é‡æ–°æ„å»ºæ€§èƒ½æ•°æ®æ•°ç»„
            const performanceData = [];
            for (let i = 0; i < allTimeLabels.length; i++) {
                performanceData.push({
                    timestamp: allTimeLabels[i],
                    cpu: allCpuData[i] || 0,
                    memory: allMemoryData[i] || 0,
                    fps: allFpsData[i] || 0,
                    threads: allThreadsData[i] || 0
                });
            }

            const now = new Date();
            const filename = `ios_performance_complete_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}.json`;
            
            const dataToSave = {
                timestamp: now.toISOString(),
                device_udid: document.getElementById('udid').value.trim(),
                bundle_id: document.getElementById('bundleId').value.trim(),
                data: performanceData,
                scenes: savedScenes, // åŒ…å«åœºæ™¯ä¿¡æ¯
                tags: savedTags, // åŒ…å«æ ‡ç­¾ä¿¡æ¯
                settings: {
                    windowSize: windowSize,
                    timePosition: timePosition
                },
                summary: {
                    total_records: performanceData.length,
                    total_scenes: savedScenes.length,
                    total_tags: savedTags.length,
                    duration_seconds: performanceData.length > 0 ? 
                        Math.round((new Date(performanceData[performanceData.length-1].timestamp) - new Date(performanceData[0].timestamp)) / 1000) : 0
                }
            };

            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`æ•°æ®å’Œåœºæ™¯å·²ä¿å­˜åˆ° ${filename}`, 'success');
        }

        socket.on('monitoring_started', function(data) {
            if (data.status === 'success') {
                isMonitoring = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('saveBtn').disabled = false;
                showStatus('ç›‘æ§å·²å¯åŠ¨ï¼Œæ­£åœ¨æ”¶é›†æ•°æ®...', 'success');
                document.getElementById('chartsGrid').style.display = 'grid';
                document.getElementById('currentValues').style.display = 'grid';
                document.getElementById('thresholdControls').style.display = 'block';
                document.getElementById('scoringPanel').style.display = 'block';
                document.getElementById('memoryLeakPanel').style.display = 'block';
                document.getElementById('testScenariosPanel').style.display = 'block';
                document.getElementById('statisticsPanel').style.display = 'block';
                document.getElementById('timeControls').style.display = 'block';
                document.getElementById('sceneControls').style.display = 'block';
                document.getElementById('tagControls').style.display = 'block';
                initCharts();
                enableDoubleClickTags(); // å¯ç”¨åŒå‡»æ ‡ç­¾åŠŸèƒ½
            }
        });

        socket.on('monitoring_stopped', function(data) {
            if (data.status === 'success') {
                isMonitoring = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('saveBtn').disabled = true;
                showStatus('ç›‘æ§å·²åœæ­¢', 'success');
            }
        });

        socket.on('performance_data', function(data) {
            if (!isMonitoring) return;
            
            // ä¿å­˜åˆ°allPerformanceDataç”¨äºå¯¼å‡º
            allPerformanceData.push({
                type: 'performance',
                timestamp: new Date().toISOString(),
                time: data.time,
                cpu: data.cpu,
                memory: data.memory,
                threads: data.threads,
                pid: data.pid,
                name: data.name
            });
            
            // æ›´æ–°å½“å‰å€¼æ˜¾ç¤º
            document.getElementById('currentCpu').textContent = `${data.cpu}%`;
            document.getElementById('currentMemory').textContent = `${data.memory.toFixed(1)}MB`;
            document.getElementById('currentThreads').textContent = data.threads;
            
            // æ·»åŠ æ•°æ®åˆ°å›¾è¡¨
            addDataToChart(cpuChart, data.time, data.cpu);
            addDataToChart(memoryChart, data.time, data.memory);
            addDataToChart(threadsChart, data.time, data.threads);
            
            // æ›´æ–°æ€§èƒ½ç»Ÿè®¡åˆ†æ
            updatePerformanceStats(data.cpu, data.memory, 0, data.threads); // FPSå•ç‹¬å¤„ç†
        });

        socket.on('fps_data', function(data) {
            if (!isMonitoring) return;
            
            // ä¿å­˜åˆ°allPerformanceDataç”¨äºå¯¼å‡º
            allPerformanceData.push({
                type: 'fps',
                timestamp: new Date().toISOString(),
                time: data.time,
                fps: data.fps
            });
            
            // æ›´æ–°å½“å‰FPSæ˜¾ç¤º
            document.getElementById('currentFps').textContent = `${data.fps}FPS`;
            
            // æ·»åŠ FPSæ•°æ®åˆ°å›¾è¡¨
            addDataToChart(fpsChart, data.time, data.fps);
            
            // å•ç‹¬æ›´æ–°FPSç»Ÿè®¡
            updateStat('fps', data.fps);
        });

        socket.on('connect', function() {
            console.log('å·²è¿æ¥åˆ°æœåŠ¡å™¨');
        });

        socket.on('disconnect', function() {
            console.log('ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥');
            if (isMonitoring) {
                showStatus('ä¸æœåŠ¡å™¨è¿æ¥æ–­å¼€', 'error');
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–ç•Œé¢å·²åŠ è½½');
        });
    </script>
</body>
</html>
