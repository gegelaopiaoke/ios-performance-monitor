<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f7;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #1d1d1f;
            margin-bottom: 10px;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        .controls h3 {
            margin-top: 0;
            color: #1d1d1f;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #424245;
        }
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        .form-group input:focus {
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }
        .btn {
            background: #007aff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .btn:hover {
            background: #0056cc;
        }
        .btn:disabled {
            background: #d2d2d7;
            cursor: not-allowed;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .chart-container h3 {
            margin: 0 0 20px 0;
            color: #1d1d1f;
            font-size: 18px;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .current-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .value-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .value-card .label {
            font-size: 12px;
            color: #86868b;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        .value-card .value {
            font-size: 24px;
            font-weight: 600;
            color: #1d1d1f;
        }
        .hidden {
            display: none;
        }
        
        /* ç»Ÿè®¡é¢æ¿æ ·å¼ */
        .stat-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        .stat-current {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 8px;
        }
        .stat-details {
            font-size: 11px;
            color: #888;
            line-height: 1.4;
        }
        
        /* å†…å­˜æ³„æ¼æ£€æµ‹æ ·å¼ */
        .leak-warning {
            background: #f8d7da;
            border: 2px solid #dc3545;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }
        .leak-warning.active {
            display: block;
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        /* æ‹–æ‹½åŠŸèƒ½æ ·å¼ */
        .controls {
            position: relative;
            cursor: move;
            transition: transform 0.2s ease;
        }
        
        .controls:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        
        .controls.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        .controls h3 {
            user-select: none;
            position: relative;
        }
        
        .controls h3::before {
            content: 'â‹®â‹®';
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
            font-size: 14px;
            line-height: 1;
        }
        
        .controls:hover h3::before {
            color: #666;
        }
        
        .drag-placeholder {
            height: 100px;
            background: linear-gradient(90deg, #e3f2fd, #f5f5f5);
            border: 2px dashed #2196f3;
            border-radius: 12px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #2196f3;
            font-weight: bold;
            opacity: 0.7;
        }
        
        .drag-placeholder::before {
            content: 'é‡Šæ”¾åˆ°è¿™é‡Œ';
        }
        
        /* é‡ç½®æŒ‰é’®æ ·å¼ */
        .header .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .header .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .header small {
            opacity: 0.8;
            font-style: italic;
        }
        
        /* åˆ†äº«å¯¹è¯æ¡†æ ·å¼ */
        .share-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .share-dialog-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }
        
        .share-url {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
            position: relative;
        }
        
        .copy-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
            transition: background 0.3s ease;
        }
        
        .copy-btn:hover {
            background: #218838;
        }
        
        .copy-btn.copied {
            background: #17a2b8;
        }
        
        .close-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
        }
        
        .close-btn:hover {
            background: #5a6268;
        }
        
        .share-tips {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .share-tips h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        
        .share-tips ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .share-tips li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“± iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–</h1>
            <p>åŸºäºåŸå§‹main.pyé€»è¾‘çš„å®æ—¶æ€§èƒ½å›¾è¡¨æ˜¾ç¤º</p>
            <div style="margin-top: 15px;">
                <button class="btn" onclick="resetPanelOrder()" title="æ¢å¤é¢æ¿é»˜è®¤é¡ºåº">ğŸ”„ é‡ç½®é¢æ¿é¡ºåº</button>
                <button class="btn" onclick="showShareDialog()" title="è·å–åˆ†äº«é“¾æ¥">ğŸ”— åˆ†äº«æ•°æ®</button>
                <small style="margin-left: 10px; color: #666;">ğŸ’¡ æç¤º: ç‚¹å‡»é¢æ¿æ ‡é¢˜å·¦ä¾§çš„ â‹®â‹® å›¾æ ‡å¯æ‹–æ‹½è°ƒæ•´é¡ºåº</small>
            </div>
        </div>

        <div class="controls">
            <h3>ğŸ”§ ç›‘æ§é…ç½®</h3>
            <div class="form-group">
                <label for="deviceSelect">é€‰æ‹©è®¾å¤‡:</label>
                <select id="deviceSelect" onchange="onDeviceChanged()">
                    <option value="">æ£€æµ‹ä¸­...</option>
                </select>
                <button type="button" onclick="refreshDevices()" style="margin-left: 8px; padding: 8px 12px; border: 1px solid #007AFF; background: #007AFF; color: white; border-radius: 6px; cursor: pointer;">åˆ·æ–°è®¾å¤‡</button>
            </div>
            <div class="form-group">
                <label for="appSearch">æœç´¢åº”ç”¨:</label>
                <input type="text" id="appSearch" placeholder="è¾“å…¥åº”ç”¨åç§°æˆ–Bundle IDæœç´¢..." oninput="filterApps()">
            </div>
            <div class="form-group">
                <label for="appSelect">é€‰æ‹©åº”ç”¨:</label>
                <select id="appSelect" size="8" style="width: 100%; height: 200px;" onchange="onAppSelected()">
                    <option value="">è¯·å…ˆé€‰æ‹©è®¾å¤‡</option>
                </select>
                <button type="button" onclick="refreshApps()" style="margin-top: 8px; padding: 8px 12px; border: 1px solid #007AFF; background: #007AFF; color: white; border-radius: 6px; cursor: pointer;">åˆ·æ–°åº”ç”¨åˆ—è¡¨</button>
            </div>
            <div class="form-group" style="display: none;">
                <label for="udid">è®¾å¤‡UDID:</label>
                <input type="text" id="udid" readonly>
            </div>
            <div class="form-group" style="display: none;">
                <label for="bundleId">åº”ç”¨Bundle ID:</label>
                <input type="text" id="bundleId" readonly>
            </div>
            <button class="btn" id="startBtn" onclick="startMonitoring()">å¼€å§‹ç›‘æ§</button>
            <button class="btn" id="stopBtn" onclick="stopMonitoring()" disabled>åœæ­¢ç›‘æ§</button>
            
            <!-- å¯¼å‡ºæ•°æ®æ§åˆ¶ -->
            <div style="display: inline-flex; align-items: center; gap: 8px;">
                <select id="exportFormat" style="padding: 8px; border: 1px solid #d2d2d7; border-radius: 6px; font-size: 14px;">
                    <option value="json">JSONæ ¼å¼</option>
                    <option value="csv">CSVæ ¼å¼</option>
                </select>
                <button class="btn" id="saveBtn" onclick="saveData()" disabled>ğŸ“¥ å¯¼å‡ºæ•°æ®</button>
            </div>
            
            <button class="btn" id="importBtn" onclick="document.getElementById('fileInput').click()">ğŸ“¤ å¯¼å…¥æ•°æ®</button>
            <input type="file" id="fileInput" accept=".json,.csv" style="display: none;" onchange="importData(event)">
        </div>

        <div id="status" class="status hidden"></div>

        <div class="current-values" id="currentValues" style="display: none;">
            <div class="value-card">
                <div class="label">CPUä½¿ç”¨ç‡</div>
                <div class="value" id="currentCpu">0%</div>
            </div>
            <div class="value-card">
                <div class="label">å†…å­˜ä½¿ç”¨</div>
                <div class="value" id="currentMemory">0MB</div>
            </div>
            <div class="value-card">
                <div class="label">å¸§ç‡</div>
                <div class="value" id="currentFps">0FPS</div>
            </div>
            <div class="value-card">
                <div class="label">çº¿ç¨‹æ•°</div>
                <div class="value" id="currentThreads">0</div>
            </div>
            <div class="value-card">
                <div class="label">ç£ç›˜è¯»å–</div>
                <div class="value" id="currentDiskReads">0MB</div>
            </div>
            <div class="value-card">
                <div class="label">ç£ç›˜å†™å…¥</div>
                <div class="value" id="currentDiskWrites">0MB</div>
            </div>
        </div>

        <!-- æ•°æ®ç»Ÿè®¡é¢æ¿ -->
        <div class="controls" id="statisticsPanel">
            <h3>ğŸ“ˆ æ•°æ®ç»Ÿè®¡</h3>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div class="stat-card">
                    <div class="stat-label">CPUä½¿ç”¨ç‡</div>
                    <div class="stat-current" id="statCpuCurrent">0%</div>
                    <div class="stat-details">
                        å¹³å‡: <span id="statCpuAvg">0%</span> | 
                        æœ€å¤§: <span id="statCpuMax">0%</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">å†…å­˜ä½¿ç”¨</div>
                    <div class="stat-current" id="statMemoryCurrent">0MB</div>
                    <div class="stat-details">
                        å¹³å‡: <span id="statMemoryAvg">0MB</span> | 
                        æœ€å¤§: <span id="statMemoryMax">0MB</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">å¸§ç‡</div>
                    <div class="stat-current" id="statFpsCurrent">0FPS</div>
                    <div class="stat-details">
                        å¹³å‡: <span id="statFpsAvg">0FPS</span> | 
                        æœ€ä½: <span id="statFpsMin">0FPS</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">çº¿ç¨‹æ•°</div>
                    <div class="stat-current" id="statThreadsCurrent">0</div>
                    <div class="stat-details">
                        å¹³å‡: <span id="statThreadsAvg">0</span> | 
                        æœ€å¤§: <span id="statThreadsMax">0</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ç£ç›˜è¯»å–</div>
                    <div class="stat-current" id="statDiskReadsCurrent">0MB</div>
                    <div class="stat-details">
                        å¹³å‡: <span id="statDiskReadsAvg">0MB</span> | 
                        æœ€å¤§: <span id="statDiskReadsMax">0MB</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ç£ç›˜å†™å…¥</div>
                    <div class="stat-current" id="statDiskWritesCurrent">0MB</div>
                    <div class="stat-details">
                        å¹³å‡: <span id="statDiskWritesAvg">0MB</span> | 
                        æœ€å¤§: <span id="statDiskWritesMax">0MB</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="charts-grid" id="chartsGrid" style="display: none;">
            <div class="chart-container">
                <h3>ğŸ“Š CPUä½¿ç”¨ç‡</h3>
                <div class="chart-wrapper" data-chart="cpu">
                    <canvas id="cpuChart"></canvas>
                    <div class="chart-selection-overlay" id="cpuOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ’¾ å†…å­˜ä½¿ç”¨é‡</h3>
                <div class="chart-wrapper" data-chart="memory">
                    <canvas id="memoryChart"></canvas>
                    <div class="chart-selection-overlay" id="memoryOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ® å¸§ç‡(FPS)</h3>
                <div class="chart-wrapper" data-chart="fps">
                    <canvas id="fpsChart"></canvas>
                    <div class="chart-selection-overlay" id="fpsOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ§µ çº¿ç¨‹æ•°é‡</h3>
                <div class="chart-wrapper" data-chart="threads">
                    <canvas id="threadsChart"></canvas>
                    <div class="chart-selection-overlay" id="threadsOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ’¾ ç£ç›˜è¯»å–</h3>
                <div class="chart-wrapper" data-chart="disk_reads">
                    <canvas id="diskReadsChart"></canvas>
                    <div class="chart-selection-overlay" id="diskReadsOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ’¿ ç£ç›˜å†™å…¥</h3>
                <div class="chart-wrapper" data-chart="disk_writes">
                    <canvas id="diskWritesChart"></canvas>
                    <div class="chart-selection-overlay" id="diskWritesOverlay"></div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // WebSocketè¿æ¥
        // ä¼˜åŒ–Socket.IOè¿æ¥ï¼Œå‡å°‘å»¶è¿Ÿ
        const socket = io({
            transports: ['websocket'],  // å¼ºåˆ¶ä½¿ç”¨WebSocketï¼Œé¿å…è½®è¯¢
            upgrade: false,             // ä¸è¿›è¡Œä¼ è¾“å‡çº§
            rememberUpgrade: false,     // ä¸è®°ä½å‡çº§
            forceNew: true,             // å¼ºåˆ¶æ–°è¿æ¥
            timeout: 1000,              // è¿æ¥è¶…æ—¶1ç§’
            pingTimeout: 5000,          // pingè¶…æ—¶5ç§’
            pingInterval: 1000,         // æ¯1ç§’pingä¸€æ¬¡
            maxHttpBufferSize: 1e6,     // 1MBç¼“å†²åŒº
            connectTimeout: 1000        // è¿æ¥è¶…æ—¶1ç§’
        });
        
        // å›¾è¡¨å®ä¾‹
        let cpuChart, memoryChart, fpsChart, threadsChart, diskReadsChart, diskWritesChart;
        
        // æ•°æ®å­˜å‚¨
        let isMonitoring = false;
        let windowSize = 50; // æ˜¾ç¤ºçª—å£å¤§å°
        let timePosition = 100; // æ—¶é—´ä½ç½®ç™¾åˆ†æ¯”ï¼Œ100è¡¨ç¤ºæœ€æ–°
        let allPerformanceData = []; // å­˜å‚¨æ‰€æœ‰æ€§èƒ½æ•°æ®ç”¨äºä¿å­˜
        
        // è®¾å¤‡å’Œåº”ç”¨ç®¡ç†
        let connectedDevices = [];
        let installedApps = [];
        let allApps = []; // å­˜å‚¨å®Œæ•´åº”ç”¨åˆ—è¡¨ç”¨äºæœç´¢
        
        // æ€§èƒ½é˜ˆå€¼é…ç½®
        let thresholds = {
            cpu: 80,
            memory: 200,
            fps: 30,
            threads: 50
        };
        
        // æ€§èƒ½ç»Ÿè®¡æ•°æ®
        let performanceStats = {
            cpu: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
            memory: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
            fps: { current: 0, avg: 0, min: Infinity, sum: 0, count: 0 },
            threads: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
            diskReads: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
            diskWrites: { current: 0, avg: 0, max: 0, sum: 0, count: 0 }
        };
        
        // ä¸“ä¸šçº§å†…å­˜æ³„æ¼æ£€æµ‹ç³»ç»Ÿ
        let professionalMemoryLeakDetection = {
            // åœºæ™¯çŠ¶æ€æœº
            sceneStateMachine: {
                currentScene: 'unknown',
                previousScene: 'unknown',
                sceneHistory: [],
                sceneStartTime: null,
                sceneStartMemory: 0,
                sceneTransitionCount: 0
            },
            
            // åœºæ™¯å®šä¹‰å’ŒåŸºçº¿
            sceneProfiles: {
                'idle': { 
                    name: 'ç©ºé—²çŠ¶æ€', 
                    expectedMemory: { min: 80, max: 150 }, 
                    color: '#4CAF50',
                    priority: 1 
                },
                'launching': { 
                    name: 'åº”ç”¨å¯åŠ¨', 
                    expectedMemory: { min: 120, max: 200 }, 
                    color: '#FF9800',
                    priority: 3 
                },
                'video_playing': { 
                    name: 'è§†é¢‘æ’­æ”¾', 
                    expectedMemory: { min: 200, max: 400 }, 
                    color: '#F44336',
                    priority: 4 
                },
                'navigation': { 
                    name: 'ç•Œé¢å¯¼èˆª', 
                    expectedMemory: { min: 100, max: 180 }, 
                    color: '#2196F3',
                    priority: 2 
                },
                'background': { 
                    name: 'åå°è¿è¡Œ', 
                    expectedMemory: { min: 60, max: 120 }, 
                    color: '#9C27B0',
                    priority: 1 
                }
            },
            
            // å†…å­˜å†å²æ•°æ®
            memoryHistory: [],
            maxHistoryLength: 200,
            
            // æ£€æµ‹å‚æ•°
            detection: {
                minSampleSize: 15,              // æœ€å°æ ·æœ¬æ•°é‡
                sceneMinDuration: 10000,        // åœºæ™¯æœ€å°æŒç»­æ—¶é—´ (10ç§’)
                leakThreshold: 0.85,            // å†…å­˜å›æ”¶ç‡é˜ˆå€¼ (85%)
                anomalyThreshold: 2.5,          // å¼‚å¸¸æ£€æµ‹æ ‡å‡†å·®å€æ•°
                trendAnalysisWindow: 30,        // è¶‹åŠ¿åˆ†æçª—å£å¤§å°
                gcDetectionThreshold: 15        // GCæ£€æµ‹é˜ˆå€¼ (MB)
            },
            
            // æ£€æµ‹çŠ¶æ€
            status: {
                isLeaking: false,
                leakLevel: 'none',              // none, mild, moderate, severe
                leakSources: [],
                lastGCTime: null,
                gcFrequency: 0,
                suspiciousTransitions: []
            },
            
            // ç»Ÿè®¡æ•°æ®
            statistics: {
                totalLeaksDetected: 0,
                falsePositiveRate: 0,
                averageRecoveryRate: 0,
                sceneTransitionMatrix: {}
            }
        };
        
        // å…¼å®¹æ—§ç³»ç»Ÿ
        let memoryLeakDetection = {
            memoryHistory: [],
            leakThreshold: 2,
            detectionWindow: 300000,
            isLeaking: false
        };
        
        // æ´»è·ƒå‘Šè­¦åˆ—è¡¨
        let activeAlerts = [];
        let allTimeLabels = []; // å­˜å‚¨æ‰€æœ‰æ—¶é—´æ ‡ç­¾
        let allCpuData = []; // å­˜å‚¨æ‰€æœ‰CPUæ•°æ®
        let allMemoryData = []; // å­˜å‚¨æ‰€æœ‰å†…å­˜æ•°æ®
        let allFpsData = []; // å­˜å‚¨æ‰€æœ‰FPSæ•°æ®
        let allThreadsData = []; // å­˜å‚¨æ‰€æœ‰çº¿ç¨‹æ•°æ®
        let allDiskReadsData = []; // å­˜å‚¨æ‰€æœ‰ç£ç›˜è¯»å–æ•°æ®
        let allDiskWritesData = []; // å­˜å‚¨æ‰€æœ‰ç£ç›˜å†™å…¥æ•°æ®
        let currentUpdateInterval = 1000; // å½“å‰æ›´æ–°é—´éš”
        let isFollowingLatest = true; // æ˜¯å¦è·Ÿéšæœ€æ–°æ•°æ®
        
        // åœºæ™¯é€‰æ‹©ç›¸å…³å˜é‡
        let isSelecting = false;
        let selectionStart = null;
        let selectionEnd = null;
        let currentSelection = null;
        let savedScenes = []; // ä¿å­˜çš„åœºæ™¯åˆ—è¡¨
        let isMouseDown = false;
        let selectionStartX = 0;
        
        // æ ‡ç­¾ç›¸å…³å˜é‡
        let savedTags = []; // ä¿å­˜çš„æ ‡ç­¾åˆ—è¡¨
        
        // å›¾è¡¨é…ç½®
        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: 'æ—¶é—´'
                    }
                },
                y: {
                    display: true,
                    beginAtZero: true
                }
            },
            elements: {
                line: {
                    tension: 0.4
                },
                point: {
                    radius: 3
                }
            }
        };

        // åˆå§‹åŒ–å›¾è¡¨
        function initCharts() {
            // æ£€æŸ¥æ‰€æœ‰canvaså…ƒç´ æ˜¯å¦å­˜åœ¨
            const cpuCanvas = document.getElementById('cpuChart');
            const memoryCanvas = document.getElementById('memoryChart');
            const fpsCanvas = document.getElementById('fpsChart');
            const threadsCanvas = document.getElementById('threadsChart');
            const diskReadsCanvas = document.getElementById('diskReadsChart');
            const diskWritesCanvas = document.getElementById('diskWritesChart');
            
            if (!cpuCanvas || !memoryCanvas || !fpsCanvas || !threadsCanvas || !diskReadsCanvas || !diskWritesCanvas) {
                console.error('å›¾è¡¨canvaså…ƒç´ æœªæ‰¾åˆ°ï¼Œè·³è¿‡åˆå§‹åŒ–');
                return;
            }
            
            const cpuCtx = cpuCanvas.getContext('2d');
            cpuChart = new Chart(cpuCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'CPUä½¿ç”¨ç‡ (%)',
                        data: [],
                        borderColor: '#ff3b30',
                        backgroundColor: 'rgba(255, 59, 48, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'CPUä½¿ç”¨ç‡ (%)'
                            }
                        }
                    }
                }
            });

            const memoryCtx = memoryCanvas.getContext('2d');
            memoryChart = new Chart(memoryCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å†…å­˜ä½¿ç”¨ (MB)',
                        data: [],
                        borderColor: '#007aff',
                        backgroundColor: 'rgba(0, 122, 255, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'å†…å­˜ä½¿ç”¨ (MB)'
                            }
                        }
                    }
                }
            });

            const fpsCtx = fpsCanvas.getContext('2d');
            fpsChart = new Chart(fpsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å¸§ç‡ (FPS)',
                        data: [],
                        borderColor: '#34c759',
                        backgroundColor: 'rgba(52, 199, 89, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'å¸§ç‡ (FPS)'
                            },
                            max: 60
                        }
                    }
                }
            });

            const threadsCtx = threadsCanvas.getContext('2d');
            threadsChart = new Chart(threadsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'çº¿ç¨‹æ•°é‡',
                        data: [],
                        borderColor: '#ff9500',
                        backgroundColor: 'rgba(255, 149, 0, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'çº¿ç¨‹æ•°é‡'
                            }
                        }
                    }
                }
            });

            // ç£ç›˜è¯»å–å›¾è¡¨
            const diskReadsCtx = diskReadsCanvas.getContext('2d');
            diskReadsChart = new Chart(diskReadsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'ç£ç›˜è¯»å– (MB/s)',
                        data: [],
                        borderColor: '#007aff',
                        backgroundColor: 'rgba(0, 122, 255, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'ç£ç›˜è¯»å– (MB/s)'
                            }
                        }
                    }
                }
            });

            // ç£ç›˜å†™å…¥å›¾è¡¨
            const diskWritesCtx = diskWritesCanvas.getContext('2d');
            diskWritesChart = new Chart(diskWritesCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'ç£ç›˜å†™å…¥ (MB/s)',
                        data: [],
                        borderColor: '#ff3b30',
                        backgroundColor: 'rgba(255, 59, 48, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'ç£ç›˜å†™å…¥ (MB/s)'
                            }
                        }
                    }
                }
            });
        }

        // æ·»åŠ æ•°æ®åˆ°å›¾è¡¨
        function addDataToChart(chart, label, data) {
            // å­˜å‚¨åˆ°å…¨å±€æ•°ç»„
            if (chart === cpuChart) {
                allTimeLabels.push(label);
                allCpuData.push(data);
            } else if (chart === memoryChart) {
                allMemoryData.push(data);
            } else if (chart === fpsChart) {
                allFpsData.push(data);
            } else if (chart === threadsChart) {
                allThreadsData.push(data);
            } else if (chart === diskReadsChart) {
                allDiskReadsData.push(data);
            } else if (chart === diskWritesChart) {
                allDiskWritesData.push(data);
            }
            
            // å¦‚æœæ­£åœ¨è·Ÿéšæœ€æ–°æ•°æ®ï¼Œç«‹å³æ›´æ–°æ˜¾ç¤ºï¼ˆæ— å»¶è¿Ÿï¼‰
            if (isFollowingLatest) {
                updateChartDisplay(); // ç›´æ¥è°ƒç”¨ï¼Œä¸ä½¿ç”¨requestAnimationFrame
            }
            
            // æ›´æ–°æ ‡ç­¾ä½ç½®ï¼ˆä»…åœ¨CPUå›¾è¡¨æ›´æ–°æ—¶æ‰§è¡Œï¼Œé¿å…é‡å¤ï¼‰
            if (chart === cpuChart && savedTags.length > 0) {
                updateAllTagMarkers();
                updateTagList(); // æ›´æ–°æ ‡ç­¾åˆ—è¡¨çŠ¶æ€
            }
        }

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.classList.remove('hidden');
        }

        // éšè—çŠ¶æ€æ¶ˆæ¯
        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        // çª—å£å¤§å°å’Œæ—¶é—´ä½ç½®æ§åˆ¶å‡½æ•°
        function updateWindowSize(value) {
            windowSize = parseInt(value);
            document.getElementById('windowSizeValue').textContent = windowSize + 'ä¸ªç‚¹';
            updateChartDisplay();
        }

        function updateTimePosition(value) {
            timePosition = parseInt(value);
            isFollowingLatest = (timePosition === 100);
            
            if (isFollowingLatest) {
                document.getElementById('timePosition').textContent = 'æœ€æ–°';
            } else {
                const totalData = allTimeLabels.length;
                const endIndex = Math.floor((timePosition / 100) * totalData);
                const startIndex = Math.max(0, endIndex - windowSize);
                document.getElementById('timePosition').textContent = `${startIndex}-${endIndex}`;
            }
            
            updateChartDisplay();
        }

        function goToLatest() {
            timePosition = 100;
            isFollowingLatest = true;
            document.getElementById('timeSlider').value = 100;
            document.getElementById('timePosition').textContent = 'æœ€æ–°';
            updateChartDisplay();
        }

        function updateChartDisplay() {
            if (allTimeLabels.length === 0) return;

            let startIndex, endIndex;
            
            if (isFollowingLatest) {
                // è·Ÿéšæœ€æ–°æ•°æ®
                endIndex = allTimeLabels.length;
                startIndex = Math.max(0, endIndex - windowSize);
            } else {
                // æ ¹æ®æ—¶é—´ä½ç½®è®¡ç®—æ˜¾ç¤ºèŒƒå›´
                const totalData = allTimeLabels.length;
                endIndex = Math.floor((timePosition / 100) * totalData);
                startIndex = Math.max(0, endIndex - windowSize);
                endIndex = Math.min(totalData, startIndex + windowSize);
            }

            // æ›´æ–°æ‰€æœ‰å›¾è¡¨çš„æ˜¾ç¤ºæ•°æ®
            if (cpuChart) updateChartData(cpuChart, allTimeLabels.slice(startIndex, endIndex), allCpuData.slice(startIndex, endIndex));
            if (memoryChart) updateChartData(memoryChart, allTimeLabels.slice(startIndex, endIndex), allMemoryData.slice(startIndex, endIndex));
            if (fpsChart) updateChartData(fpsChart, allTimeLabels.slice(startIndex, endIndex), allFpsData.slice(startIndex, endIndex));
            if (threadsChart) updateChartData(threadsChart, allTimeLabels.slice(startIndex, endIndex), allThreadsData.slice(startIndex, endIndex));
            if (diskReadsChart) updateChartData(diskReadsChart, allTimeLabels.slice(startIndex, endIndex), allDiskReadsData.slice(startIndex, endIndex));
            if (diskWritesChart) updateChartData(diskWritesChart, allTimeLabels.slice(startIndex, endIndex), allDiskWritesData.slice(startIndex, endIndex));

            // æ›´æ–°æ‹–åŠ¨æ¡çš„èŒƒå›´
            if (allTimeLabels.length > windowSize) {
                const maxSliderValue = Math.floor(((allTimeLabels.length - windowSize) / allTimeLabels.length) * 100);
                document.getElementById('timeSlider').max = 100;
                if (!isFollowingLatest && timePosition > maxSliderValue) {
                    timePosition = maxSliderValue;
                    document.getElementById('timeSlider').value = timePosition;
                }
            }
            
            // æ›´æ–°æ ‡ç­¾ä½ç½®
            updateAllTagMarkers();
        }

        function updateChartData(chart, labels, data) {
            if (!chart || !chart.data) {
                console.warn('å›¾è¡¨å¯¹è±¡æœªåˆå§‹åŒ–ï¼Œè·³è¿‡æ›´æ–°');
                return;
            }
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update('none');
        }

        function updateInterval(value) {
            currentUpdateInterval = parseInt(value);
            document.getElementById('intervalValue').textContent = value + 'ms';
        }

        // æ ‡ç­¾åŠŸèƒ½
        function enableDoubleClickTags() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            if (!chartWrappers || chartWrappers.length === 0) {
                console.warn('å›¾è¡¨å®¹å™¨å…ƒç´ æœªæ‰¾åˆ°ï¼Œè·³è¿‡æ ‡ç­¾åŠŸèƒ½åˆå§‹åŒ–');
                return;
            }
            
            chartWrappers.forEach(wrapper => {
                if (wrapper) {
                    wrapper.addEventListener('dblclick', onDoubleClickTag);
                }
            });
        }

        function onDoubleClickTag(e) {
            if (isSelecting) return; // é€‰æ‹©æ¨¡å¼ä¸‹ä¸æ·»åŠ æ ‡ç­¾
            if (!e || !e.currentTarget) return; // æ£€æŸ¥äº‹ä»¶å¯¹è±¡
            
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // æ£€æŸ¥å›¾è¡¨æ˜¯å¦å­˜åœ¨
            if (!cpuChart || !cpuChart.data || !cpuChart.data.labels) {
                console.warn('å›¾è¡¨æœªåˆå§‹åŒ–ï¼Œæ— æ³•æ·»åŠ æ ‡ç­¾');
                return;
            }
            
            // è®¡ç®—æ—¶é—´ç´¢å¼•
            const clickIndex = Math.floor((clickX / chartWidth) * (cpuChart.data.labels.length));
            const timeLabel = cpuChart.data.labels[clickIndex];
            
            if (timeLabel) {
                // å¼¹å‡ºè¾“å…¥æ¡†è®©ç”¨æˆ·è¾“å…¥æ ‡ç­¾å†…å®¹
                const tagNote = prompt('è¯·è¾“å…¥æ ‡ç­¾å¤‡æ³¨:', '');
                if (tagNote !== null && tagNote.trim() !== '') {
                    addTag(timeLabel, tagNote.trim(), clickX, chartWidth);
                }
            }
        }

        function addTag(timeLabel, note, clickX, chartWidth) {
            const tag = {
                id: Date.now(),
                time: timeLabel,
                note: note,
                createdAt: new Date().toISOString()
            };

            savedTags.push(tag);
            updateTagList();
            
            // åœ¨æ‰€æœ‰å›¾è¡¨ä¸Šæ·»åŠ æ ‡ç­¾æ ‡è®°
            addTagMarkersToAllCharts(tag);
            
            showStatus(`æ ‡ç­¾ "${note}" å·²æ·»åŠ åˆ° ${timeLabel}`, 'success');
        }

        function addTagMarkersToAllCharts(tag) {
            // ä¸åœ¨è¿™é‡Œç›´æ¥æ·»åŠ DOMå…ƒç´ ï¼Œè€Œæ˜¯åœ¨updateAllTagMarkersä¸­ç»Ÿä¸€å¤„ç†
            updateAllTagMarkers();
        }

        function updateAllTagMarkers() {
            // åˆ é™¤æ‰€æœ‰ç°æœ‰çš„æ ‡è®°
            const existingMarkers = document.querySelectorAll('.chart-tag-marker');
            existingMarkers.forEach(marker => {
                if (marker && marker.parentNode) {
                    marker.remove();
                }
            });

            // æ£€æŸ¥å›¾è¡¨æ˜¯å¦å­˜åœ¨
            if (!cpuChart || !cpuChart.data || !cpuChart.data.labels || cpuChart.data.labels.length === 0) {
                return;
            }
            
            // é‡æ–°æ·»åŠ æ‰€æœ‰æ ‡ç­¾æ ‡è®°
            savedTags.forEach(tag => {
                if (!tag || !tag.time) return;
                
                // æ‰¾åˆ°æ ‡ç­¾æ—¶é—´åœ¨å½“å‰å›¾è¡¨ä¸­çš„ä½ç½®
                const timeIndex = cpuChart.data.labels.findIndex(label => label === tag.time);
                if (timeIndex !== -1 && timeIndex >= 0 && timeIndex < cpuChart.data.labels.length) {
                    // ç¡®ä¿ä½ç½®åœ¨0-100%èŒƒå›´å†…
                    const position = Math.max(0, Math.min(100, (timeIndex / Math.max(1, cpuChart.data.labels.length - 1)) * 100));
                    
                    const chartWrappers = document.querySelectorAll('.chart-wrapper');
                    chartWrappers.forEach(wrapper => {
                        if (!wrapper) return;
                        
                        const marker = document.createElement('div');
                        marker.className = 'chart-tag-marker';
                        marker.style.left = position + '%';
                        marker.title = `${tag.time}: ${tag.note}`;
                        marker.setAttribute('data-tag-id', tag.id);
                        wrapper.appendChild(marker);
                    });
                }
            });
        }

        function updateTagList() {
            const tagList = document.getElementById('tagList');
            if (!tagList) {
                console.warn('æ ‡ç­¾åˆ—è¡¨å…ƒç´ æœªæ‰¾åˆ°');
                return;
            }
            
            tagList.innerHTML = '';
            
            savedTags.forEach(tag => {
                if (!tag) return;
                
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-item';
                
                // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦åœ¨å½“å‰æ—¶é—´çª—å£å†…
                const isVisible = cpuChart && cpuChart.data && cpuChart.data.labels && cpuChart.data.labels.includes(tag.time);
                const statusText = isVisible ? '' : ' (å·²ç§»å‡ºæ—¶é—´çª—å£)';
                const statusStyle = isVisible ? '' : 'opacity: 0.6; font-style: italic;';
                
                tagItem.innerHTML = `
                    <div class="tag-info" style="${statusStyle}">
                        <div class="tag-time">${tag.time}${statusText}</div>
                        <div class="tag-note">${tag.note}</div>
                    </div>
                    <div class="tag-actions">
                        <button onclick="deleteTag(${tag.id})">åˆ é™¤</button>
                    </div>
                `;
                tagList.appendChild(tagItem);
            });
        }

        function deleteTag(tagId) {
            savedTags = savedTags.filter(tag => tag.id !== tagId);
            updateTagList();
            
            // é‡æ–°æ›´æ–°æ‰€æœ‰æ ‡ç­¾ä½ç½®
            updateAllTagMarkers();
            
            showStatus('æ ‡ç­¾å·²åˆ é™¤', 'info');
        }

        function clearAllTags() {
            if (savedTags.length === 0) return;
            if (confirm('ç¡®è®¤æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾ï¼Ÿ')) {
                savedTags = [];
                updateTagList();
                
                // é‡æ–°æ›´æ–°æ ‡ç­¾ï¼ˆä¼šæ¸…ç©ºæ‰€æœ‰ï¼‰
                updateAllTagMarkers();
                
                showStatus('æ‰€æœ‰æ ‡ç­¾å·²æ¸…ç©º', 'info');
            }
        }

        // ä¿å­˜æ•°æ®å‡½æ•°ï¼ˆè°ƒç”¨æ–°çš„åŒ…å«åœºæ™¯çš„ä¿å­˜åŠŸèƒ½ï¼‰
        function saveData() {
            const exportFormat = document.getElementById('exportFormat').value;
            if (exportFormat === 'csv') {
                saveDataAsCSV();
            } else {
                saveDataWithScenes();
            }
        }

        // CSVæ•°æ®è§£æå‡½æ•°
        function parseCSVData(csvContent) {
            const lines = csvContent.split('\n');
            if (lines.length < 2) {
                throw new Error('CSVæ–‡ä»¶å†…å®¹ä¸è¶³');
            }

            // è§£æè¡¨å¤´
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            console.log('CSV Headers:', headers);

            // éªŒè¯å¿…è¦çš„åˆ—æ˜¯å¦å­˜åœ¨
            const requiredColumns = ['Timestamp', 'CPU Usage (%)', 'Memory Usage (MB)', 'FPS', 'Thread Count'];
            const missingColumns = requiredColumns.filter(col => 
                !headers.some(h => h.includes(col.split(' ')[0]))
            );
            
            if (missingColumns.length > 0) {
                throw new Error(`CSVæ–‡ä»¶ç¼ºå°‘å¿…è¦åˆ—: ${missingColumns.join(', ')}`);
            }

            // è§£ææ•°æ®è¡Œ
            const data = [];
            const scenes = [];
            const tags = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue; // è·³è¿‡ç©ºè¡Œ

                // ç®€å•çš„CSVè§£æï¼ˆå¤„ç†é€—å·åˆ†éš”ï¼‰
                const values = parseCSVLine(line);
                if (values.length < headers.length) continue;

                try {
                    // åˆ›å»ºæ•°æ®è®°å½•
                    const record = {
                        timestamp: values[0].replace(/"/g, ''),
                        cpu: parseFloat(values[2]) || 0,
                        memory: parseFloat(values[3]) || 0,
                        fps: parseFloat(values[4]) || 0,
                        threads: parseInt(values[5]) || 0
                    };

                    data.push(record);

                    // å¤„ç†åœºæ™¯ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                    if (values.length > 6 && values[6] && values[6].trim() !== '') {
                        const sceneName = values[6].replace(/"/g, '').trim();
                        // é¿å…é‡å¤åœºæ™¯
                        if (!scenes.some(s => s.name === sceneName)) {
                            scenes.push({
                                name: sceneName,
                                startTime: record.timestamp,
                                endTime: record.timestamp // å°†åœ¨åé¢æ›´æ–°
                            });
                        } else {
                            // æ›´æ–°åœºæ™¯ç»“æŸæ—¶é—´
                            const scene = scenes.find(s => s.name === sceneName);
                            if (scene) {
                                scene.endTime = record.timestamp;
                            }
                        }
                    }

                    // å¤„ç†æ ‡ç­¾ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                    if (values.length > 7 && values[7] && values[7].trim() !== '') {
                        const tagNote = values[7].replace(/"/g, '').trim();
                        tags.push({
                            time: record.timestamp,
                            note: tagNote,
                            id: 'csv_tag_' + Date.now() + '_' + i
                        });
                    }
                } catch (err) {
                    console.warn(`è·³è¿‡ç¬¬${i+1}è¡Œæ•°æ®ï¼Œè§£æé”™è¯¯:`, err);
                }
            }

            return {
                data: data,
                scenes: scenes,
                tags: tags,
                summary: {
                    total_records: data.length,
                    total_scenes: scenes.length,
                    total_tags: tags.length
                }
            };
        }

        // è§£æCSVè¡Œï¼ˆå¤„ç†å¼•å·å’Œé€—å·ï¼‰
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            let i = 0;

            while (i < line.length) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        // è½¬ä¹‰çš„å¼•å·
                        current += '"';
                        i += 2;
                    } else {
                        // å¼€å§‹æˆ–ç»“æŸå¼•å·
                        inQuotes = !inQuotes;
                        i++;
                    }
                } else if (char === ',' && !inQuotes) {
                    // å­—æ®µåˆ†éš”ç¬¦
                    result.push(current);
                    current = '';
                    i++;
                } else {
                    current += char;
                    i++;
                }
            }
            
            result.push(current); // æœ€åä¸€ä¸ªå­—æ®µ
            return result;
        }

        // å¯¼å…¥æ•°æ®å‡½æ•°
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileContent = e.target.result;
                    let importedData;
                    
                    // æ ¹æ®æ–‡ä»¶æ‰©å±•åæˆ–å†…å®¹åˆ¤æ–­æ ¼å¼
                    if (file.name.toLowerCase().endsWith('.csv') || fileContent.startsWith('Timestamp,')) {
                        // CSVæ ¼å¼å¯¼å…¥
                        importedData = parseCSVData(fileContent);
                    } else {
                        // JSONæ ¼å¼å¯¼å…¥
                        importedData = JSON.parse(fileContent);
                    }
                    
                    if (!importedData || !importedData.data || !Array.isArray(importedData.data)) {
                        showStatus('æ— æ•ˆçš„æ•°æ®æ–‡ä»¶æ ¼å¼', 'error');
                        return;
                    }

                    // åœæ­¢å½“å‰ç›‘æ§
                    if (isMonitoring) {
                        stopMonitoring();
                    }

                    // æ¸…ç©ºç°æœ‰å›¾è¡¨
                    clearAllCharts();
                    
                    // å®‰å…¨æ˜¾ç¤ºå›¾è¡¨åŒºåŸŸ
                    const chartsGrid = document.getElementById('chartsGrid');
                    const currentValues = document.getElementById('currentValues');
                    const timeControls = document.getElementById('timeControls');
                    const sceneControls = document.getElementById('sceneControls');
                    const tagControls = document.getElementById('tagControls');
                    const scenarioControls = document.getElementById('scenarioControls');
                    
                    if (chartsGrid) chartsGrid.style.display = 'grid';
                    if (currentValues) currentValues.style.display = 'grid';
                    if (timeControls) timeControls.style.display = 'block';
                    if (sceneControls) sceneControls.style.display = 'block';
                    if (tagControls) tagControls.style.display = 'block';
                    if (scenarioControls) scenarioControls.style.display = 'block';
                    
                    initCharts();
                    enableDoubleClickTags(); // å¯ç”¨åŒå‡»æ ‡ç­¾åŠŸèƒ½

                    // æ¢å¤è®¾ç½®
                    if (importedData.settings) {
                        if (importedData.settings.isUnlimited) {
                            setUnlimited();
                        } else if (importedData.settings.maxDataPoints) {
                            document.getElementById('timeRange').value = importedData.settings.maxDataPoints;
                            updateTimeRange(importedData.settings.maxDataPoints);
                        }
                    }

                    // æ‰¹é‡æ·»åŠ å¯¼å…¥çš„æ•°æ®
                    let dataCount = 0;
                    importedData.data.forEach(item => {
                        // å…¼å®¹ä¸åŒçš„æ•°æ®æ ¼å¼
                        const timeValue = item.time || item.timestamp;
                        const hasPerformanceData = item.cpu !== undefined || item.memory !== undefined;
                        
                        if (hasPerformanceData || item.type === 'performance') {
                            // ç¡®ä¿æ•°æ®å®Œæ•´æ€§
                            const cpu = item.cpu || 0;
                            const memory = item.memory || 0;
                            const threads = item.threads || 0;
                            const fps = item.fps || 0;
                            
                            addDataToChart(cpuChart, timeValue, cpu);
                            addDataToChart(memoryChart, timeValue, memory);
                            addDataToChart(threadsChart, timeValue, threads);
                            addDataToChart(fpsChart, timeValue, fps);
                            
                            // å®‰å…¨æ›´æ–°å½“å‰å€¼æ˜¾ç¤º
                            const currentCpu = document.getElementById('currentCpu');
                            const currentMemory = document.getElementById('currentMemory');
                            const currentThreads = document.getElementById('currentThreads');
                            const currentFps = document.getElementById('currentFps');
                            
                            if (currentCpu) currentCpu.textContent = `${cpu}%`;
                            if (currentMemory) currentMemory.textContent = `${memory.toFixed(1)}MB`;
                            if (currentThreads) currentThreads.textContent = threads;
                            if (currentFps) currentFps.textContent = `${fps}FPS`;
                            
                            // è·å–ç£ç›˜è¯»å†™æ•°æ®ï¼ˆå¦‚æœæœ‰ï¼‰
                            const diskReads = item.disk_reads || 0;
                            const diskWrites = item.disk_writes || 0;
                            
                            // æ›´æ–°æ€§èƒ½ç»Ÿè®¡åˆ†æ
                            updatePerformanceStats(cpu, memory, fps, threads, diskReads, diskWrites);
                            
                            dataCount++;
                        }
                    });

                    // å¯¼å…¥åœºæ™¯æ•°æ®
                    if (importedData.scenes && Array.isArray(importedData.scenes)) {
                        savedScenes = importedData.scenes;
                        updateSceneList();
                    }

                    // å¯¼å…¥æ ‡ç­¾æ•°æ®
                    if (importedData.tags && Array.isArray(importedData.tags)) {
                        savedTags = importedData.tags;
                        updateTagList();
                        // æ¢å¤æ ‡ç­¾æ ‡è®°
                        updateAllTagMarkers();
                    }

                    let statusMessage = `æˆåŠŸå¯¼å…¥ ${dataCount} æ¡æ€§èƒ½è®°å½•`;
                    if (importedData.scenes && importedData.scenes.length > 0) {
                        statusMessage += `ï¼Œ${importedData.scenes.length} ä¸ªåœºæ™¯`;
                    }
                    if (importedData.tags && importedData.tags.length > 0) {
                        statusMessage += `ï¼Œ${importedData.tags.length} ä¸ªæ ‡ç­¾`;
                    }
                    statusMessage += `ï¼Œæ¥è‡ª ${importedData.timestamp}`;
                    showStatus(statusMessage, 'success');
                    
                    // æ›´æ–°æœ€ç»ˆçš„æ€§èƒ½è¯„åˆ†
                    updatePerformanceScores();
                    
                } catch (error) {
                    showStatus('æ–‡ä»¶è§£æå¤±è´¥: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
            
            // æ¸…ç©ºfile input
            event.target.value = '';
        }

        function clearAllCharts() {
            // å®‰å…¨æ¸…ç©ºæ‰€æœ‰å›¾è¡¨
            if (cpuChart && cpuChart.data) {
                cpuChart.data.labels = [];
                if (cpuChart.data.datasets && cpuChart.data.datasets[0]) {
                    cpuChart.data.datasets[0].data = [];
                }
                cpuChart.update();
            }
            
            if (memoryChart && memoryChart.data) {
                memoryChart.data.labels = [];
                if (memoryChart.data.datasets && memoryChart.data.datasets[0]) {
                    memoryChart.data.datasets[0].data = [];
                }
                memoryChart.update();
            }
            
            if (fpsChart && fpsChart.data) {
                fpsChart.data.labels = [];
                if (fpsChart.data.datasets && fpsChart.data.datasets[0]) {
                    fpsChart.data.datasets[0].data = [];
                }
                fpsChart.update();
            }
            
            if (threadsChart && threadsChart.data) {
                threadsChart.data.labels = [];
                if (threadsChart.data.datasets && threadsChart.data.datasets[0]) {
                    threadsChart.data.datasets[0].data = [];
                }
                threadsChart.update();
            }
            
            if (diskReadsChart && diskReadsChart.data) {
                diskReadsChart.data.labels = [];
                if (diskReadsChart.data.datasets && diskReadsChart.data.datasets[0]) {
                    diskReadsChart.data.datasets[0].data = [];
                }
                diskReadsChart.update();
            }
            
            if (diskWritesChart && diskWritesChart.data) {
                diskWritesChart.data.labels = [];
                if (diskWritesChart.data.datasets && diskWritesChart.data.datasets[0]) {
                    diskWritesChart.data.datasets[0].data = [];
                }
                diskWritesChart.update();
            }
            
            // æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾æ ‡è®°
            const existingMarkers = document.querySelectorAll('.chart-tag-marker');
            existingMarkers.forEach(marker => {
                if (marker && marker.parentNode) {
                    marker.remove();
                }
            });
            
            // æ¸…ç©ºæ•°æ®æ•°ç»„
            allTimeLabels = [];
            allCpuData = [];
            allMemoryData = [];
            allFpsData = [];
            allThreadsData = [];
            allDiskReadsData = [];
            allDiskWritesData = [];
            allPerformanceData = [];
        }

        // è®¾å¤‡å’Œåº”ç”¨ç®¡ç†å‡½æ•°
        async function refreshDevices() {
            try {
                console.log('å¼€å§‹è·å–è®¾å¤‡åˆ—è¡¨...');
                showStatus('æ­£åœ¨æ£€æµ‹è®¾å¤‡...', 'info');
                
                const response = await fetch('/api/devices');
                console.log('APIå“åº”çŠ¶æ€:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('APIè¿”å›æ•°æ®:', data);
                
                if (!data.success) {
                    throw new Error(data.error || 'è·å–è®¾å¤‡å¤±è´¥');
                }
                
                connectedDevices = data.devices;
                
                const deviceSelect = document.getElementById('deviceSelect');
                deviceSelect.innerHTML = '';
                
                if (connectedDevices.length === 0) {
                    deviceSelect.innerHTML = '<option value="">æœªæ£€æµ‹åˆ°è®¾å¤‡</option>';
                    showStatus('æœªæ£€æµ‹åˆ°iOSè®¾å¤‡ï¼Œè¯·ç¡®ä¿è®¾å¤‡å·²è¿æ¥å¹¶ä¿¡ä»»æ­¤ç”µè„‘', 'warning');
                } else {
                    connectedDevices.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.UniqueDeviceID;
                        // å°è¯•ä»ä¸åŒä½ç½®è·å–è®¾å¤‡åç§°
                        const deviceName = device.Properties?.DeviceName || device.DeviceName || 'æœªçŸ¥è®¾å¤‡';
                        option.textContent = `${deviceName} (${device.UniqueDeviceID.substring(0, 8)}...)`;
                        deviceSelect.appendChild(option);
                    });
                    
                    // è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªè®¾å¤‡
                    if (connectedDevices.length > 0) {
                        deviceSelect.value = connectedDevices[0].UniqueDeviceID;
                        showStatus(`æ£€æµ‹åˆ° ${connectedDevices.length} ä¸ªè®¾å¤‡`, 'success');
                        onDeviceChanged();
                    }
                }
            } catch (error) {
                console.error('è·å–è®¾å¤‡å¤±è´¥:', error);
                showStatus('è·å–è®¾å¤‡å¤±è´¥: ' + error.message, 'error');
                
                const deviceSelect = document.getElementById('deviceSelect');
                deviceSelect.innerHTML = '<option value="">è·å–è®¾å¤‡å¤±è´¥</option>';
            }
        }
        
        async function onDeviceChanged() {
            const deviceSelect = document.getElementById('deviceSelect');
            const selectedUdid = deviceSelect.value;
            
            document.getElementById('udid').value = selectedUdid;
            
            if (selectedUdid) {
                await refreshApps();
            } else {
                const appSelect = document.getElementById('appSelect');
                appSelect.innerHTML = '<option value="">è¯·å…ˆé€‰æ‹©è®¾å¤‡</option>';
            }
        }
        
        async function refreshApps() {
            const selectedUdid = document.getElementById('deviceSelect').value;
            if (!selectedUdid) {
                showStatus('è¯·å…ˆé€‰æ‹©è®¾å¤‡', 'error');
                return;
            }
            
            try {
                showStatus('æ­£åœ¨è·å–åº”ç”¨åˆ—è¡¨...', 'info');
                console.log('å¼€å§‹è·å–åº”ç”¨åˆ—è¡¨ï¼ŒUDID:', selectedUdid);
                
                const response = await fetch(`/api/apps?udid=${selectedUdid}`);
                console.log('åº”ç”¨APIå“åº”çŠ¶æ€:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('åº”ç”¨APIè¿”å›æ•°æ®:', data);
                
                if (!data.success) {
                    throw new Error(data.error || 'è·å–åº”ç”¨åˆ—è¡¨å¤±è´¥');
                }
                
                allApps = data.apps;
                installedApps = allApps; // åˆå§‹æ˜¾ç¤ºæ‰€æœ‰åº”ç”¨
                
                updateAppList();
                
                if (allApps.length === 0) {
                    showStatus('è¯¥è®¾å¤‡ä¸Šæœªæ‰¾åˆ°åº”ç”¨ï¼Œå¯èƒ½éœ€è¦ä¿¡ä»»æ­¤ç”µè„‘æˆ–åº”ç”¨è·å–æƒé™', 'warning');
                } else {
                    showStatus(`è·å–åˆ° ${allApps.length} ä¸ªåº”ç”¨`, 'success');
                }
            } catch (error) {
                console.error('è·å–åº”ç”¨å¤±è´¥:', error);
                showStatus('è·å–åº”ç”¨å¤±è´¥: ' + error.message, 'error');
                
                const appSelect = document.getElementById('appSelect');
                appSelect.innerHTML = '<option value="">è·å–åº”ç”¨å¤±è´¥</option>';
            }
        }
        
        function updateAppList() {
            const appSelect = document.getElementById('appSelect');
            appSelect.innerHTML = '';
            
            if (installedApps.length === 0) {
                appSelect.innerHTML = '<option value="">æœªæ‰¾åˆ°åº”ç”¨</option>';
                return;
            }
            
            installedApps.forEach(app => {
                const option = document.createElement('option');
                option.value = app.bundle_id;
                option.textContent = `${app.name} (${app.bundle_id})`;
                option.title = `ç‰ˆæœ¬: ${app.version}`;
                appSelect.appendChild(option);
            });
        }
        
        function filterApps() {
            const searchText = document.getElementById('appSearch').value.toLowerCase();
            
            if (searchText === '') {
                installedApps = allApps;
            } else {
                installedApps = allApps.filter(app => 
                    app.name.toLowerCase().includes(searchText) || 
                    app.bundle_id.toLowerCase().includes(searchText)
                );
            }
            
            updateAppList();
        }
        
        function onAppSelected() {
            const appSelect = document.getElementById('appSelect');
            const selectedBundleId = appSelect.value;
            document.getElementById('bundleId').value = selectedBundleId;
        }

        // å¼€å§‹ç›‘æ§
        function startMonitoring() {
            const udid = document.getElementById('udid').value.trim();
            const bundleId = document.getElementById('bundleId').value.trim();
            
            if (!udid) {
                showStatus('è¯·å…ˆé€‰æ‹©è®¾å¤‡', 'error');
                return;
            }
            
            if (!bundleId) {
                showStatus('è¯·å…ˆé€‰æ‹©åº”ç”¨', 'error');
                return;
            }
            
            showStatus('æ­£åœ¨å¯åŠ¨ç›‘æ§...', 'info');
            
            // æ¸…ç©ºä¹‹å‰çš„æ•°æ®
            allPerformanceData = [];
            
            socket.emit('start_monitoring', {
                udid: udid,
                bundle_id: bundleId
            });
            
            isMonitoring = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('saveBtn').disabled = false;
        }

        // åœæ­¢ç›‘æ§
        function stopMonitoring() {
            isMonitoring = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            showStatus('ç›‘æ§å·²åœæ­¢', 'info');
            // ä¿æŒå›¾è¡¨æ˜¾ç¤ºï¼Œä¸éšè—
        }

        // Socket.IOäº‹ä»¶å¤„ç†
        // åœºæ™¯ç®¡ç†åŠŸèƒ½
        function toggleSelection() {
            isSelecting = !isSelecting;
            const btn = document.getElementById('startSelectionBtn');
            const statusEl = document.getElementById('selectionStatus');
            
            if (isSelecting) {
                btn.textContent = 'å–æ¶ˆé€‰æ‹©';
                btn.style.background = '#ff3b30';
                statusEl.textContent = 'è¯·åœ¨ä»»æ„å›¾è¡¨ä¸Šæ‹–æ‹½é€‰æ‹©æ—¶é—´åŒºåŸŸ';
                document.body.classList.add('selecting');
                enableChartSelection();
            } else {
                btn.textContent = 'å¼€å§‹é€‰æ‹©æ—¶é—´åŒºåŸŸ';
                btn.style.background = '#007aff';
                statusEl.textContent = '';
                document.body.classList.remove('selecting');
                disableChartSelection();
                clearCurrentSelection();
            }
        }

        function enableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('mousedown', onSelectionStart);
                wrapper.addEventListener('mousemove', onSelectionMove);
                wrapper.addEventListener('mouseup', onSelectionEnd);
                wrapper.addEventListener('mouseleave', onSelectionEnd);
            });
        }

        function disableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.removeEventListener('mousedown', onSelectionStart);
                wrapper.removeEventListener('mousemove', onSelectionMove);
                wrapper.removeEventListener('mouseup', onSelectionEnd);
                wrapper.removeEventListener('mouseleave', onSelectionEnd);
            });
        }

        function onSelectionStart(e) {
            if (!isSelecting) return;
            isMouseDown = true;
            const rect = e.currentTarget.getBoundingClientRect();
            selectionStartX = e.clientX - rect.left;
            clearCurrentSelection();
        }

        function onSelectionMove(e) {
            if (!isSelecting || !isMouseDown) return;
            const rect = e.currentTarget.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const width = Math.abs(currentX - selectionStartX);
            const left = Math.min(selectionStartX, currentX);
            
            // åŒæ­¥æ˜¾ç¤ºé€‰æ‹©åŒºåŸŸåˆ°æ‰€æœ‰å›¾è¡¨
            updateAllSelectionOverlays(left, width);
        }

        function onSelectionEnd(e) {
            if (!isSelecting || !isMouseDown) return;
            isMouseDown = false;
            
            const rect = e.currentTarget.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // è®¡ç®—æ—¶é—´ç´¢å¼•
            const startIndex = Math.floor((Math.min(selectionStartX, endX) / chartWidth) * maxDataPoints);
            const endIndex = Math.floor((Math.max(selectionStartX, endX) / chartWidth) * maxDataPoints);
            
            if (Math.abs(endX - selectionStartX) > 10) { // æœ€å°é€‰æ‹©å®½åº¦
                // è·å–æ—¶é—´æ ‡ç­¾
                const timeLabels = cpuChart.data.labels;
                selectionStart = timeLabels[Math.max(0, startIndex)] || '';
                selectionEnd = timeLabels[Math.min(timeLabels.length - 1, endIndex)] || '';
                
                if (selectionStart && selectionEnd) {
                    document.getElementById('saveSceneBtn').disabled = false;
                    document.getElementById('selectionStatus').textContent = 
                        `å·²é€‰æ‹©æ—¶é—´æ®µ: ${selectionStart} - ${selectionEnd}`;
                }
            }
        }

        function updateAllSelectionOverlays(left, width) {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                const overlay = document.getElementById(overlayId);
                if (overlay) {
                    overlay.style.display = 'block';
                    overlay.style.left = left + 'px';
                    overlay.style.width = width + 'px';
                    overlay.style.top = '0px';
                    overlay.style.height = '100%';
                }
            });
        }

        function clearCurrentSelection() {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                const overlay = document.getElementById(overlayId);
                if (overlay) {
                    overlay.style.display = 'none';
                }
            });
            selectionStart = null;
            selectionEnd = null;
            const saveSceneBtn = document.getElementById('saveSceneBtn');
            if (saveSceneBtn) {
                saveSceneBtn.disabled = true;
            }
        }

        function saveScene() {
            const sceneName = document.getElementById('sceneNameInput').value.trim();
            if (!sceneName) {
                showStatus('è¯·è¾“å…¥åœºæ™¯åç§°', 'error');
                return;
            }
            
            if (!selectionStart || !selectionEnd) {
                showStatus('è¯·å…ˆé€‰æ‹©æ—¶é—´åŒºåŸŸ', 'error');
                return;
            }

            // è·å–é€‰æ‹©æ—¶é—´æ®µå†…çš„æ€§èƒ½æ•°æ®
            const sceneData = allPerformanceData.filter(item => {
                return item.time >= selectionStart && item.time <= selectionEnd;
            });

            const scene = {
                id: Date.now(),
                name: sceneName,
                startTime: selectionStart,
                endTime: selectionEnd,
                data: sceneData,
                createdAt: new Date().toISOString(),
                summary: generateSceneSummary(sceneData)
            };

            savedScenes.push(scene);
            updateSceneList();
            
            // åœ¨æ‰€æœ‰å›¾è¡¨ä¸Šæ·»åŠ æ°¸ä¹…æ ‡è®°
            addSceneMarkersToAllCharts(scene);
            
            // æ¸…ç©ºè¾“å…¥å’Œé€‰æ‹©
            document.getElementById('sceneNameInput').value = '';
            clearCurrentSelection();
            toggleSelection(); // é€€å‡ºé€‰æ‹©æ¨¡å¼
            
            showStatus(`åœºæ™¯ "${sceneName}" å·²ä¿å­˜`, 'success');
        }

        function generateSceneSummary(sceneData) {
            const perfData = sceneData.filter(item => item.type === 'performance');
            //const fpsData = sceneData.filter(item => item.type === 'fps');
            
            if (perfData.length === 0) return {};
            
            const cpuValues = perfData.map(item => item.cpu);
            const memoryValues = perfData.map(item => item.memory);
            const fpsValues = perfData.map(item => item.fps);
            
            return {
                duration: perfData.length,
                avgCpu: (cpuValues.reduce((a, b) => a + b, 0) / cpuValues.length).toFixed(2),
                maxCpu: Math.max(...cpuValues).toFixed(2),
                avgMemory: (memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length).toFixed(1),
                maxMemory: Math.max(...memoryValues).toFixed(1),
                avgFps: fpsValues.length > 0 ? (fpsValues.reduce((a, b) => a + b, 0) / fpsValues.length).toFixed(1) : 0,
                minFps: fpsValues.length > 0 ? Math.min(...fpsValues) : 0
            };
        }

        function addSceneMarkersToAllCharts(scene) {
            // è¿™é‡Œæ·»åŠ æ°¸ä¹…çš„åœºæ™¯æ ‡è®°åˆ°æ‰€æœ‰å›¾è¡¨
            // Chart.jsæ’ä»¶å¯ä»¥å®ç°ï¼Œä½†ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å…ˆåœ¨åœºæ™¯åˆ—è¡¨ä¸­æ˜¾ç¤º
        }

        function updateSceneList() {
            const sceneList = document.getElementById('sceneList');
            sceneList.innerHTML = '';
            
            savedScenes.forEach(scene => {
                const sceneItem = document.createElement('div');
                sceneItem.className = 'scene-item';
                sceneItem.innerHTML = `
                    <div class="scene-info">
                        <div><strong>${scene.name}</strong></div>
                        <div class="scene-time">${scene.startTime} - ${scene.endTime}</div>
                        <div style="font-size: 11px; color: #86868b;">
                            å¹³å‡CPU: ${scene.summary.avgCpu}% | å¹³å‡å†…å­˜: ${scene.summary.avgMemory}MB | å¹³å‡FPS: ${scene.summary.avgFps}
                        </div>
                    </div>
                    <div class="scene-actions">
                        <button onclick="deleteScene(${scene.id})">åˆ é™¤</button>
                    </div>
                `;
                sceneList.appendChild(sceneItem);
            });
        }

        function deleteScene(sceneId) {
            savedScenes = savedScenes.filter(scene => scene.id !== sceneId);
            updateSceneList();
            showStatus('åœºæ™¯å·²åˆ é™¤', 'info');
        }

        function clearAllScenes() {
            if (savedScenes.length === 0) return;
            if (confirm('ç¡®è®¤æ¸…ç©ºæ‰€æœ‰åœºæ™¯æ ‡è®°ï¼Ÿ')) {
                savedScenes = [];
                updateSceneList();
                showStatus('æ‰€æœ‰åœºæ™¯å·²æ¸…ç©º', 'info');
            }
        }

        // ä¿®æ”¹ä¿å­˜æ•°æ®å‡½æ•°ï¼ŒåŒ…å«åœºæ™¯å’Œæ ‡ç­¾ä¿¡æ¯
        function saveDataWithScenes() {
            if (allTimeLabels.length === 0 && savedScenes.length === 0 && savedTags.length === 0) {
                showStatus('æ²¡æœ‰æ•°æ®ã€åœºæ™¯æˆ–æ ‡ç­¾å¯ä¿å­˜', 'error');
                return;
            }

            // é‡æ–°æ„å»ºæ€§èƒ½æ•°æ®æ•°ç»„
            const performanceData = [];
            for (let i = 0; i < allTimeLabels.length; i++) {
                performanceData.push({
                    timestamp: allTimeLabels[i],
                    cpu: allCpuData[i] || 0,
                    memory: allMemoryData[i] || 0,
                    fps: allFpsData[i] || 0,
                    threads: allThreadsData[i] || 0
                });
            }

            const now = new Date();
            const filename = `ios_performance_complete_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}.json`;
            
            const dataToSave = {
                timestamp: now.toISOString(),
                device_udid: document.getElementById('udid').value.trim(),
                bundle_id: document.getElementById('bundleId').value.trim(),
                data: performanceData,
                scenes: savedScenes, // åŒ…å«åœºæ™¯ä¿¡æ¯
                tags: savedTags, // åŒ…å«æ ‡ç­¾ä¿¡æ¯
                settings: {
                    windowSize: windowSize,
                    timePosition: timePosition
                },
                summary: {
                    total_records: performanceData.length,
                    total_scenes: savedScenes.length,
                    total_tags: savedTags.length,
                    duration_seconds: performanceData.length > 0 ? 
                        Math.round((new Date(performanceData[performanceData.length-1].timestamp) - new Date(performanceData[0].timestamp)) / 1000) : 0
                }
            };

            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`æ•°æ®å’Œåœºæ™¯å·²ä¿å­˜åˆ° ${filename}`, 'success');
        }

        // CSVæ ¼å¼å¯¼å‡ºå‡½æ•°
        function saveDataAsCSV() {
            if (allTimeLabels.length === 0) {
                showStatus('æ²¡æœ‰æ€§èƒ½æ•°æ®å¯å¯¼å‡º', 'error');
                return;
            }

            // å‡†å¤‡CSVæ•°æ®
            const csvData = [];
            
            // CSVæ ‡é¢˜è¡Œ
            const headers = [
                'Timestamp',
                'Time',
                'CPU Usage (%)',
                'Memory Usage (MB)',
                'FPS',
                'Thread Count',
                'Scene',
                'Tags'
            ];
            csvData.push(headers);

            // æ•°æ®è¡Œ
            for (let i = 0; i < allTimeLabels.length; i++) {
                const timestamp = allTimeLabels[i];
                const timeStr = new Date(timestamp).toLocaleString('zh-CN');
                const cpu = allCpuData[i] || 0;
                const memory = allMemoryData[i] || 0;
                const fps = allFpsData[i] || 0;
                const threads = allThreadsData[i] || 0;
                
                // æŸ¥æ‰¾å½“å‰æ—¶é—´ç‚¹çš„åœºæ™¯å’Œæ ‡ç­¾
                const currentTime = new Date(timestamp).getTime();
                let sceneInfo = '';
                let tagInfo = '';
                
                // æ£€æŸ¥æ˜¯å¦åœ¨æŸä¸ªåœºæ™¯åŒºé—´å†…
                for (const scene of savedScenes) {
                    const sceneStart = new Date(scene.startTime).getTime();
                    const sceneEnd = new Date(scene.endTime).getTime();
                    if (currentTime >= sceneStart && currentTime <= sceneEnd) {
                        sceneInfo = scene.name;
                        break;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰æ ‡ç­¾
                for (const tag of savedTags) {
                    const tagTime = new Date(tag.time).getTime();
                    if (Math.abs(currentTime - tagTime) < 5000) { // 5ç§’è¯¯å·®èŒƒå›´
                        tagInfo = tag.note || 'Tag';
                        break;
                    }
                }
                
                const row = [
                    timestamp,
                    timeStr,
                    cpu.toFixed(2),
                    memory.toFixed(2),
                    fps.toFixed(1),
                    threads,
                    sceneInfo,
                    tagInfo
                ];
                csvData.push(row);
            }

            // è½¬æ¢ä¸ºCSVå­—ç¬¦ä¸²
            const csvContent = csvData.map(row => 
                row.map(field => {
                    // å¤„ç†åŒ…å«é€—å·ã€å¼•å·æˆ–æ¢è¡Œçš„å­—æ®µ
                    const fieldStr = String(field);
                    if (fieldStr.includes(',') || fieldStr.includes('"') || fieldStr.includes('\n')) {
                        return '"' + fieldStr.replace(/"/g, '""') + '"';
                    }
                    return fieldStr;
                }).join(',')
            ).join('\n');

            // æ·»åŠ BOMä»¥æ”¯æŒä¸­æ–‡å­—ç¬¦
            const BOM = '\uFEFF';
            const csvWithBOM = BOM + csvContent;

            // ç”Ÿæˆæ–‡ä»¶å
            const now = new Date();
            const filename = `ios_performance_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}.csv`;
            
            // ä¸‹è½½æ–‡ä»¶
            const blob = new Blob([csvWithBOM], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`CSVæ•°æ®å¯¼å‡ºæˆåŠŸï¼æ–‡ä»¶: ${filename}`, 'success');
        }

        socket.on('monitoring_started', function(data) {
            if (data.status === 'success') {
                isMonitoring = true;  // é‡è¦ï¼šè®¾ç½®ç›‘æ§çŠ¶æ€ä¸ºtrue
                showStatus('ç›‘æ§å·²å¯åŠ¨ï¼Œæ­£åœ¨æ”¶é›†æ•°æ®...', 'success');
                
                // âš ï¸ å…³é”®ä¿®å¤ï¼šåœ¨æ˜¾ç¤ºå›¾è¡¨ä¹‹å‰å…ˆå¼ºåˆ¶è°ƒæ•´ç»Ÿè®¡é¢æ¿ä½ç½®
                ensureStatisticsPanelPosition();
                
                // å®‰å…¨æ˜¾ç¤ºå›¾è¡¨åŒºåŸŸï¼ˆæ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼‰
                const chartsGrid = document.getElementById('chartsGrid');
                const currentValues = document.getElementById('currentValues');
                const timeControls = document.getElementById('timeControls');
                const sceneControls = document.getElementById('sceneControls');
                const tagControls = document.getElementById('tagControls');
                const scenarioControls = document.getElementById('scenarioControls');
                
                if (chartsGrid) chartsGrid.style.display = 'grid';
                if (currentValues) currentValues.style.display = 'grid';
                if (timeControls) timeControls.style.display = 'block';
                if (sceneControls) sceneControls.style.display = 'block';
                if (tagControls) tagControls.style.display = 'block';
                if (scenarioControls) scenarioControls.style.display = 'block';
                
                // ç­‰å¾…DOMå…ƒç´ æ¸²æŸ“å®Œæˆåå†åˆå§‹åŒ–å›¾è¡¨
                setTimeout(() => {
                    initCharts();
                    enableDoubleClickTags(); // å¯ç”¨åŒå‡»æ ‡ç­¾åŠŸèƒ½
                    // å†æ¬¡ç¡®ä¿ä½ç½®æ­£ç¡®ï¼ˆåŒé‡ä¿é™©ï¼‰
                    ensureStatisticsPanelPosition();
                }, 100);
            }
        });

        socket.on('performance_data', function(data) {
            if (!isMonitoring) return;
            
            // å®‰å…¨æ›´æ–°å½“å‰å€¼æ˜¾ç¤ºï¼ˆæ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼‰
            const currentCpu = document.getElementById('currentCpu');
            const currentMemory = document.getElementById('currentMemory');
            const currentThreads = document.getElementById('currentThreads');
            const currentFps = document.getElementById('currentFps');
            const currentDiskReads = document.getElementById('currentDiskReads');
            const currentDiskWrites = document.getElementById('currentDiskWrites');
            
            if (currentCpu) currentCpu.textContent = `${data.cpu}%`;
            if (currentMemory) currentMemory.textContent = `${data.memory.toFixed(1)}MB`;
            if (currentThreads) currentThreads.textContent = data.threads;
            if (currentFps) currentFps.textContent = `${data.fps}FPS`;
            
            // æ›´æ–°ç£ç›˜è¯»å†™æ˜¾ç¤º
            if (data.disk_reads !== undefined && currentDiskReads) {
                currentDiskReads.textContent = `${data.disk_reads.toFixed(1)}MB`;
            }
            if (data.disk_writes !== undefined && currentDiskWrites) {
                currentDiskWrites.textContent = `${data.disk_writes.toFixed(1)}MB`;
            }
            
            // ç«‹å³æ·»åŠ æ•°æ®åˆ°å›¾è¡¨ï¼ˆåŒæ­¥ï¼Œæ— å»¶è¿Ÿï¼‰
            addDataToChart(cpuChart, data.time, data.cpu);
            addDataToChart(memoryChart, data.time, data.memory);
            addDataToChart(threadsChart, data.time, data.threads);
            addDataToChart(fpsChart, data.time, data.fps);
            
            // æ·»åŠ ç£ç›˜è¯»å†™æ•°æ®åˆ°å›¾è¡¨
            if (data.disk_reads !== undefined) {
                addDataToChart(diskReadsChart, data.time, data.disk_reads);
            }
            if (data.disk_writes !== undefined) {
                addDataToChart(diskWritesChart, data.time, data.disk_writes);
            }
            
            // ä¿å­˜åˆ°allPerformanceDataç”¨äºå¯¼å‡º
            const performanceRecord = {
                type: 'performance',
                timestamp: new Date().toISOString(),
                time: data.time,
                cpu: data.cpu,
                memory: data.memory,
                fps: data.fps,
                threads: data.threads,
                pid: data.pid,
                name: data.name
            };
            
            // æ·»åŠ ç£ç›˜æ•°æ®åˆ°è®°å½•ä¸­
            if (data.disk_reads !== undefined) {
                performanceRecord.disk_reads = data.disk_reads;
            }
            if (data.disk_writes !== undefined) {
                performanceRecord.disk_writes = data.disk_writes;
            }
            
            allPerformanceData.push(performanceRecord);
            
            // é™ä½ç»Ÿè®¡æ›´æ–°é¢‘ç‡ï¼Œä½†ä¸å½±å“ä¸»è¦æ•°æ®æ˜¾ç¤º
            if (!window.statsUpdatePending) {
                window.statsUpdatePending = true;
                setTimeout(() => {
                    updatePerformanceStats(
                        data.cpu, 
                        data.memory, 
                        data.fps || 0, 
                        data.threads,
                        data.disk_reads || 0,
                        data.disk_writes || 0
                    );
                    checkPerformanceThresholds(data.cpu, data.memory, data.fps || 0, data.threads);
                    detectMemoryLeak(data.memory, data.cpu, data.fps || 0, data.threads);
                    updatePerformanceScores();
                    window.statsUpdatePending = false;
                }, 500); // 500msæ‰¹é‡æ›´æ–°ä¸€æ¬¡ç»Ÿè®¡æ•°æ®ï¼ˆä¸å½±å“ä¸»è¦æ˜¾ç¤ºï¼‰
            }
        });

        /*socket.on('fps_data', function(data) {
            if (!isMonitoring) return;

            // ä¿å­˜åˆ°allPerformanceDataç”¨äºå¯¼å‡º
            allPerformanceData.push({
                type: 'fps',
                timestamp: new Date().toISOString(),
                time: data.time,
                fps: data.fps
            });

            // æ›´æ–°å½“å‰FPSæ˜¾ç¤º
            document.getElementById('currentFps').textContent = `${data.fps}FPS`;

            // æ·»åŠ FPSæ•°æ®åˆ°å›¾è¡¨
            addDataToChart(fpsChart, data.time, data.fps);
        });*/

        socket.on('connect', function() {
            console.log('å·²è¿æ¥åˆ°æœåŠ¡å™¨');
        });

        socket.on('disconnect', function() {
            console.log('ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥');
            if (isMonitoring) {
                showStatus('ä¸æœåŠ¡å™¨è¿æ¥æ–­å¼€', 'error');
            }
        });

        // æ€§èƒ½ç»Ÿè®¡æ›´æ–°å‡½æ•°
        function updatePerformanceStats(cpu, memory, fps, threads, diskReads = 0, diskWrites = 0) {
            // æ›´æ–°CPUç»Ÿè®¡
            performanceStats.cpu.current = cpu;
            performanceStats.cpu.sum += cpu;
            performanceStats.cpu.count++;
            performanceStats.cpu.avg = performanceStats.cpu.sum / performanceStats.cpu.count;
            performanceStats.cpu.max = Math.max(performanceStats.cpu.max, cpu);
            
            // æ›´æ–°å†…å­˜ç»Ÿè®¡
            performanceStats.memory.current = memory;
            performanceStats.memory.sum += memory;
            performanceStats.memory.count++;
            performanceStats.memory.avg = performanceStats.memory.sum / performanceStats.memory.count;
            performanceStats.memory.max = Math.max(performanceStats.memory.max, memory);
            
            // æ›´æ–°FPSç»Ÿè®¡
            if (fps > 0) {
                performanceStats.fps.current = fps;
                performanceStats.fps.sum += fps;
                performanceStats.fps.count++;
                performanceStats.fps.avg = performanceStats.fps.sum / performanceStats.fps.count;
                performanceStats.fps.min = Math.min(performanceStats.fps.min, fps);
            }
            
            // æ›´æ–°çº¿ç¨‹ç»Ÿè®¡
            performanceStats.threads.current = threads;
            performanceStats.threads.sum += threads;
            performanceStats.threads.count++;
            performanceStats.threads.avg = performanceStats.threads.sum / performanceStats.threads.count;
            performanceStats.threads.max = Math.max(performanceStats.threads.max, threads);
            
            // æ›´æ–°ç£ç›˜è¯»å–ç»Ÿè®¡
            if (diskReads > 0) {
                performanceStats.diskReads.current = diskReads;
                performanceStats.diskReads.sum += diskReads;
                performanceStats.diskReads.count++;
                performanceStats.diskReads.avg = performanceStats.diskReads.sum / performanceStats.diskReads.count;
                performanceStats.diskReads.max = Math.max(performanceStats.diskReads.max, diskReads);
            }
            
            // æ›´æ–°ç£ç›˜å†™å…¥ç»Ÿè®¡
            if (diskWrites > 0) {
                performanceStats.diskWrites.current = diskWrites;
                performanceStats.diskWrites.sum += diskWrites;
                performanceStats.diskWrites.count++;
                performanceStats.diskWrites.avg = performanceStats.diskWrites.sum / performanceStats.diskWrites.count;
                performanceStats.diskWrites.max = Math.max(performanceStats.diskWrites.max, diskWrites);
            }
            
            // æ›´æ–°ç»Ÿè®¡é¢æ¿æ˜¾ç¤º
            updateStatisticsDisplay();
        }
        
        function updateStatisticsDisplay() {
            // å®‰å…¨æ›´æ–°ç»Ÿè®¡æ˜¾ç¤ºï¼ˆæ£€æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼‰
            const statCpuCurrent = document.getElementById('statCpuCurrent');
            const statCpuAvg = document.getElementById('statCpuAvg');
            const statCpuMax = document.getElementById('statCpuMax');
            const statMemoryCurrent = document.getElementById('statMemoryCurrent');
            const statMemoryAvg = document.getElementById('statMemoryAvg');
            const statMemoryMax = document.getElementById('statMemoryMax');
            const statFpsCurrent = document.getElementById('statFpsCurrent');
            const statFpsAvg = document.getElementById('statFpsAvg');
            const statFpsMin = document.getElementById('statFpsMin');
            const statThreadsCurrent = document.getElementById('statThreadsCurrent');
            const statThreadsAvg = document.getElementById('statThreadsAvg');
            const statThreadsMax = document.getElementById('statThreadsMax');
            const statDiskReadsCurrent = document.getElementById('statDiskReadsCurrent');
            const statDiskReadsAvg = document.getElementById('statDiskReadsAvg');
            const statDiskReadsMax = document.getElementById('statDiskReadsMax');
            const statDiskWritesCurrent = document.getElementById('statDiskWritesCurrent');
            const statDiskWritesAvg = document.getElementById('statDiskWritesAvg');
            const statDiskWritesMax = document.getElementById('statDiskWritesMax');
            
            if (statCpuCurrent) statCpuCurrent.textContent = `${performanceStats.cpu.current.toFixed(1)}%`;
            if (statCpuAvg) statCpuAvg.textContent = `${performanceStats.cpu.avg.toFixed(1)}%`;
            if (statCpuMax) statCpuMax.textContent = `${performanceStats.cpu.max.toFixed(1)}%`;
            
            if (statMemoryCurrent) statMemoryCurrent.textContent = `${performanceStats.memory.current.toFixed(1)}MB`;
            if (statMemoryAvg) statMemoryAvg.textContent = `${performanceStats.memory.avg.toFixed(1)}MB`;
            if (statMemoryMax) statMemoryMax.textContent = `${performanceStats.memory.max.toFixed(1)}MB`;
            
            if (performanceStats.fps.count > 0) {
                if (statFpsCurrent) statFpsCurrent.textContent = `${performanceStats.fps.current}FPS`;
                if (statFpsAvg) statFpsAvg.textContent = `${performanceStats.fps.avg.toFixed(1)}FPS`;
                if (statFpsMin) statFpsMin.textContent = `${performanceStats.fps.min === Infinity ? 0 : performanceStats.fps.min}FPS`;
            }
            
            if (statThreadsCurrent) statThreadsCurrent.textContent = performanceStats.threads.current;
            if (statThreadsAvg) statThreadsAvg.textContent = performanceStats.threads.avg.toFixed(1);
            if (statThreadsMax) statThreadsMax.textContent = performanceStats.threads.max;
            
            // æ›´æ–°ç£ç›˜è¯»å†™ç»Ÿè®¡æ˜¾ç¤º
            if (performanceStats.diskReads.count > 0) {
                if (statDiskReadsCurrent) statDiskReadsCurrent.textContent = `${performanceStats.diskReads.current.toFixed(1)}MB`;
                if (statDiskReadsAvg) statDiskReadsAvg.textContent = `${performanceStats.diskReads.avg.toFixed(1)}MB`;
                if (statDiskReadsMax) statDiskReadsMax.textContent = `${performanceStats.diskReads.max.toFixed(1)}MB`;
            }
            
            if (performanceStats.diskWrites.count > 0) {
                if (statDiskWritesCurrent) statDiskWritesCurrent.textContent = `${performanceStats.diskWrites.current.toFixed(1)}MB`;
                if (statDiskWritesAvg) statDiskWritesAvg.textContent = `${performanceStats.diskWrites.avg.toFixed(1)}MB`;
                if (statDiskWritesMax) statDiskWritesMax.textContent = `${performanceStats.diskWrites.max.toFixed(1)}MB`;
            }
        }
        
        // æ€§èƒ½é˜ˆå€¼æ£€æŸ¥å‡½æ•°
        function checkPerformanceThresholds(cpu, memory, fps, threads) {
            // æ›´æ–°é˜ˆå€¼é…ç½®
            thresholds.cpu = parseInt(document.getElementById('cpuThreshold').value) || 80;
            thresholds.memory = parseInt(document.getElementById('memoryThreshold').value) || 200;
            thresholds.fps = parseInt(document.getElementById('fpsThreshold').value) || 30;
            thresholds.threads = parseInt(document.getElementById('threadsThreshold').value) || 50;
            
            activeAlerts = []; // æ¸…ç©ºå‘Šè­¦åˆ—è¡¨
            
            // æ£€æŸ¥CPUé˜ˆå€¼
            if (cpu > thresholds.cpu) {
                activeAlerts.push({
                    type: 'cpu',
                    level: cpu > thresholds.cpu * 1.2 ? 'critical' : 'warning',
                    message: `CPUä½¿ç”¨ç‡è¿‡é«˜: ${cpu.toFixed(1)}% (é˜ˆå€¼: ${thresholds.cpu}%)`
                });
            }
            
            // æ£€æŸ¥å†…å­˜é˜ˆå€¼
            if (memory > thresholds.memory) {
                activeAlerts.push({
                    type: 'memory',
                    level: memory > thresholds.memory * 1.2 ? 'critical' : 'warning',
                    message: `å†…å­˜ä½¿ç”¨é‡è¿‡é«˜: ${memory.toFixed(1)}MB (é˜ˆå€¼: ${thresholds.memory}MB)`
                });
            }
            
            // æ£€æŸ¥FPSé˜ˆå€¼
            if (fps > 0 && fps < thresholds.fps) {
                activeAlerts.push({
                    type: 'fps',
                    level: fps < thresholds.fps * 0.7 ? 'critical' : 'warning',
                    message: `å¸§ç‡è¿‡ä½: ${fps}FPS (é˜ˆå€¼: ${thresholds.fps}FPS)`
                });
            }
            
            // æ£€æŸ¥çº¿ç¨‹æ•°é˜ˆå€¼
            if (threads > thresholds.threads) {
                activeAlerts.push({
                    type: 'threads',
                    level: threads > thresholds.threads * 1.2 ? 'critical' : 'warning',
                    message: `çº¿ç¨‹æ•°è¿‡å¤š: ${threads} (é˜ˆå€¼: ${thresholds.threads})`
                });
            }
            
            updateAlertsDisplay();
        }
        
        function updateAlertsDisplay() {
            const alertPanel = document.getElementById('alertPanel');
            const alertList = document.getElementById('alertList');
            
            if (activeAlerts.length === 0) {
                alertPanel.style.display = 'none';
                return;
            }
            
            alertPanel.style.display = 'block';
            alertList.innerHTML = '';
            
            activeAlerts.forEach(alert => {
                const alertItem = document.createElement('div');
                alertItem.className = `alert-item ${alert.level}`;
                alertItem.innerHTML = `
                    <span>${alert.message}</span>
                    <span>âš ï¸</span>
                `;
                alertList.appendChild(alertItem);
            });
        }
        
        // ä¸“ä¸šçº§å†…å­˜æ³„æ¼æ£€æµ‹ä¸»å‡½æ•°
        function detectMemoryLeak(currentMemory, cpuUsage = 0, fpsRate = 0, threads = 0) {
            // ä½¿ç”¨æ–°çš„ä¸“ä¸šæ£€æµ‹ç³»ç»Ÿ
            runProfessionalMemoryLeakDetection(currentMemory, cpuUsage, fpsRate, threads);
            
            // å…¼å®¹æ—§UIæ˜¾ç¤º
            updateLegacyMemoryLeakUI(currentMemory);
        }
        
        function showMemoryLeakWarning(growthRate) {
            const warningEl = document.getElementById('leakWarning');
            const detailsEl = document.getElementById('leakDetails');
            
            detailsEl.innerHTML = `
                æ£€æµ‹åˆ°å†…å­˜æŒç»­å¢é•¿ï¼Œå¢é•¿ç‡: ${growthRate.toFixed(2)} MB/min<br>
                å»ºè®®æ£€æŸ¥åº”ç”¨æ˜¯å¦å­˜åœ¨å†…å­˜æ³„æ¼é—®é¢˜ã€‚<br>
                <small>æ£€æµ‹æ—¶é—´çª—å£: 5åˆ†é’Ÿ</small>
            `;
            
            warningEl.style.display = 'block';
            warningEl.classList.add('active');
        }
        
        function hideMemoryLeakWarning() {
            const warningEl = document.getElementById('leakWarning');
            warningEl.style.display = 'none';
            warningEl.classList.remove('active');
        }
        
        // æ€§èƒ½è¯„åˆ†è®¡ç®—å‡½æ•°
        function updatePerformanceScores() {
            const scores = calculatePerformanceScores();
            
            // æ›´æ–°CPUè¯„åˆ†
            updateScoreDisplay('cpu', scores.cpu);
            
            // æ›´æ–°å†…å­˜è¯„åˆ†
            updateScoreDisplay('memory', scores.memory);
            
            // æ›´æ–°FPSè¯„åˆ†
            updateScoreDisplay('fps', scores.fps);
            
            // æ›´æ–°æ€»ä½“è¯„åˆ†
            const overallScore = Math.round((scores.cpu.score + scores.memory.score + scores.fps.score) / 3);
            const overallGrade = getGradeFromScore(overallScore);
            updateScoreDisplay('overall', { score: overallScore, grade: overallGrade });
        }
        
        function calculatePerformanceScores() {
            const cpu = performanceStats.cpu.current;
            const memory = performanceStats.memory.current;
            const fps = performanceStats.fps.current;
            
            // CPUè¯„åˆ† (0-100)
            let cpuScore = Math.max(0, 100 - cpu);
            if (cpu < 30) cpuScore = 100;
            else if (cpu < 50) cpuScore = 90;
            else if (cpu < 70) cpuScore = 75;
            else if (cpu < 85) cpuScore = 60;
            else cpuScore = Math.max(0, 100 - cpu);
            
            // å†…å­˜è¯„åˆ† (å‡è®¾200MBä¸ºåŸºå‡†)
            let memoryScore = Math.max(0, 100 - (memory / 200) * 100);
            if (memory < 100) memoryScore = 100;
            else if (memory < 150) memoryScore = 90;
            else if (memory < 200) memoryScore = 75;
            else if (memory < 300) memoryScore = 60;
            else memoryScore = Math.max(0, 100 - ((memory - 200) / 200) * 100);
            
            // FPSè¯„åˆ†
            let fpsScore = 100;
            if (fps > 0) {
                if (fps >= 55) fpsScore = 100;
                else if (fps >= 45) fpsScore = 90;
                else if (fps >= 30) fpsScore = 75;
                else if (fps >= 20) fpsScore = 60;
                else fpsScore = Math.max(0, (fps / 20) * 60);
            }
            
            return {
                cpu: { score: Math.round(cpuScore), grade: getGradeFromScore(cpuScore) },
                memory: { score: Math.round(memoryScore), grade: getGradeFromScore(memoryScore) },
                fps: { score: Math.round(fpsScore), grade: getGradeFromScore(fpsScore) }
            };
        }
        
        function getGradeFromScore(score) {
            if (score >= 90) return 'A+';
            if (score >= 80) return 'A';
            if (score >= 70) return 'B';
            if (score >= 60) return 'C';
            if (score >= 50) return 'D';
            return 'F';
        }
        
        function updateScoreDisplay(type, scoreData) {
            const scoreEl = document.getElementById(`${type}Score`);
            const scoreNumEl = document.getElementById(`${type}ScoreNum`);
            
            if (scoreEl && scoreNumEl) {
                scoreEl.textContent = scoreData.grade;
                scoreNumEl.textContent = `(${scoreData.score})`;
                
                // æ›´æ–°é¢œè‰²
                scoreEl.className = 'score-value grade-' + scoreData.grade.toLowerCase().replace('+', '');
            }
        }
        
        function resetPerformanceStats() {
            performanceStats = {
                cpu: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
                memory: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
                fps: { current: 0, avg: 0, min: Infinity, sum: 0, count: 0 },
                threads: { current: 0, avg: 0, max: 0, sum: 0, count: 0 }
            };
            updateStatisticsDisplay();
            // é‡ç½®å†…å­˜æ³„æ¼æ£€æµ‹ç³»ç»Ÿ
            memoryLeakDetection.memoryHistory = [];
            professionalMemoryLeakDetection.memoryHistory = [];
            professionalMemoryLeakDetection.sceneStateMachine.currentScene = 'unknown';
            professionalMemoryLeakDetection.sceneStateMachine.sceneHistory = [];
            professionalMemoryLeakDetection.status.isLeaking = false;
            professionalMemoryLeakDetection.status.leakSources = [];
            professionalMemoryLeakDetection.status.suspiciousTransitions = [];
            professionalMemoryLeakDetection.statistics.totalLeaksDetected = 0;
            professionalMemoryLeakDetection.statistics.averageRecoveryRate = 0;
            activeAlerts = [];
            updateAlertsDisplay();
        }

        function calculateOverallScore() {
            const scores = calculatePerformanceScores();
            return Math.round((scores.cpu.score + scores.memory.score + scores.fps.score) / 3);
        }

        // é¢æ¿æ‹–æ‹½åŠŸèƒ½
        let draggedElement = null;
        let placeholder = null;
        let dragStartY = 0;
        let isDragging = false;

        function initDragAndDrop() {
            const container = document.querySelector('.container');
            if (!container) {
                console.warn('å®¹å™¨å…ƒç´ æœªæ‰¾åˆ°ï¼Œè·³è¿‡æ‹–æ‹½åˆå§‹åŒ–');
                return;
            }
            
            const panels = document.querySelectorAll('.controls');
            if (!panels || panels.length === 0) {
                console.warn('é¢æ¿å…ƒç´ æœªæ‰¾åˆ°ï¼Œè·³è¿‡æ‹–æ‹½åˆå§‹åŒ–');
                return;
            }
            
            panels.forEach(panel => {
                // ç¦æ­¢ç»Ÿè®¡é¢æ¿è¢«æ‹–æ‹½ï¼Œä¿è¯å®ƒå›ºå®šåœ¨å›¾è¡¨ä¸Šæ–¹
                if (panel.id === 'statisticsPanel') {
                    panel.setAttribute('draggable', 'false');
                    panel.style.cursor = 'default'; // æ”¹å˜é¼ æ ‡æ ·å¼æç¤ºä¸å¯æ‹–æ‹½
                    return; // è·³è¿‡ç»Ÿè®¡é¢æ¿ï¼Œä¸æ·»åŠ æ‹–æ‹½äº‹ä»¶
                }
                
                panel.setAttribute('draggable', 'true');
                
                panel.addEventListener('dragstart', function(e) {
                    draggedElement = this;
                    this.classList.add('dragging');
                    dragStartY = e.clientY;
                    isDragging = true;
                    
                    // åˆ›å»ºå ä½ç¬¦
                    placeholder = document.createElement('div');
                    placeholder.className = 'drag-placeholder';
                    
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', this.outerHTML);
                    
                    setTimeout(() => {
                        this.style.display = 'none';
                    }, 0);
                });
                
                panel.addEventListener('dragend', function(e) {
                    this.classList.remove('dragging');
                    this.style.display = 'block';
                    
                    if (placeholder && placeholder.parentNode) {
                        placeholder.parentNode.removeChild(placeholder);
                    }
                    
                    draggedElement = null;
                    placeholder = null;
                    isDragging = false;
                });
            });
            
            // å¤„ç†æ‹–æ”¾ç›®æ ‡
            container.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                if (isDragging && draggedElement && placeholder) {
                    const afterElement = getDragAfterElement(container, e.clientY);
                    if (afterElement == null) {
                        container.appendChild(placeholder);
                    } else {
                        container.insertBefore(placeholder, afterElement);
                    }
                }
            });
            
            container.addEventListener('drop', function(e) {
                e.preventDefault();
                
                if (draggedElement && placeholder && placeholder.parentNode) {
                    placeholder.parentNode.insertBefore(draggedElement, placeholder);
                    placeholder.parentNode.removeChild(placeholder);
                    
                    // ä¿å­˜æ–°çš„é¢æ¿é¡ºåºåˆ°localStorage
                    savePanelOrder();
                    
                    showStatus('é¢æ¿é¡ºåºå·²è°ƒæ•´', 'success');
                }
            });
        }

        function getDragAfterElement(container, y) {
            if (!container) return null;
            
            const draggableElements = [...container.querySelectorAll('.controls:not(.dragging)')];
            if (!draggableElements || draggableElements.length === 0) {
                return null;
            }
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function savePanelOrder() {
            const panels = document.querySelectorAll('.controls');
            const order = [];
            
            panels.forEach(panel => {
                // æ’é™¤ç»Ÿè®¡é¢æ¿ï¼Œä¸ä¿å­˜å®ƒçš„ä½ç½®
                if (panel.id && panel.id !== 'statisticsPanel') {
                    order.push(panel.id);
                }
            });
            
            localStorage.setItem('panelOrder', JSON.stringify(order));
        }

        function restorePanelOrder() {
            const savedOrder = localStorage.getItem('panelOrder');
            if (!savedOrder) return;
            
            try {
                const order = JSON.parse(savedOrder);
                const container = document.querySelector('.container');
                
                if (!container) {
                    console.warn('å®¹å™¨å…ƒç´ æœªæ‰¾åˆ°ï¼Œæ— æ³•æ¢å¤é¢æ¿é¡ºåº');
                    return;
                }
                
                // æ‰¾åˆ°æ‰€æœ‰é¢æ¿ï¼ˆæ’é™¤ç»Ÿè®¡é¢æ¿å’Œå›¾è¡¨ç½‘æ ¼ï¼‰
                const panels = {};
                document.querySelectorAll('.controls').forEach(panel => {
                    if (panel.id && panel.id !== 'statisticsPanel') {
                        // æ’é™¤ç»Ÿè®¡é¢æ¿ï¼Œä¿è¯å®ƒä¸è¢«ç§»åŠ¨
                        panels[panel.id] = panel;
                    }
                });
                
                // æŒ‰ä¿å­˜çš„é¡ºåºé‡æ–°æ’åˆ—ï¼ˆä¸åŒ…æ‹¬ç»Ÿè®¡é¢æ¿ï¼‰
                order.forEach(panelId => {
                    if (panels[panelId]) {
                        container.appendChild(panels[panelId]);
                    }
                });
                
                console.log('å·²æ¢å¤é¢æ¿é¡ºåºï¼ˆç»Ÿè®¡é¢æ¿ä¿æŒå›ºå®šä½ç½®ï¼‰');
            } catch (error) {
                console.log('æ¢å¤é¢æ¿é¡ºåºå¤±è´¥:', error);
            }
        }

        // é‡ç½®é¢æ¿é¡ºåºåŠŸèƒ½
        function resetPanelOrder() {
            localStorage.removeItem('panelOrder');
            location.reload(); // ç®€å•é‡æ–°åŠ è½½é¡µé¢æ¥æ¢å¤é»˜è®¤é¡ºåº
        }

        // åˆ†äº«åŠŸèƒ½
        function showShareDialog() {
            const dialog = document.getElementById('shareDialog');
            const urlElement = document.getElementById('shareUrl');
            
            // è·å–å½“å‰é¡µé¢çš„åˆ†äº«URL
            const currentHost = window.location.hostname;
            const currentPort = window.location.port || (window.location.protocol === 'https:' ? '443' : '80');
            const shareUrl = `${window.location.protocol}//${currentHost}:${currentPort}`;
            
            urlElement.textContent = shareUrl;
            dialog.style.display = 'flex';
            
            // æ·»åŠ ç‚¹å‡»èƒŒæ™¯å…³é—­åŠŸèƒ½
            dialog.onclick = function(e) {
                if (e.target === dialog) {
                    closeShareDialog();
                }
            };
        }

        function closeShareDialog() {
            const dialog = document.getElementById('shareDialog');
            dialog.style.display = 'none';
        }

        function copyShareUrl() {
            const urlElement = document.getElementById('shareUrl');
            const shareUrl = urlElement.textContent;
            
            // ä½¿ç”¨ç°ä»£æµè§ˆå™¨çš„Clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(shareUrl).then(() => {
                    showCopySuccess();
                }).catch(() => {
                    fallbackCopyTextToClipboard(shareUrl);
                });
            } else {
                fallbackCopyTextToClipboard(shareUrl);
            }
        }

        function fallbackCopyTextToClipboard(text) {
            // åˆ›å»ºä¸´æ—¶æ–‡æœ¬åŸŸ
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-999999px";
            textArea.style.top = "-999999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showCopySuccess();
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                showStatus('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶é“¾æ¥', 'error');
            }
            
            document.body.removeChild(textArea);
        }

        function showCopySuccess() {
            const copyBtn = document.querySelector('.copy-btn');
            const originalText = copyBtn.textContent;
            
            copyBtn.textContent = 'âœ… å·²å¤åˆ¶';
            copyBtn.classList.add('copied');
            
            setTimeout(() => {
                copyBtn.textContent = originalText;
                copyBtn.classList.remove('copied');
            }, 2000);
            
            showStatus('åˆ†äº«é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
        }

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function(e) {
            // Ctrl+Shift+S æˆ– Cmd+Shift+S å¿«é€Ÿåˆ†äº«
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'S') {
                e.preventDefault();
                showShareDialog();
            }
            // ESCé”®å…³é—­åˆ†äº«å¯¹è¯æ¡†
            if (e.key === 'Escape') {
                closeShareDialog();
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–ç•Œé¢å·²åŠ è½½');
            
            // åˆå§‹åŒ–æ‹–æ‹½åŠŸèƒ½
            setTimeout(() => {
                initDragAndDrop();
                // ç¡®ä¿ç»Ÿè®¡é¢æ¿åœ¨å›¾è¡¨ç½‘æ ¼ä¸Šæ–¹
                ensureStatisticsPanelPosition();
                // ç„¶åæ¢å¤å…¶ä»–é¢æ¿é¡ºåº
                restorePanelOrder();
            }, 100);
        });
        
        // ç¡®ä¿ç»Ÿè®¡é¢æ¿åœ¨å›¾è¡¨ç½‘æ ¼ä¸Šæ–¹
        function ensureStatisticsPanelPosition() {
            const container = document.querySelector('.container');
            const statisticsPanel = document.getElementById('statisticsPanel');
            const chartsGrid = document.getElementById('chartsGrid');
            
            if (container && statisticsPanel && chartsGrid) {
                // å°†ç»Ÿè®¡é¢æ¿ç§»åŠ¨åˆ°å›¾è¡¨ç½‘æ ¼ä¹‹å‰
                container.insertBefore(statisticsPanel, chartsGrid);
                console.log('âœ… ç»Ÿè®¡é¢æ¿å·²æ”¾ç½®åœ¨å›¾è¡¨ä¸Šæ–¹');
            }
        }
        
        // ======================== ä¸“ä¸šçº§å†…å­˜æ³„æ¼æ£€æµ‹æ ¸å¿ƒå‡½æ•° ========================
        
        // æ™ºèƒ½åœºæ™¯è¯†åˆ«
        function detectCurrentScene(currentMemory, cpuUsage, fpsRate, threads) {
            const history = professionalMemoryLeakDetection.memoryHistory;
            
            if (history.length < 5) return 'unknown';
            
            // åˆ†æå†…å­˜å˜åŒ–æ¨¡å¼
            const recentMemory = history.slice(-5).map(h => h.memory);
            const memoryTrend = calculateTrend(recentMemory);
            const memoryVolatility = calculateVolatility(recentMemory);
            
            // åœºæ™¯è¯†åˆ«è§„åˆ™ (åŸºäºçœŸå®iOSåº”ç”¨ç‰¹å¾)
            if (currentMemory < 120 && cpuUsage < 20 && Math.abs(memoryTrend) < 2) {
                return currentMemory < 90 ? 'background' : 'idle';
            } else if (memoryTrend > 15 && cpuUsage > 40) {
                return currentMemory > 250 ? 'video_playing' : 'launching';
            } else if (memoryVolatility > 10 && cpuUsage > 15) {
                return 'navigation';
            } else if (currentMemory > 200 && fpsRate > 30) {
                return 'video_playing';
            }
            
            return 'idle';
        }
        
        // è®¡ç®—æ•°æ®è¶‹åŠ¿
        function calculateTrend(values) {
            if (values.length < 2) return 0;
            let sum = 0;
            for (let i = 1; i < values.length; i++) {
                sum += values[i] - values[i-1];
            }
            return sum / (values.length - 1);
        }
        
        // è®¡ç®—æ•°æ®æ³¢åŠ¨æ€§
        function calculateVolatility(values) {
            if (values.length < 2) return 0;
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            return Math.sqrt(variance);
        }
        
        // ä¸“ä¸šçº§æ£€æµ‹æ‰§è¡Œå™¨
        function runProfessionalMemoryLeakDetection(currentMemory, cpuUsage, fpsRate, threads) {
            const now = Date.now();
            const stateMachine = professionalMemoryLeakDetection.sceneStateMachine;
            const detection = professionalMemoryLeakDetection.detection;
            
            // è®°å½•å†…å­˜å†å²
            professionalMemoryLeakDetection.memoryHistory.push({
                time: now,
                memory: currentMemory,
                cpu: cpuUsage,
                fps: fpsRate,
                threads: threads,
                scene: null
            });
            
            // ä¿æŒå†å²è®°å½•é•¿åº¦
            if (professionalMemoryLeakDetection.memoryHistory.length > professionalMemoryLeakDetection.maxHistoryLength) {
                professionalMemoryLeakDetection.memoryHistory.shift();
            }
            
            // æ£€æµ‹å½“å‰åœºæ™¯
            const detectedScene = detectCurrentScene(currentMemory, cpuUsage, fpsRate, threads);
            professionalMemoryLeakDetection.memoryHistory[professionalMemoryLeakDetection.memoryHistory.length - 1].scene = detectedScene;
            
            // åœºæ™¯åˆ‡æ¢æ£€æµ‹
            if (detectedScene !== stateMachine.currentScene && stateMachine.currentScene !== 'unknown') {
                handleSceneTransition(stateMachine.currentScene, detectedScene, currentMemory, now);
            }
            
            // æ›´æ–°å½“å‰åœºæ™¯ä¿¡æ¯
            if (!stateMachine.sceneStartTime || detectedScene !== stateMachine.currentScene) {
                stateMachine.sceneStartTime = now;
                stateMachine.sceneStartMemory = currentMemory;
            }
            
            stateMachine.currentScene = detectedScene;
            
            // æ‰§è¡Œå¤šç»´åº¦æ£€æµ‹
            if (professionalMemoryLeakDetection.memoryHistory.length >= detection.minSampleSize) {
                performComprehensiveLeakDetection(currentMemory, now);
            }
            
            // æ›´æ–°UIæ˜¾ç¤º
            updateProfessionalMemoryLeakUI();
        }
        
        // å¤„ç†åœºæ™¯åˆ‡æ¢
        function handleSceneTransition(fromScene, toScene, currentMemory, timestamp) {
            const stateMachine = professionalMemoryLeakDetection.sceneStateMachine;
            const detection = professionalMemoryLeakDetection.detection;
            
            const sceneDuration = timestamp - stateMachine.sceneStartTime;
            
            // åªæœ‰åœºæ™¯æŒç»­è¶³å¤Ÿé•¿æ—¶é—´æ‰è¿›è¡Œåˆ†æ
            if (sceneDuration >= detection.sceneMinDuration) {
                analyzeSceneTransition(fromScene, toScene, stateMachine.sceneStartMemory, currentMemory, sceneDuration);
            }
            
            // è®°å½•åœºæ™¯åˆ‡æ¢å†å²
            stateMachine.sceneHistory.push({
                fromScene,
                toScene,
                startMemory: stateMachine.sceneStartMemory,
                endMemory: currentMemory,
                duration: sceneDuration,
                timestamp: timestamp,
                memoryDelta: currentMemory - stateMachine.sceneStartMemory
            });
            
            // ä¿æŒå†å²è®°å½•é•¿åº¦
            if (stateMachine.sceneHistory.length > 50) {
                stateMachine.sceneHistory.shift();
            }
            
            stateMachine.sceneTransitionCount++;
            console.log(`ğŸ”„ åœºæ™¯åˆ‡æ¢: ${fromScene} â†’ ${toScene}, å†…å­˜å˜åŒ–: ${(currentMemory - stateMachine.sceneStartMemory).toFixed(1)}MB`);
        }
        
        // åˆ†æåœºæ™¯åˆ‡æ¢çš„å†…å­˜å›æ”¶æƒ…å†µ
        function analyzeSceneTransition(fromScene, toScene, startMemory, endMemory, duration) {
            const profiles = professionalMemoryLeakDetection.sceneProfiles;
            const status = professionalMemoryLeakDetection.status;
            
            // æ£€æŸ¥æ˜¯å¦ä»é«˜å†…å­˜åœºæ™¯åˆ‡æ¢åˆ°ä½å†…å­˜åœºæ™¯
            const fromPriority = profiles[fromScene]?.priority || 0;
            const toPriority = profiles[toScene]?.priority || 0;
            
            if (fromPriority > toPriority) {
                // æœŸæœ›å†…å­˜ä¸‹é™
                const expectedDecrease = calculateExpectedMemoryDecrease(fromScene, toScene, startMemory);
                const actualDecrease = Math.max(0, startMemory - endMemory);
                const recoveryRate = expectedDecrease > 0 ? actualDecrease / expectedDecrease : 1;
                
                // æ›´æ–°ç»Ÿè®¡
                const stats = professionalMemoryLeakDetection.statistics;
                stats.averageRecoveryRate = (stats.averageRecoveryRate + recoveryRate) / 2;
                
                // æ£€æµ‹å†…å­˜æ³„æ¼
                if (recoveryRate < professionalMemoryLeakDetection.detection.leakThreshold && expectedDecrease > 10) {
                    const leakAmount = Math.max(0, expectedDecrease - actualDecrease);
                    reportMemoryLeak(fromScene, toScene, leakAmount, recoveryRate, 'scene_transition');
                }
                
                console.log(`ğŸ“Š åœºæ™¯åˆ‡æ¢åˆ†æ: ${fromScene} â†’ ${toScene}, æœŸæœ›å›æ”¶: ${expectedDecrease.toFixed(1)}MB, å®é™…å›æ”¶: ${actualDecrease.toFixed(1)}MB, å›æ”¶ç‡: ${(recoveryRate*100).toFixed(1)}%`);
            }
        }
        
        // è®¡ç®—æœŸæœ›çš„å†…å­˜ä¸‹é™é‡
        function calculateExpectedMemoryDecrease(fromScene, toScene, currentMemory) {
            const profiles = professionalMemoryLeakDetection.sceneProfiles;
            const fromProfile = profiles[fromScene];
            const toProfile = profiles[toScene];
            
            if (!fromProfile || !toProfile) return 0;
            
            // åŸºäºåœºæ™¯ç‰¹æ€§è®¡ç®—æœŸæœ›ä¸‹é™é‡
            const fromExpected = (fromProfile.expectedMemory.min + fromProfile.expectedMemory.max) / 2;
            const toExpected = (toProfile.expectedMemory.min + toProfile.expectedMemory.max) / 2;
            
            // è€ƒè™‘å½“å‰å†…å­˜æ°´å¹³çš„è°ƒæ•´å› å­
            const ratio = Math.min(1.0, Math.max(0.3, currentMemory / fromExpected));
            return Math.max(0, (fromExpected - toExpected) * ratio);
        }
        
        // æŠ¥å‘Šå†…å­˜æ³„æ¼
        function reportMemoryLeak(fromScene, toScene, leakAmount, recoveryRate, source) {
            const status = professionalMemoryLeakDetection.status;
            const statistics = professionalMemoryLeakDetection.statistics;
            
            statistics.totalLeaksDetected++;
            
            const leakReport = {
                source: source,
                fromScene: fromScene,
                toScene: toScene,
                leakAmount: leakAmount,
                recoveryRate: recoveryRate,
                timestamp: Date.now(),
                severity: leakAmount > 50 ? 'severe' : leakAmount > 20 ? 'moderate' : 'mild'
            };
            
            status.suspiciousTransitions.push(leakReport);
            
            // ä¿æŒè®°å½•é•¿åº¦
            if (status.suspiciousTransitions.length > 10) {
                status.suspiciousTransitions.shift();
            }
            
            console.log(`ğŸš¨ å†…å­˜æ³„æ¼æ£€æµ‹: ${fromScene} â†’ ${toScene}, æ³„æ¼é‡: ${leakAmount.toFixed(1)}MB, å›æ”¶ç‡: ${(recoveryRate*100).toFixed(1)}%`);
        }
        
        // ç»¼åˆæ³„æ¼æ£€æµ‹
        function performComprehensiveLeakDetection(currentMemory, timestamp) {
            const history = professionalMemoryLeakDetection.memoryHistory;
            const detection = professionalMemoryLeakDetection.detection;
            
            // 1. è¶‹åŠ¿åˆ†æ
            const trendWindow = Math.min(detection.trendAnalysisWindow, history.length);
            const recentHistory = history.slice(-trendWindow);
            const memoryTrend = calculateAdvancedTrend(recentHistory);
            
            // 2. å¼‚å¸¸æ£€æµ‹
            const anomalies = detectMemoryAnomalies(recentHistory);
            
            // 3. é•¿æœŸå†…å­˜å¢é•¿æ£€æµ‹
            const longTermGrowth = analyzeLongTermMemoryGrowth(history);
            
            // ç»¼åˆè¯„ä¼°
            evaluateOverallLeakStatus(memoryTrend, anomalies, longTermGrowth);
        }
        
        // é«˜çº§è¶‹åŠ¿åˆ†æ
        function calculateAdvancedTrend(historyWindow) {
            if (historyWindow.length < 10) return { slope: 0, confidence: 0, pattern: 'insufficient_data' };
            
            const memoryValues = historyWindow.map(h => h.memory);
            const timeValues = historyWindow.map((h, i) => i);
            
            // çº¿æ€§å›å½’
            const slope = calculateLinearRegressionSlope(timeValues, memoryValues);
            const correlation = calculateCorrelation(timeValues, memoryValues);
            
            return {
                slope: slope,
                confidence: Math.abs(correlation),
                pattern: identifyMemoryPattern(memoryValues),
                volatility: calculateVolatility(memoryValues)
            };
        }
        
        // çº¿æ€§å›å½’æ–œç‡è®¡ç®—
        function calculateLinearRegressionSlope(x, y) {
            const n = x.length;
            if (n < 2) return 0;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            
            const denominator = n * sumXX - sumX * sumX;
            return denominator === 0 ? 0 : (n * sumXY - sumX * sumY) / denominator;
        }
        
        // ç›¸å…³ç³»æ•°è®¡ç®—
        function calculateCorrelation(x, y) {
            const n = x.length;
            if (n < 2) return 0;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumYY = y.reduce((sum, yi) => sum + yi * yi, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }
        
        // å†…å­˜æ¨¡å¼è¯†åˆ«
        function identifyMemoryPattern(memoryValues) {
            const trend = calculateTrend(memoryValues);
            const volatility = calculateVolatility(memoryValues);
            
            if (Math.abs(trend) < 1 && volatility < 5) return 'stable';
            if (trend > 5) return 'increasing';
            if (trend < -5) return 'decreasing';
            if (volatility > 15) return 'volatile';
            return 'normal';
        }
        
        // å†…å­˜å¼‚å¸¸æ£€æµ‹
        function detectMemoryAnomalies(historyWindow) {
            if (historyWindow.length < 10) return [];
            
            const memoryValues = historyWindow.map(h => h.memory);
            const mean = memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length;
            const stdDev = Math.sqrt(memoryValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / memoryValues.length);
            
            if (stdDev === 0) return [];
            
            const threshold = professionalMemoryLeakDetection.detection.anomalyThreshold;
            const anomalies = [];
            
            memoryValues.forEach((value, index) => {
                const zScore = Math.abs((value - mean) / stdDev);
                if (zScore > threshold) {
                    anomalies.push({
                        index: index,
                        value: value,
                        zScore: zScore,
                        severity: zScore > 3 ? 'high' : 'medium'
                    });
                }
            });
            
            return anomalies;
        }
        
        // é•¿æœŸå†…å­˜å¢é•¿åˆ†æ
        function analyzeLongTermMemoryGrowth(fullHistory) {
            if (fullHistory.length < 50) return { growth: 0, significance: 'low' };
            
            const segments = Math.min(5, Math.floor(fullHistory.length / 20));
            const segmentSize = Math.floor(fullHistory.length / segments);
            const segmentAverages = [];
            
            for (let i = 0; i < segments; i++) {
                const start = i * segmentSize;
                const end = start + segmentSize;
                const segment = fullHistory.slice(start, end);
                const average = segment.reduce((sum, h) => sum + h.memory, 0) / segment.length;
                segmentAverages.push(average);
            }
            
            const overallGrowth = segmentAverages[segmentAverages.length - 1] - segmentAverages[0];
            const growthRate = overallGrowth / segmentAverages.length;
            
            return {
                growth: overallGrowth,
                growthRate: growthRate,
                significance: Math.abs(growthRate) > 5 ? 'high' : 'low',
                segmentAverages: segmentAverages
            };
        }
        
        // ç»¼åˆè¯„ä¼°æ³„æ¼çŠ¶æ€
        function evaluateOverallLeakStatus(trendAnalysis, anomalies, longTermGrowth) {
            const status = professionalMemoryLeakDetection.status;
            let leakScore = 0;
            const leakSources = [];
            
            // è¶‹åŠ¿åˆ†æè¯„åˆ†
            if (trendAnalysis.slope > 2 && trendAnalysis.confidence > 0.7) {
                leakScore += 30;
                leakSources.push(`æŒç»­å†…å­˜å¢é•¿è¶‹åŠ¿ (${trendAnalysis.slope.toFixed(2)} MB/æ ·æœ¬)`);
            }
            
            // å¼‚å¸¸æ£€æµ‹è¯„åˆ†
            if (anomalies.length > 0) {
                leakScore += Math.min(25, anomalies.length * 5);
                leakSources.push(`æ£€æµ‹åˆ° ${anomalies.length} ä¸ªå†…å­˜å¼‚å¸¸å³°å€¼`);
            }
            
            // é•¿æœŸå¢é•¿è¯„åˆ†
            if (longTermGrowth.significance === 'high' && longTermGrowth.growth > 30) {
                leakScore += 25;
                leakSources.push(`é•¿æœŸå†…å­˜å¢é•¿ ${longTermGrowth.growth.toFixed(1)} MB`);
            }
            
            // åœºæ™¯åˆ‡æ¢å¼‚å¸¸è¯„åˆ†
            if (status.suspiciousTransitions.length > 0) {
                leakScore += Math.min(20, status.suspiciousTransitions.length * 4);
                leakSources.push(`åœºæ™¯åˆ‡æ¢å¼‚å¸¸ ${status.suspiciousTransitions.length} æ¬¡`);
            }
            
            // ç¡®å®šæ³„æ¼ç­‰çº§
            let leakLevel = 'none';
            if (leakScore >= 70) leakLevel = 'severe';
            else if (leakScore >= 45) leakLevel = 'moderate';
            else if (leakScore >= 20) leakLevel = 'mild';
            
            // æ›´æ–°çŠ¶æ€
            const wasLeaking = status.isLeaking;
            status.isLeaking = leakLevel !== 'none';
            status.leakLevel = leakLevel;
            status.leakSources = leakSources;
            
            // å¦‚æœçŠ¶æ€æ”¹å˜ï¼Œè§¦å‘è­¦å‘Š
            if (status.isLeaking && !wasLeaking) {
                showProfessionalMemoryLeakWarning(leakLevel, leakSources, leakScore);
            } else if (!status.isLeaking && wasLeaking) {
                hideProfessionalMemoryLeakWarning();
            }
        }
        
        // æ›´æ–°ä¸“ä¸šçº§å†…å­˜æ³„æ¼UIæ˜¾ç¤º
        function updateProfessionalMemoryLeakUI() {
            const status = professionalMemoryLeakDetection.status;
            const stateMachine = professionalMemoryLeakDetection.sceneStateMachine;
            const statistics = professionalMemoryLeakDetection.statistics;
            
            // æ›´æ–°æ£€æµ‹çŠ¶æ€
            const leakStatusEl = document.getElementById('leakStatus');
            const memoryTrendEl = document.getElementById('memoryTrend');
            const leakRateEl = document.getElementById('leakRate');
            
            if (leakStatusEl) {
                if (status.isLeaking) {
                    const levelText = status.leakLevel === 'severe' ? 'ğŸ”´ ä¸¥é‡æ³„æ¼' : 
                                     status.leakLevel === 'moderate' ? 'ğŸŸ  ä¸­åº¦æ³„æ¼' : 'ğŸŸ¡ è½»å¾®æ³„æ¼';
                    leakStatusEl.textContent = levelText;
                } else {
                    leakStatusEl.textContent = 'âœ… æ­£å¸¸';
                }
            }
            
            if (memoryTrendEl) {
                const sceneName = professionalMemoryLeakDetection.sceneProfiles[stateMachine.currentScene]?.name || stateMachine.currentScene;
                memoryTrendEl.textContent = `å½“å‰åœºæ™¯: ${sceneName}`;
            }
            
            if (leakRateEl) {
                leakRateEl.textContent = `å¹³å‡å›æ”¶ç‡: ${(statistics.averageRecoveryRate * 100).toFixed(1)}%`;
            }
        }
        
        // ä¸“ä¸šçº§æ³„æ¼è­¦å‘Šæ˜¾ç¤º
        function showProfessionalMemoryLeakWarning(leakLevel, leakSources, leakScore) {
            const warningEl = document.getElementById('leakWarning');
            const detailsEl = document.getElementById('leakDetails');
            
            if (detailsEl) {
                const severityText = leakLevel === 'severe' ? 'ğŸ”´ ä¸¥é‡' : leakLevel === 'moderate' ? 'ğŸŸ  ä¸­åº¦' : 'ğŸŸ¡ è½»å¾®';
                
                detailsEl.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <strong>${severityText} å†…å­˜æ³„æ¼æ£€æµ‹ (è¯„åˆ†: ${leakScore})</strong>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <strong>æ£€æµ‹æº:</strong>
                        ${leakSources.map(source => `<div style="margin-left: 10px;">â€¢ ${source}</div>`).join('')}
                    </div>
                    <div style="font-size: 12px; color: #666; margin-top: 8px;">
                        ğŸ¯ <strong>ä¸“ä¸šçº§æ£€æµ‹æ–¹æ³•:</strong><br>
                        â€¢ åœºæ™¯åˆ‡æ¢å†…å­˜å›æ”¶ç‡åˆ†æ<br>
                        â€¢ ç»Ÿè®¡å­¦å¼‚å¸¸æ£€æµ‹ (Z-Score)<br>
                        â€¢ çº¿æ€§å›å½’è¶‹åŠ¿åˆ†æ<br>
                        â€¢ é•¿æœŸå†…å­˜å¢é•¿æ¨¡å¼è¯†åˆ«
                    </div>
                `;
            }
            
            if (warningEl) {
                warningEl.style.display = 'block';
                warningEl.classList.add('active');
            }
            
            console.log(`ğŸš¨ ä¸“ä¸šçº§å†…å­˜æ³„æ¼æ£€æµ‹: ${leakLevel}, è¯„åˆ†: ${leakScore}, æº: ${leakSources.join(', ')}`);
        }
        
        // éšè—ä¸“ä¸šçº§æ³„æ¼è­¦å‘Š
        function hideProfessionalMemoryLeakWarning() {
            const warningEl = document.getElementById('leakWarning');
            if (warningEl) {
                warningEl.style.display = 'none';
                warningEl.classList.remove('active');
            }
        }
        
        // å…¼å®¹æ—§ç³»ç»Ÿçš„å†…å­˜æ³„æ¼UIæ›´æ–°
        function updateLegacyMemoryLeakUI(currentMemory) {
            const now = Date.now();
            memoryLeakDetection.memoryHistory.push({
                time: now,
                memory: currentMemory
            });
            
            // ä¿æŒæ£€æµ‹çª—å£å¤§å°
            const windowStart = now - memoryLeakDetection.detectionWindow;
            memoryLeakDetection.memoryHistory = memoryLeakDetection.memoryHistory.filter(
                item => item.time >= windowStart
            );
            
            // ä½¿ç”¨ä¸“ä¸šæ£€æµ‹ç»“æœæ›´æ–°æ—§ç³»ç»ŸçŠ¶æ€
            memoryLeakDetection.isLeaking = professionalMemoryLeakDetection.status.isLeaking;
            
            // å¦‚æœæ²¡æœ‰ä¸“ä¸šçº§è­¦å‘Šæ˜¾ç¤ºï¼Œä½¿ç”¨æ—§çš„ç®€å•æ˜¾ç¤º
            if (!professionalMemoryLeakDetection.status.isLeaking && memoryLeakDetection.memoryHistory.length >= 10) {
                const timeSpan = (now - memoryLeakDetection.memoryHistory[0].time) / 60000;
                const memoryIncrease = currentMemory - memoryLeakDetection.memoryHistory[0].memory;
                const growthRate = memoryIncrease / timeSpan;
                
                const leakRateEl = document.getElementById('leakRate');
                if (leakRateEl && !professionalMemoryLeakDetection.status.isLeaking) {
                    leakRateEl.textContent = `å¢é•¿ç‡: ${growthRate.toFixed(2)} MB/min`;
                }
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨æ£€æµ‹è®¾å¤‡
        document.addEventListener('DOMContentLoaded', function() {
            refreshDevices();
        });
    </script>
</body>
</html>
