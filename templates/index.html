<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOS性能监控可视化</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f7;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #1d1d1f;
            margin-bottom: 10px;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        .controls h3 {
            margin-top: 0;
            color: #1d1d1f;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #424245;
        }
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        .form-group input:focus {
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }
        .btn {
            background: #007aff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .btn:hover {
            background: #0056cc;
        }
        .btn:disabled {
            background: #d2d2d7;
            cursor: not-allowed;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .chart-container h3 {
            margin: 0 0 20px 0;
            color: #1d1d1f;
            font-size: 18px;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .current-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .value-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .value-card .label {
            font-size: 12px;
            color: #86868b;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        .value-card .value {
            font-size: 24px;
            font-weight: 600;
            color: #1d1d1f;
        }
        .hidden {
            display: none;
        }
        .scene-controls {
            background: #f0f8ff;
            border: 1px solid #007aff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .scene-controls h4 {
            margin: 0 0 10px 0;
            color: #007aff;
        }
        .scene-list {
            margin-top: 15px;
        }
        .scene-item {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: between;
            align-items: center;
            font-size: 14px;
        }
        .scene-item .scene-info {
            flex: 1;
        }
        .scene-item .scene-time {
            color: #86868b;
            font-size: 12px;
        }
        .scene-item .scene-actions {
            margin-left: 10px;
        }
        .scene-item button {
            background: #ff3b30;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        .chart-selection-overlay {
            position: absolute;
            background: rgba(0, 122, 255, 0.2);
            border: 2px solid #007aff;
            pointer-events: none;
            display: none;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
            cursor: crosshair;
        }
        .selecting .chart-wrapper {
            cursor: crosshair;
        }
        .tag-controls {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .tag-controls h4 {
            margin: 0 0 10px 0;
            color: #856404;
        }
        .tag-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }
        .tag-item .tag-info {
            flex: 1;
        }
        .tag-item .tag-time {
            color: #6c757d;
            font-size: 12px;
        }
        .tag-item .tag-note {
            color: #495057;
            font-style: italic;
            margin-top: 3px;
        }
        .tag-item .tag-actions {
            margin-left: 10px;
        }
        .tag-item button {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        .chart-tag-marker {
            position: absolute;
            width: 2px;
            background: #ffc107;
            top: 0;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .chart-tag-marker::after {
            content: '🏷️';
            position: absolute;
            top: -5px;
            left: -8px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📱 iOS性能监控可视化</h1>
            <p>基于原始main.py逻辑的实时性能图表显示</p>
        </div>

        <div class="controls">
            <h3>🔧 监控配置</h3>
            <div class="form-group">
                <label for="udid">设备UDID（可选）:</label>
                <input type="text" id="udid" placeholder="留空使用默认设备">
            </div>
            <div class="form-group">
                <label for="bundleId">应用Bundle ID:</label>
                <input type="text" id="bundleId" value="com.newleaf.app.ios.vic" placeholder="默认应用">
            </div>
            <button class="btn" id="startBtn" onclick="startMonitoring()">开始监控</button>
            <button class="btn" id="stopBtn" onclick="stopMonitoring()" disabled>停止监控</button>
            <button class="btn" id="saveBtn" onclick="saveData()" disabled>保存数据</button>
            <button class="btn" id="importBtn" onclick="document.getElementById('fileInput').click()">导入数据</button>
            <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="importData(event)">
        </div>

        <div id="status" class="status hidden"></div>

        <!-- 时间范围控制 -->
        <div class="controls" id="timeControls" style="display: none;">
            <h3>⏰ 时间范围控制</h3>
            <div style="display: flex; gap: 15px; align-items: center;">
                <div style="flex: 1;">
                    <label for="windowSize">显示窗口大小:</label>
                    <input type="number" id="windowSize" min="10" max="500" value="50" step="10" oninput="updateWindowSize(this.value)" style="width: 80px; padding: 4px;">
                    <span id="windowSizeValue">50个点</span>
                </div>
                <div style="flex: 2;">
                    <label for="timeSlider">时间轴拖动:</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="timeSlider" min="0" max="100" value="100" oninput="updateTimePosition(this.value)" style="flex: 1;">
                        <span id="timePosition">最新</span>
                        <button onclick="goToLatest()" style="padding: 4px 8px; background: #007aff; color: white; border: none; border-radius: 4px; font-size: 12px;">跳到最新</button>
                    </div>
                </div>
                <div class="form-group" style="flex: 1; margin-bottom: 0;">
                    <label for="updateInterval">更新间隔（毫秒）:</label>
                    <input type="range" id="updateInterval" min="500" max="5000" value="1000" oninput="updateInterval(this.value)">
                    <span id="intervalValue">1000ms</span>
                </div>
            </div>
        </div>

        <!-- 场景标记控制 -->
        <div class="scene-controls" id="sceneControls" style="display: none;">
            <h4>🎬 场景标记</h4>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <button class="btn" id="startSelectionBtn" onclick="toggleSelection()">开始选择时间区域</button>
                <input type="text" id="sceneNameInput" placeholder="场景名称" style="padding: 8px; border: 1px solid #d2d2d7; border-radius: 6px; width: 200px;">
                <button class="btn" id="saveSceneBtn" onclick="saveScene()" disabled>保存场景</button>
                <button class="btn" id="clearScenesBtn" onclick="clearAllScenes()">清空所有场景</button>
            </div>
            <div id="selectionStatus" style="font-size: 14px; color: #86868b; margin-bottom: 10px;"></div>
            <div class="scene-list" id="sceneList"></div>
        </div>

        <!-- 单点标签控制 -->
        <div class="tag-controls" id="tagControls" style="display: none;">
            <h4>🏷️ 单点标签</h4>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <span style="font-size: 14px; color: #856404;">双击图表任意位置添加标签</span>
                <button class="btn" id="clearTagsBtn" onclick="clearAllTags()">清空所有标签</button>
            </div>
            <div class="scene-list" id="tagList"></div>
        </div>

        <div class="current-values" id="currentValues" style="display: none;">
            <div class="value-card">
                <div class="label">CPU使用率</div>
                <div class="value" id="currentCpu">0%</div>
            </div>
            <div class="value-card">
                <div class="label">内存使用</div>
                <div class="value" id="currentMemory">0MB</div>
            </div>
            <div class="value-card">
                <div class="label">帧率</div>
                <div class="value" id="currentFps">0FPS</div>
            </div>
            <div class="value-card">
                <div class="label">线程数</div>
                <div class="value" id="currentThreads">0</div>
            </div>
        </div>

        <div class="charts-grid" id="chartsGrid" style="display: none;">
            <div class="chart-container">
                <h3>📊 CPU使用率</h3>
                <div class="chart-wrapper" data-chart="cpu">
                    <canvas id="cpuChart"></canvas>
                    <div class="chart-selection-overlay" id="cpuOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>💾 内存使用量</h3>
                <div class="chart-wrapper" data-chart="memory">
                    <canvas id="memoryChart"></canvas>
                    <div class="chart-selection-overlay" id="memoryOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>🎮 帧率(FPS)</h3>
                <div class="chart-wrapper" data-chart="fps">
                    <canvas id="fpsChart"></canvas>
                    <div class="chart-selection-overlay" id="fpsOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>🧵 线程数量</h3>
                <div class="chart-wrapper" data-chart="threads">
                    <canvas id="threadsChart"></canvas>
                    <div class="chart-selection-overlay" id="threadsOverlay"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WebSocket连接
        const socket = io();
        
        // 图表实例
        let cpuChart, memoryChart, fpsChart, threadsChart;
        
        // 数据存储
        let isMonitoring = false;
        let windowSize = 50; // 显示窗口大小
        let timePosition = 100; // 时间位置百分比，100表示最新
        let allPerformanceData = []; // 存储所有性能数据用于保存
        let allTimeLabels = []; // 存储所有时间标签
        let allCpuData = []; // 存储所有CPU数据
        let allMemoryData = []; // 存储所有内存数据
        let allFpsData = []; // 存储所有FPS数据
        let allThreadsData = []; // 存储所有线程数据
        let currentUpdateInterval = 1000; // 当前更新间隔
        let isFollowingLatest = true; // 是否跟随最新数据
        
        // 场景选择相关变量
        let isSelecting = false;
        let selectionStart = null;
        let selectionEnd = null;
        let currentSelection = null;
        let savedScenes = []; // 保存的场景列表
        let isMouseDown = false;
        let selectionStartX = 0;
        
        // 标签相关变量
        let savedTags = []; // 保存的标签列表
        
        // 图表配置
        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: '时间'
                    }
                },
                y: {
                    display: true,
                    beginAtZero: true
                }
            },
            elements: {
                line: {
                    tension: 0.4
                },
                point: {
                    radius: 3
                }
            }
        };

        // 初始化图表
        function initCharts() {
            const cpuCtx = document.getElementById('cpuChart').getContext('2d');
            cpuChart = new Chart(cpuCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'CPU使用率 (%)',
                        data: [],
                        borderColor: '#ff3b30',
                        backgroundColor: 'rgba(255, 59, 48, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'CPU使用率 (%)'
                            }
                        }
                    }
                }
            });

            const memoryCtx = document.getElementById('memoryChart').getContext('2d');
            memoryChart = new Chart(memoryCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '内存使用 (MB)',
                        data: [],
                        borderColor: '#007aff',
                        backgroundColor: 'rgba(0, 122, 255, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: '内存使用 (MB)'
                            }
                        }
                    }
                }
            });

            const fpsCtx = document.getElementById('fpsChart').getContext('2d');
            fpsChart = new Chart(fpsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '帧率 (FPS)',
                        data: [],
                        borderColor: '#34c759',
                        backgroundColor: 'rgba(52, 199, 89, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: '帧率 (FPS)'
                            },
                            max: 60
                        }
                    }
                }
            });

            const threadsCtx = document.getElementById('threadsChart').getContext('2d');
            threadsChart = new Chart(threadsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '线程数量',
                        data: [],
                        borderColor: '#ff9500',
                        backgroundColor: 'rgba(255, 149, 0, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: '线程数量'
                            }
                        }
                    }
                }
            });
        }

        // 添加数据到图表
        function addDataToChart(chart, label, data) {
            // 存储到全局数组
            if (chart === cpuChart) {
                allTimeLabels.push(label);
                allCpuData.push(data);
            } else if (chart === memoryChart) {
                allMemoryData.push(data);
            } else if (chart === fpsChart) {
                allFpsData.push(data);
            } else if (chart === threadsChart) {
                allThreadsData.push(data);
            }
            
            // 如果正在跟随最新数据，更新显示
            if (isFollowingLatest) {
                updateChartDisplay();
            }
            
            // 更新标签位置（仅在CPU图表更新时执行，避免重复）
            if (chart === cpuChart && savedTags.length > 0) {
                updateAllTagMarkers();
                updateTagList(); // 更新标签列表状态
            }
        }

        // 显示状态消息
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.classList.remove('hidden');
        }

        // 隐藏状态消息
        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        // 窗口大小和时间位置控制函数
        function updateWindowSize(value) {
            windowSize = parseInt(value);
            document.getElementById('windowSizeValue').textContent = windowSize + '个点';
            updateChartDisplay();
        }

        function updateTimePosition(value) {
            timePosition = parseInt(value);
            isFollowingLatest = (timePosition === 100);
            
            if (isFollowingLatest) {
                document.getElementById('timePosition').textContent = '最新';
            } else {
                const totalData = allTimeLabels.length;
                const endIndex = Math.floor((timePosition / 100) * totalData);
                const startIndex = Math.max(0, endIndex - windowSize);
                document.getElementById('timePosition').textContent = `${startIndex}-${endIndex}`;
            }
            
            updateChartDisplay();
        }

        function goToLatest() {
            timePosition = 100;
            isFollowingLatest = true;
            document.getElementById('timeSlider').value = 100;
            document.getElementById('timePosition').textContent = '最新';
            updateChartDisplay();
        }

        function updateChartDisplay() {
            if (allTimeLabels.length === 0) return;

            let startIndex, endIndex;
            
            if (isFollowingLatest) {
                // 跟随最新数据
                endIndex = allTimeLabels.length;
                startIndex = Math.max(0, endIndex - windowSize);
            } else {
                // 根据时间位置计算显示范围
                const totalData = allTimeLabels.length;
                endIndex = Math.floor((timePosition / 100) * totalData);
                startIndex = Math.max(0, endIndex - windowSize);
                endIndex = Math.min(totalData, startIndex + windowSize);
            }

            // 更新所有图表的显示数据
            updateChartData(cpuChart, allTimeLabels.slice(startIndex, endIndex), allCpuData.slice(startIndex, endIndex));
            updateChartData(memoryChart, allTimeLabels.slice(startIndex, endIndex), allMemoryData.slice(startIndex, endIndex));
            updateChartData(fpsChart, allTimeLabels.slice(startIndex, endIndex), allFpsData.slice(startIndex, endIndex));
            updateChartData(threadsChart, allTimeLabels.slice(startIndex, endIndex), allThreadsData.slice(startIndex, endIndex));

            // 更新拖动条的范围
            if (allTimeLabels.length > windowSize) {
                const maxSliderValue = Math.floor(((allTimeLabels.length - windowSize) / allTimeLabels.length) * 100);
                document.getElementById('timeSlider').max = 100;
                if (!isFollowingLatest && timePosition > maxSliderValue) {
                    timePosition = maxSliderValue;
                    document.getElementById('timeSlider').value = timePosition;
                }
            }
            
            // 更新标签位置
            updateAllTagMarkers();
        }

        function updateChartData(chart, labels, data) {
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update('none');
        }

        function updateInterval(value) {
            currentUpdateInterval = parseInt(value);
            document.getElementById('intervalValue').textContent = value + 'ms';
        }

        // 标签功能
        function enableDoubleClickTags() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('dblclick', onDoubleClickTag);
            });
        }

        function onDoubleClickTag(e) {
            if (isSelecting) return; // 选择模式下不添加标签
            
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // 计算时间索引
            const clickIndex = Math.floor((clickX / chartWidth) * (cpuChart.data.labels.length));
            const timeLabel = cpuChart.data.labels[clickIndex];
            
            if (timeLabel) {
                // 弹出输入框让用户输入标签内容
                const tagNote = prompt('请输入标签备注:', '');
                if (tagNote !== null && tagNote.trim() !== '') {
                    addTag(timeLabel, tagNote.trim(), clickX, chartWidth);
                }
            }
        }

        function addTag(timeLabel, note, clickX, chartWidth) {
            const tag = {
                id: Date.now(),
                time: timeLabel,
                note: note,
                createdAt: new Date().toISOString()
            };

            savedTags.push(tag);
            updateTagList();
            
            // 在所有图表上添加标签标记
            addTagMarkersToAllCharts(tag);
            
            showStatus(`标签 "${note}" 已添加到 ${timeLabel}`, 'success');
        }

        function addTagMarkersToAllCharts(tag) {
            // 不在这里直接添加DOM元素，而是在updateAllTagMarkers中统一处理
            updateAllTagMarkers();
        }

        function updateAllTagMarkers() {
            // 删除所有现有的标记
            const existingMarkers = document.querySelectorAll('.chart-tag-marker');
            existingMarkers.forEach(marker => marker.remove());

            // 重新添加所有标签标记
            if (cpuChart && cpuChart.data.labels.length > 0) {
                savedTags.forEach(tag => {
                    // 找到标签时间在当前图表中的位置
                    const timeIndex = cpuChart.data.labels.findIndex(label => label === tag.time);
                    if (timeIndex !== -1 && timeIndex >= 0 && timeIndex < cpuChart.data.labels.length) {
                        // 确保位置在0-100%范围内
                        const position = Math.max(0, Math.min(100, (timeIndex / Math.max(1, cpuChart.data.labels.length - 1)) * 100));
                        
                        const chartWrappers = document.querySelectorAll('.chart-wrapper');
                        chartWrappers.forEach(wrapper => {
                            const marker = document.createElement('div');
                            marker.className = 'chart-tag-marker';
                            marker.style.left = position + '%';
                            marker.title = `${tag.time}: ${tag.note}`;
                            marker.setAttribute('data-tag-id', tag.id);
                            wrapper.appendChild(marker);
                        });
                    }
                });
            }
        }

        function updateTagList() {
            const tagList = document.getElementById('tagList');
            tagList.innerHTML = '';
            
            savedTags.forEach(tag => {
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-item';
                
                // 检查标签是否在当前时间窗口内
                const isVisible = cpuChart && cpuChart.data.labels.includes(tag.time);
                const statusText = isVisible ? '' : ' (已移出时间窗口)';
                const statusStyle = isVisible ? '' : 'opacity: 0.6; font-style: italic;';
                
                tagItem.innerHTML = `
                    <div class="tag-info" style="${statusStyle}">
                        <div class="tag-time">${tag.time}${statusText}</div>
                        <div class="tag-note">${tag.note}</div>
                    </div>
                    <div class="tag-actions">
                        <button onclick="deleteTag(${tag.id})">删除</button>
                    </div>
                `;
                tagList.appendChild(tagItem);
            });
        }

        function deleteTag(tagId) {
            savedTags = savedTags.filter(tag => tag.id !== tagId);
            updateTagList();
            
            // 重新更新所有标签位置
            updateAllTagMarkers();
            
            showStatus('标签已删除', 'info');
        }

        function clearAllTags() {
            if (savedTags.length === 0) return;
            if (confirm('确认清空所有标签？')) {
                savedTags = [];
                updateTagList();
                
                // 重新更新标签（会清空所有）
                updateAllTagMarkers();
                
                showStatus('所有标签已清空', 'info');
            }
        }

        // 保存数据函数（调用新的包含场景的保存功能）
        function saveData() {
            saveDataWithScenes();
        }

        // 导入数据函数
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.data || !Array.isArray(importedData.data)) {
                        showStatus('无效的数据文件格式', 'error');
                        return;
                    }

                    // 停止当前监控
                    if (isMonitoring) {
                        stopMonitoring();
                    }

                    // 清空现有图表
                    clearAllCharts();
                    
                    // 显示图表区域
                    document.getElementById('chartsGrid').style.display = 'grid';
                    document.getElementById('currentValues').style.display = 'grid';
                    document.getElementById('timeControls').style.display = 'block';
                    document.getElementById('sceneControls').style.display = 'block';
                    document.getElementById('tagControls').style.display = 'block';
                    initCharts();
                    enableDoubleClickTags(); // 启用双击标签功能

                    // 恢复设置
                    if (importedData.settings) {
                        if (importedData.settings.isUnlimited) {
                            setUnlimited();
                        } else if (importedData.settings.maxDataPoints) {
                            document.getElementById('timeRange').value = importedData.settings.maxDataPoints;
                            updateTimeRange(importedData.settings.maxDataPoints);
                        }
                    }

                    // 批量添加导入的数据
                    let dataCount = 0;
                    importedData.data.forEach(item => {
                        if (item.type === 'performance') {
                            addDataToChart(cpuChart, item.time, item.cpu);
                            addDataToChart(memoryChart, item.time, item.memory);
                            addDataToChart(threadsChart, item.time, item.threads);
                            
                            // 更新当前值显示
                            document.getElementById('currentCpu').textContent = `${item.cpu}%`;
                            document.getElementById('currentMemory').textContent = `${item.memory.toFixed(1)}MB`;
                            document.getElementById('currentThreads').textContent = item.threads;
                            dataCount++;
                        } else if (item.type === 'fps') {
                            addDataToChart(fpsChart, item.time, item.fps);
                            document.getElementById('currentFps').textContent = `${item.fps}FPS`;
                        }
                    });

                    // 导入场景数据
                    if (importedData.scenes && Array.isArray(importedData.scenes)) {
                        savedScenes = importedData.scenes;
                        updateSceneList();
                    }

                    // 导入标签数据
                    if (importedData.tags && Array.isArray(importedData.tags)) {
                        savedTags = importedData.tags;
                        updateTagList();
                        // 恢复标签标记
                        updateAllTagMarkers();
                    }

                    let statusMessage = `成功导入 ${dataCount} 条性能记录`;
                    if (importedData.scenes && importedData.scenes.length > 0) {
                        statusMessage += `，${importedData.scenes.length} 个场景`;
                    }
                    if (importedData.tags && importedData.tags.length > 0) {
                        statusMessage += `，${importedData.tags.length} 个标签`;
                    }
                    statusMessage += `，来自 ${importedData.timestamp}`;
                    showStatus(statusMessage, 'success');
                    
                } catch (error) {
                    showStatus('文件解析失败: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
            
            // 清空file input
            event.target.value = '';
        }

        function clearAllCharts() {
            if (cpuChart) {
                cpuChart.data.labels = [];
                cpuChart.data.datasets[0].data = [];
                cpuChart.update();
                
                memoryChart.data.labels = [];
                memoryChart.data.datasets[0].data = [];
                memoryChart.update();
                
                fpsChart.data.labels = [];
                fpsChart.data.datasets[0].data = [];
                fpsChart.update();
                
                threadsChart.data.labels = [];
                threadsChart.data.datasets[0].data = [];
                threadsChart.update();
                
                // 清空所有标签标记
                const existingMarkers = document.querySelectorAll('.chart-tag-marker');
                existingMarkers.forEach(marker => marker.remove());
            }
        }

        // 开始监控
        function startMonitoring() {
            const udid = document.getElementById('udid').value.trim();
            const bundleId = document.getElementById('bundleId').value.trim();
            
            showStatus('正在启动监控...', 'info');
            
            // 清空之前的数据
            allPerformanceData = [];
            
            socket.emit('start_monitoring', {
                udid: udid,
                bundle_id: bundleId
            });
            
            isMonitoring = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('saveBtn').disabled = false;
        }

        // 停止监控
        function stopMonitoring() {
            isMonitoring = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            showStatus('监控已停止', 'info');
            // 保持图表显示，不隐藏
        }

        // Socket.IO事件处理
        // 场景管理功能
        function toggleSelection() {
            isSelecting = !isSelecting;
            const btn = document.getElementById('startSelectionBtn');
            const statusEl = document.getElementById('selectionStatus');
            
            if (isSelecting) {
                btn.textContent = '取消选择';
                btn.style.background = '#ff3b30';
                statusEl.textContent = '请在任意图表上拖拽选择时间区域';
                document.body.classList.add('selecting');
                enableChartSelection();
            } else {
                btn.textContent = '开始选择时间区域';
                btn.style.background = '#007aff';
                statusEl.textContent = '';
                document.body.classList.remove('selecting');
                disableChartSelection();
                clearCurrentSelection();
            }
        }

        function enableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('mousedown', onSelectionStart);
                wrapper.addEventListener('mousemove', onSelectionMove);
                wrapper.addEventListener('mouseup', onSelectionEnd);
                wrapper.addEventListener('mouseleave', onSelectionEnd);
            });
        }

        function disableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.removeEventListener('mousedown', onSelectionStart);
                wrapper.removeEventListener('mousemove', onSelectionMove);
                wrapper.removeEventListener('mouseup', onSelectionEnd);
                wrapper.removeEventListener('mouseleave', onSelectionEnd);
            });
        }

        function onSelectionStart(e) {
            if (!isSelecting) return;
            isMouseDown = true;
            const rect = e.currentTarget.getBoundingClientRect();
            selectionStartX = e.clientX - rect.left;
            clearCurrentSelection();
        }

        function onSelectionMove(e) {
            if (!isSelecting || !isMouseDown) return;
            const rect = e.currentTarget.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const width = Math.abs(currentX - selectionStartX);
            const left = Math.min(selectionStartX, currentX);
            
            // 同步显示选择区域到所有图表
            updateAllSelectionOverlays(left, width);
        }

        function onSelectionEnd(e) {
            if (!isSelecting || !isMouseDown) return;
            isMouseDown = false;
            
            const rect = e.currentTarget.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // 计算时间索引
            const startIndex = Math.floor((Math.min(selectionStartX, endX) / chartWidth) * maxDataPoints);
            const endIndex = Math.floor((Math.max(selectionStartX, endX) / chartWidth) * maxDataPoints);
            
            if (Math.abs(endX - selectionStartX) > 10) { // 最小选择宽度
                // 获取时间标签
                const timeLabels = cpuChart.data.labels;
                selectionStart = timeLabels[Math.max(0, startIndex)] || '';
                selectionEnd = timeLabels[Math.min(timeLabels.length - 1, endIndex)] || '';
                
                if (selectionStart && selectionEnd) {
                    document.getElementById('saveSceneBtn').disabled = false;
                    document.getElementById('selectionStatus').textContent = 
                        `已选择时间段: ${selectionStart} - ${selectionEnd}`;
                }
            }
        }

        function updateAllSelectionOverlays(left, width) {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                const overlay = document.getElementById(overlayId);
                overlay.style.display = 'block';
                overlay.style.left = left + 'px';
                overlay.style.width = width + 'px';
                overlay.style.top = '0px';
                overlay.style.height = '100%';
            });
        }

        function clearCurrentSelection() {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                document.getElementById(overlayId).style.display = 'none';
            });
            selectionStart = null;
            selectionEnd = null;
            document.getElementById('saveSceneBtn').disabled = true;
        }

        function saveScene() {
            const sceneName = document.getElementById('sceneNameInput').value.trim();
            if (!sceneName) {
                showStatus('请输入场景名称', 'error');
                return;
            }
            
            if (!selectionStart || !selectionEnd) {
                showStatus('请先选择时间区域', 'error');
                return;
            }

            // 获取选择时间段内的性能数据
            const sceneData = allPerformanceData.filter(item => {
                return item.time >= selectionStart && item.time <= selectionEnd;
            });

            const scene = {
                id: Date.now(),
                name: sceneName,
                startTime: selectionStart,
                endTime: selectionEnd,
                data: sceneData,
                createdAt: new Date().toISOString(),
                summary: generateSceneSummary(sceneData)
            };

            savedScenes.push(scene);
            updateSceneList();
            
            // 在所有图表上添加永久标记
            addSceneMarkersToAllCharts(scene);
            
            // 清空输入和选择
            document.getElementById('sceneNameInput').value = '';
            clearCurrentSelection();
            toggleSelection(); // 退出选择模式
            
            showStatus(`场景 "${sceneName}" 已保存`, 'success');
        }

        function generateSceneSummary(sceneData) {
            const perfData = sceneData.filter(item => item.type === 'performance');
            const fpsData = sceneData.filter(item => item.type === 'fps');
            
            if (perfData.length === 0) return {};
            
            const cpuValues = perfData.map(item => item.cpu);
            const memoryValues = perfData.map(item => item.memory);
            const fpsValues = fpsData.map(item => item.fps);
            
            return {
                duration: perfData.length,
                avgCpu: (cpuValues.reduce((a, b) => a + b, 0) / cpuValues.length).toFixed(2),
                maxCpu: Math.max(...cpuValues).toFixed(2),
                avgMemory: (memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length).toFixed(1),
                maxMemory: Math.max(...memoryValues).toFixed(1),
                avgFps: fpsValues.length > 0 ? (fpsValues.reduce((a, b) => a + b, 0) / fpsValues.length).toFixed(1) : 0,
                minFps: fpsValues.length > 0 ? Math.min(...fpsValues) : 0
            };
        }

        function addSceneMarkersToAllCharts(scene) {
            // 这里添加永久的场景标记到所有图表
            // Chart.js插件可以实现，但为了简化，我们先在场景列表中显示
        }

        function updateSceneList() {
            const sceneList = document.getElementById('sceneList');
            sceneList.innerHTML = '';
            
            savedScenes.forEach(scene => {
                const sceneItem = document.createElement('div');
                sceneItem.className = 'scene-item';
                sceneItem.innerHTML = `
                    <div class="scene-info">
                        <div><strong>${scene.name}</strong></div>
                        <div class="scene-time">${scene.startTime} - ${scene.endTime}</div>
                        <div style="font-size: 11px; color: #86868b;">
                            平均CPU: ${scene.summary.avgCpu}% | 平均内存: ${scene.summary.avgMemory}MB | 平均FPS: ${scene.summary.avgFps}
                        </div>
                    </div>
                    <div class="scene-actions">
                        <button onclick="deleteScene(${scene.id})">删除</button>
                    </div>
                `;
                sceneList.appendChild(sceneItem);
            });
        }

        function deleteScene(sceneId) {
            savedScenes = savedScenes.filter(scene => scene.id !== sceneId);
            updateSceneList();
            showStatus('场景已删除', 'info');
        }

        function clearAllScenes() {
            if (savedScenes.length === 0) return;
            if (confirm('确认清空所有场景标记？')) {
                savedScenes = [];
                updateSceneList();
                showStatus('所有场景已清空', 'info');
            }
        }

        // 修改保存数据函数，包含场景和标签信息
        function saveDataWithScenes() {
            if (allTimeLabels.length === 0 && savedScenes.length === 0 && savedTags.length === 0) {
                showStatus('没有数据、场景或标签可保存', 'error');
                return;
            }

            // 重新构建性能数据数组
            const performanceData = [];
            for (let i = 0; i < allTimeLabels.length; i++) {
                performanceData.push({
                    timestamp: allTimeLabels[i],
                    cpu: allCpuData[i] || 0,
                    memory: allMemoryData[i] || 0,
                    fps: allFpsData[i] || 0,
                    threads: allThreadsData[i] || 0
                });
            }

            const now = new Date();
            const filename = `ios_performance_complete_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}.json`;
            
            const dataToSave = {
                timestamp: now.toISOString(),
                device_udid: document.getElementById('udid').value.trim(),
                bundle_id: document.getElementById('bundleId').value.trim(),
                data: performanceData,
                scenes: savedScenes, // 包含场景信息
                tags: savedTags, // 包含标签信息
                settings: {
                    windowSize: windowSize,
                    timePosition: timePosition
                },
                summary: {
                    total_records: performanceData.length,
                    total_scenes: savedScenes.length,
                    total_tags: savedTags.length,
                    duration_seconds: performanceData.length > 0 ? 
                        Math.round((new Date(performanceData[performanceData.length-1].timestamp) - new Date(performanceData[0].timestamp)) / 1000) : 0
                }
            };

            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`数据和场景已保存到 ${filename}`, 'success');
        }

        socket.on('monitoring_started', function(data) {
            if (data.status === 'success') {
                showStatus('监控已启动，正在收集数据...', 'success');
                document.getElementById('chartsGrid').style.display = 'grid';
                document.getElementById('currentValues').style.display = 'grid';
                document.getElementById('timeControls').style.display = 'block';
                document.getElementById('sceneControls').style.display = 'block';
                document.getElementById('tagControls').style.display = 'block';
                initCharts();
                enableDoubleClickTags(); // 启用双击标签功能
            }
        });

        socket.on('performance_data', function(data) {
            if (!isMonitoring) return;
            
            // 保存到allPerformanceData用于导出
            allPerformanceData.push({
                type: 'performance',
                timestamp: new Date().toISOString(),
                time: data.time,
                cpu: data.cpu,
                memory: data.memory,
                threads: data.threads,
                pid: data.pid,
                name: data.name
            });
            
            // 更新当前值显示
            document.getElementById('currentCpu').textContent = `${data.cpu}%`;
            document.getElementById('currentMemory').textContent = `${data.memory.toFixed(1)}MB`;
            document.getElementById('currentThreads').textContent = data.threads;
            
            // 添加数据到图表
            addDataToChart(cpuChart, data.time, data.cpu);
            addDataToChart(memoryChart, data.time, data.memory);
            addDataToChart(threadsChart, data.time, data.threads);
        });

        socket.on('fps_data', function(data) {
            if (!isMonitoring) return;
            
            // 保存到allPerformanceData用于导出
            allPerformanceData.push({
                type: 'fps',
                timestamp: new Date().toISOString(),
                time: data.time,
                fps: data.fps
            });
            
            // 更新当前FPS显示
            document.getElementById('currentFps').textContent = `${data.fps}FPS`;
            
            // 添加FPS数据到图表
            addDataToChart(fpsChart, data.time, data.fps);
        });

        socket.on('connect', function() {
            console.log('已连接到服务器');
        });

        socket.on('disconnect', function() {
            console.log('与服务器断开连接');
            if (isMonitoring) {
                showStatus('与服务器连接断开', 'error');
            }
        });

        // 页面加载完成后的初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('iOS性能监控可视化界面已加载');
        });
    </script>
</body>
</html>
