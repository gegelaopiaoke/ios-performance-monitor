<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f7;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #1d1d1f;
            margin-bottom: 10px;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        .controls h3 {
            margin-top: 0;
            color: #1d1d1f;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #424245;
        }
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        .form-group input:focus {
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }
        .btn {
            background: #007aff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .btn:hover {
            background: #0056cc;
        }
        .btn:disabled {
            background: #d2d2d7;
            cursor: not-allowed;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .chart-container h3 {
            margin: 0 0 20px 0;
            color: #1d1d1f;
            font-size: 18px;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .current-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .value-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .value-card .label {
            font-size: 12px;
            color: #86868b;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        .value-card .value {
            font-size: 24px;
            font-weight: 600;
            color: #1d1d1f;
        }
        .hidden {
            display: none;
        }
        .scene-controls {
            background: #f0f8ff;
            border: 1px solid #007aff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .scene-controls h4 {
            margin: 0 0 10px 0;
            color: #007aff;
        }
        .scene-list {
            margin-top: 15px;
        }
        .scene-item {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: between;
            align-items: center;
            font-size: 14px;
        }
        .scene-item .scene-info {
            flex: 1;
        }
        .scene-item .scene-time {
            color: #86868b;
            font-size: 12px;
        }
        .scene-item .scene-actions {
            margin-left: 10px;
        }
        .scene-item button {
            background: #ff3b30;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        .chart-selection-overlay {
            position: absolute;
            background: rgba(0, 122, 255, 0.2);
            border: 2px solid #007aff;
            pointer-events: none;
            display: none;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
            cursor: crosshair;
        }
        .selecting .chart-wrapper {
            cursor: crosshair;
        }
        .tag-controls {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .tag-controls h4 {
            margin: 0 0 10px 0;
            color: #856404;
        }
        .tag-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }
        .tag-item .tag-info {
            flex: 1;
        }
        .tag-item .tag-time {
            color: #6c757d;
            font-size: 12px;
        }
        .tag-item .tag-note {
            color: #495057;
            font-style: italic;
            margin-top: 3px;
        }
        .tag-item .tag-actions {
            margin-left: 10px;
        }
        .tag-item button {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        .chart-tag-marker {
            position: absolute;
            width: 2px;
            background: #ffc107;
            top: 0;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .chart-tag-marker::after {
            content: 'ğŸ·ï¸';
            position: absolute;
            top: -5px;
            left: -8px;
            font-size: 16px;
        }
        
        /* æ€§èƒ½é˜ˆå€¼å’Œå‘Šè­¦æ ·å¼ */
        .alert-panel {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .alert-item {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 6px;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .alert-item.warning {
            background: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }
        .alert-item.critical {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
            animation: pulse 2s infinite;
        }
        
        /* æ€§èƒ½è¯„åˆ†æ ·å¼ */
        .score-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .score-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .score-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }
        .score-value {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .score-value.grade-a { color: #28a745; }
        .score-value.grade-b { color: #17a2b8; }
        .score-value.grade-c { color: #ffc107; }
        .score-value.grade-d { color: #fd7e14; }
        .score-value.grade-f { color: #dc3545; }
        .score-number {
            font-size: 12px;
            color: #888;
        }
        
        /* ç»Ÿè®¡é¢æ¿æ ·å¼ */
        .stat-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        .stat-current {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 8px;
        }
        .stat-details {
            font-size: 11px;
            color: #888;
            line-height: 1.4;
        }
        
        /* å†…å­˜æ³„æ¼æ£€æµ‹æ ·å¼ */
        .leak-warning {
            background: #f8d7da;
            border: 2px solid #dc3545;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }
        .leak-warning.active {
            display: block;
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        /* æ‹–æ‹½åŠŸèƒ½æ ·å¼ */
        .controls {
            position: relative;
            cursor: move;
            transition: transform 0.2s ease;
        }
        
        .controls:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        
        .controls.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        .controls h3 {
            user-select: none;
            position: relative;
        }
        
        .controls h3::before {
            content: 'â‹®â‹®';
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
            font-size: 14px;
            line-height: 1;
        }
        
        .controls:hover h3::before {
            color: #666;
        }
        
        .drag-placeholder {
            height: 100px;
            background: linear-gradient(90deg, #e3f2fd, #f5f5f5);
            border: 2px dashed #2196f3;
            border-radius: 12px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #2196f3;
            font-weight: bold;
            opacity: 0.7;
        }
        
        .drag-placeholder::before {
            content: 'é‡Šæ”¾åˆ°è¿™é‡Œ';
        }
        
        /* é‡ç½®æŒ‰é’®æ ·å¼ */
        .header .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .header .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .header small {
            opacity: 0.8;
            font-style: italic;
        }
        
        /* åˆ†äº«å¯¹è¯æ¡†æ ·å¼ */
        .share-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .share-dialog-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }
        
        .share-url {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
            position: relative;
        }
        
        .copy-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
            transition: background 0.3s ease;
        }
        
        .copy-btn:hover {
            background: #218838;
        }
        
        .copy-btn.copied {
            background: #17a2b8;
        }
        
        .close-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
        }
        
        .close-btn:hover {
            background: #5a6268;
        }
        
        .share-tips {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .share-tips h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        
        .share-tips ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .share-tips li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“± iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–</h1>
            <p>åŸºäºåŸå§‹main.pyé€»è¾‘çš„å®æ—¶æ€§èƒ½å›¾è¡¨æ˜¾ç¤º</p>
            <div style="margin-top: 15px;">
                <button class="btn" onclick="resetPanelOrder()" title="æ¢å¤é¢æ¿é»˜è®¤é¡ºåº">ğŸ”„ é‡ç½®é¢æ¿é¡ºåº</button>
                <button class="btn" onclick="showShareDialog()" title="è·å–åˆ†äº«é“¾æ¥">ğŸ”— åˆ†äº«æ•°æ®</button>
                <small style="margin-left: 10px; color: #666;">ğŸ’¡ æç¤º: ç‚¹å‡»é¢æ¿æ ‡é¢˜å·¦ä¾§çš„ â‹®â‹® å›¾æ ‡å¯æ‹–æ‹½è°ƒæ•´é¡ºåº</small>
            </div>
        </div>

        <div class="controls">
            <h3>ğŸ”§ ç›‘æ§é…ç½®</h3>
            <div class="form-group">
                <label for="udid">è®¾å¤‡UDIDï¼ˆå¯é€‰ï¼‰:</label>
                <input type="text" id="udid" value="00008020-000A09960121002E" placeholder="ç•™ç©ºä½¿ç”¨é»˜è®¤è®¾å¤‡">
            </div>
            <div class="form-group">
                <label for="bundleId">åº”ç”¨Bundle ID:</label>
                <input type="text" id="bundleId" value="com.newleaf.app.ios.vic" placeholder="é»˜è®¤åº”ç”¨">
            </div>
            <button class="btn" id="startBtn" onclick="startMonitoring()">å¼€å§‹ç›‘æ§</button>
            <button class="btn" id="stopBtn" onclick="stopMonitoring()" disabled>åœæ­¢ç›‘æ§</button>
            <button class="btn" id="saveBtn" onclick="saveData()" disabled>ä¿å­˜æ•°æ®</button>
            <button class="btn" id="importBtn" onclick="document.getElementById('fileInput').click()">å¯¼å…¥æ•°æ®</button>
            <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="importData(event)">
        </div>

        <div id="status" class="status hidden"></div>

        <!-- æ—¶é—´èŒƒå›´æ§åˆ¶ -->
        <div class="controls" id="timeControls" style="display: none;">
            <h3>â° æ—¶é—´èŒƒå›´æ§åˆ¶</h3>
            <div style="display: flex; gap: 15px; align-items: center;">
                <div style="flex: 1;">
                    <label for="windowSize">æ˜¾ç¤ºçª—å£å¤§å°:</label>
                    <input type="number" id="windowSize" min="10" max="500" value="50" step="10" oninput="updateWindowSize(this.value)" style="width: 80px; padding: 4px;">
                    <span id="windowSizeValue">50ä¸ªç‚¹</span>
                </div>
                <div style="flex: 2;">
                    <label for="timeSlider">æ—¶é—´è½´æ‹–åŠ¨:</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="timeSlider" min="0" max="100" value="100" oninput="updateTimePosition(this.value)" style="flex: 1;">
                        <span id="timePosition">æœ€æ–°</span>
                        <button onclick="goToLatest()" style="padding: 4px 8px; background: #007aff; color: white; border: none; border-radius: 4px; font-size: 12px;">è·³åˆ°æœ€æ–°</button>
                    </div>
                </div>
                <div class="form-group" style="flex: 1; margin-bottom: 0;">
                    <label for="updateInterval">æ›´æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰:</label>
                    <input type="range" id="updateInterval" min="500" max="5000" value="1000" oninput="updateInterval(this.value)">
                    <span id="intervalValue">1000ms</span>
                </div>
            </div>
        </div>

        <!-- åœºæ™¯æ ‡è®°æ§åˆ¶ -->
        <div class="scene-controls" id="sceneControls" style="display: none;">
            <h4>ğŸ¬ åœºæ™¯æ ‡è®°</h4>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <button class="btn" id="startSelectionBtn" onclick="toggleSelection()">å¼€å§‹é€‰æ‹©æ—¶é—´åŒºåŸŸ</button>
                <input type="text" id="sceneNameInput" placeholder="åœºæ™¯åç§°" style="padding: 8px; border: 1px solid #d2d2d7; border-radius: 6px; width: 200px;">
                <button class="btn" id="saveSceneBtn" onclick="saveScene()" disabled>ä¿å­˜åœºæ™¯</button>
                <button class="btn" id="clearScenesBtn" onclick="clearAllScenes()">æ¸…ç©ºæ‰€æœ‰åœºæ™¯</button>
            </div>
            <div id="selectionStatus" style="font-size: 14px; color: #86868b; margin-bottom: 10px;"></div>
            <div class="scene-list" id="sceneList"></div>
        </div>

        <!-- å•ç‚¹æ ‡ç­¾æ§åˆ¶ -->
        <div class="tag-controls" id="tagControls" style="display: none;">
            <h4>ğŸ·ï¸ å•ç‚¹æ ‡ç­¾</h4>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <span style="font-size: 14px; color: #856404;">åŒå‡»å›¾è¡¨ä»»æ„ä½ç½®æ·»åŠ æ ‡ç­¾</span>
                <button class="btn" id="clearTagsBtn" onclick="clearAllTags()">æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾</button>
            </div>
            <div class="scene-list" id="tagList"></div>
        </div>

        <!-- æµ‹è¯•åœºæ™¯è‡ªåŠ¨åŒ–æ§åˆ¶ -->
        <div class="controls" id="scenarioControls" style="display: none;">
            <h3>ğŸ§ª æµ‹è¯•åœºæ™¯è‡ªåŠ¨åŒ–</h3>
            <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 15px; border-radius: 6px;">
                <div style="font-size: 14px; color: #1976d2; margin-bottom: 8px;">
                    <strong>ğŸ’¡ æ™ºèƒ½æµ‹è¯•åŠ©æ‰‹</strong>
                </div>
                <div style="font-size: 13px; color: #424242; line-height: 1.4;">
                    åœ¨æ€§èƒ½ç›‘æ§è¿è¡Œæ—¶ï¼Œå¯ä»¥å¯åŠ¨è‡ªåŠ¨åŒ–æµ‹è¯•åœºæ™¯ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨æ‰§è¡Œæµ‹è¯•æ“ä½œå¹¶åœ¨å›¾è¡¨ä¸Šæ ‡è®°å…³é”®æ—¶é—´ç‚¹
                </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label style="display: block; margin-bottom: 5px; font-weight: 500;">æµ‹è¯•åœºæ™¯ç±»å‹:</label>
                    <select id="scenarioType" style="width: 100%; padding: 8px; border: 1px solid #d2d2d7; border-radius: 6px;">
                        <option value="app_launch">åº”ç”¨å¯åŠ¨æµ‹è¯•</option>
                        <option value="memory_stress">å†…å­˜å‹åŠ›æµ‹è¯•</option>
                        <option value="ui_interaction">ç•Œé¢äº¤äº’æµ‹è¯•</option>
                        <option value="background_switch">åå°åˆ‡æ¢æµ‹è¯•</option>
                    </select>
                </div>
                <div style="display: flex; align-items: end; gap: 10px;">
                    <button class="btn" id="startScenarioBtn" onclick="startTestScenario()" disabled>ğŸš€ å¼€å§‹æµ‹è¯•</button>
                    <button class="btn" id="stopScenarioBtn" onclick="stopTestScenario()" disabled style="background: #dc3545;">â¹ï¸ åœæ­¢æµ‹è¯•</button>
                </div>
            </div>
            
            <!-- æµ‹è¯•çŠ¶æ€å’Œè¿›åº¦æ˜¾ç¤º -->
            <div id="scenarioStatus" style="display: none; background: #f8f9fa; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span id="scenarioStatusIcon">ğŸ”„</span>
                    <span id="scenarioStatusText">å‡†å¤‡ä¸­...</span>
                </div>
                <div style="background: #e9ecef; border-radius: 3px; height: 6px; overflow: hidden;">
                    <div id="scenarioProgress" style="background: #28a745; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>
            </div>
            
            <!-- æµ‹è¯•ç»“æœå’Œæ—¥å¿— -->
            <div id="scenarioResults" style="display: none;">
                <h4 style="margin: 15px 0 10px 0; color: #1d1d1f;">ğŸ“‹ æµ‹è¯•æ—¥å¿—</h4>
                <div id="scenarioLog" style="background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 10px; max-height: 200px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.4;"></div>
            </div>
        </div>

        <div class="current-values" id="currentValues" style="display: none;">
            <div class="value-card">
                <div class="label">CPUä½¿ç”¨ç‡</div>
                <div class="value" id="currentCpu">0%</div>
            </div>
            <div class="value-card">
                <div class="label">å†…å­˜ä½¿ç”¨</div>
                <div class="value" id="currentMemory">0MB</div>
            </div>
            <div class="value-card">
                <div class="label">å¸§ç‡</div>
                <div class="value" id="currentFps">0FPS</div>
            </div>
            <div class="value-card">
                <div class="label">çº¿ç¨‹æ•°</div>
                <div class="value" id="currentThreads">0</div>
            </div>
        </div>

        <div class="charts-grid" id="chartsGrid" style="display: none;">
            <div class="chart-container">
                <h3>ğŸ“Š CPUä½¿ç”¨ç‡</h3>
                <div class="chart-wrapper" data-chart="cpu">
                    <canvas id="cpuChart"></canvas>
                    <div class="chart-selection-overlay" id="cpuOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ’¾ å†…å­˜ä½¿ç”¨é‡</h3>
                <div class="chart-wrapper" data-chart="memory">
                    <canvas id="memoryChart"></canvas>
                    <div class="chart-selection-overlay" id="memoryOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ® å¸§ç‡(FPS)</h3>
                <div class="chart-wrapper" data-chart="fps">
                    <canvas id="fpsChart"></canvas>
                    <div class="chart-selection-overlay" id="fpsOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>ğŸ§µ çº¿ç¨‹æ•°é‡</h3>
                <div class="chart-wrapper" data-chart="threads">
                    <canvas id="threadsChart"></canvas>
                    <div class="chart-selection-overlay" id="threadsOverlay"></div>
                </div>
            </div>
        </div>

        <!-- æ€§èƒ½é˜ˆå€¼æ§åˆ¶é¢æ¿ -->
        <div class="controls" id="thresholdControls">
            <h3>ğŸš¨ æ€§èƒ½é˜ˆå€¼å‘Šè­¦</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div>
                    <label>CPUé˜ˆå€¼ (%):</label>
                    <input type="number" id="cpuThreshold" value="80" min="0" max="100">
                </div>
                <div>
                    <label>å†…å­˜é˜ˆå€¼ (MB):</label>
                    <input type="number" id="memoryThreshold" value="200" min="0">
                </div>
                <div>
                    <label>FPSæœ€ä½å€¼:</label>
                    <input type="number" id="fpsThreshold" value="30" min="0" max="60">
                </div>
                <div>
                    <label>çº¿ç¨‹æ•°ä¸Šé™:</label>
                    <input type="number" id="threadsThreshold" value="50" min="0">
                </div>
            </div>
            <div id="alertPanel" class="alert-panel" style="display: none;">
                <h4>âš ï¸ æ€§èƒ½å‘Šè­¦</h4>
                <div id="alertList"></div>
            </div>
        </div>

        <!-- æ€§èƒ½è¯„åˆ†é¢æ¿ -->
        <div class="controls" id="scoringPanel">
            <h3>ğŸ“Š å®æ—¶æ€§èƒ½è¯„åˆ†</h3>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                <div class="score-item">
                    <div class="score-label">CPUè¯„åˆ†</div>
                    <div class="score-value" id="cpuScore">A+</div>
                    <div class="score-number" id="cpuScoreNum">(95)</div>
                </div>
                <div class="score-item">
                    <div class="score-label">å†…å­˜è¯„åˆ†</div>
                    <div class="score-value" id="memoryScore">A+</div>
                    <div class="score-number" id="memoryScoreNum">(95)</div>
                </div>
                <div class="score-item">
                    <div class="score-label">FPSè¯„åˆ†</div>
                    <div class="score-value" id="fpsScore">A+</div>
                    <div class="score-number" id="fpsScoreNum">(95)</div>
                </div>
                <div class="score-item">
                    <div class="score-label">æ€»ä½“è¯„åˆ†</div>
                    <div class="score-value" id="overallScore">A+</div>
                    <div class="score-number" id="overallScoreNum">(95)</div>
                </div>
            </div>
        </div>

        <!-- å†…å­˜æ³„æ¼æ£€æµ‹é¢æ¿ -->
        <div class="controls" id="memoryLeakPanel">
            <h3>ğŸ§  å†…å­˜æ³„æ¼æ£€æµ‹</h3>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div class="stat-card">
                    <div class="stat-label">æ£€æµ‹çŠ¶æ€</div>
                    <div class="stat-value" id="leakStatus">æ­£å¸¸</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">å†…å­˜è¶‹åŠ¿</div>
                    <div class="stat-value" id="memoryTrend">ç¨³å®š</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">å¢é•¿ç‡</div>
                    <div class="stat-value" id="leakRate">0 MB/min</div>
                </div>
            </div>
            <div class="leak-warning" id="leakWarning" style="display: none;">
                <h4>âš ï¸ ç–‘ä¼¼å†…å­˜æ³„æ¼</h4>
                <div id="leakDetails"></div>
            </div>
        </div>

        <!-- æ•°æ®ç»Ÿè®¡é¢æ¿ -->
        <div class="controls" id="statisticsPanel">
            <h3>ğŸ“ˆ æ•°æ®ç»Ÿè®¡</h3>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                <div class="stat-card">
                    <div class="stat-label">CPUä½¿ç”¨ç‡</div>
                    <div class="stat-current" id="statCpuCurrent">0%</div>
                    <div class="stat-details">
                        å¹³å‡: <span id="statCpuAvg">0%</span> | 
                        æœ€å¤§: <span id="statCpuMax">0%</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">å†…å­˜ä½¿ç”¨</div>
                    <div class="stat-current" id="statMemoryCurrent">0MB</div>
                    <div class="stat-details">
                        å¹³å‡: <span id="statMemoryAvg">0MB</span> | 
                        æœ€å¤§: <span id="statMemoryMax">0MB</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">å¸§ç‡</div>
                    <div class="stat-current" id="statFpsCurrent">0FPS</div>
                    <div class="stat-details">
                        å¹³å‡: <span id="statFpsAvg">0FPS</span> | 
                        æœ€ä½: <span id="statFpsMin">0FPS</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">çº¿ç¨‹æ•°</div>
                    <div class="stat-current" id="statThreadsCurrent">0</div>
                    <div class="stat-details">
                        å¹³å‡: <span id="statThreadsAvg">0</span> | 
                        æœ€å¤§: <span id="statThreadsMax">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- åˆ†äº«å¯¹è¯æ¡† -->
    <div id="shareDialog" class="share-dialog">
        <div class="share-dialog-content">
            <h3>ğŸ”— åˆ†äº«å®æ—¶æ•°æ®</h3>
            <p>å°†ä»¥ä¸‹é“¾æ¥åˆ†äº«ç»™å…¶ä»–äººï¼Œä»–ä»¬å¯ä»¥å®æ—¶æŸ¥çœ‹ä½ çš„æ€§èƒ½ç›‘æ§æ•°æ®ï¼š</p>
            
            <div class="share-url" id="shareUrl">
                æ­£åœ¨è·å–åˆ†äº«é“¾æ¥...
            </div>
            
            <div>
                <button class="copy-btn" onclick="copyShareUrl()">ğŸ“‹ å¤åˆ¶é“¾æ¥</button>
                <button class="close-btn" onclick="closeShareDialog()">å…³é—­</button>
            </div>
            
            <div class="share-tips">
                <h4>ğŸ’¡ ä½¿ç”¨è¯´æ˜ï¼š</h4>
                <ul>
                    <li>ç¡®ä¿åˆ†äº«å¯¹è±¡ä¸ä½ åœ¨åŒä¸€ç½‘ç»œç¯å¢ƒä¸­ï¼ˆå¦‚åŒä¸€WiFiï¼‰</li>
                    <li>å¦‚æœæ— æ³•è®¿é—®ï¼Œå¯èƒ½éœ€è¦å…³é—­é˜²ç«å¢™æˆ–å…è®¸ç«¯å£5001</li>
                    <li>åˆ†äº«çš„æ˜¯å®æ—¶æ•°æ®ï¼Œä»–ä»¬èƒ½çœ‹åˆ°ä½ å½“å‰çš„æ€§èƒ½ç›‘æ§çŠ¶æ€</li>
                    <li>åœæ­¢ç›‘æ§åï¼Œåˆ†äº«çš„é¡µé¢ä¹Ÿä¼šåœæ­¢æ›´æ–°</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // WebSocketè¿æ¥
        const socket = io();
        
        // å›¾è¡¨å®ä¾‹
        let cpuChart, memoryChart, fpsChart, threadsChart;
        
        // æ•°æ®å­˜å‚¨
        let isMonitoring = false;
        let windowSize = 50; // æ˜¾ç¤ºçª—å£å¤§å°
        let timePosition = 100; // æ—¶é—´ä½ç½®ç™¾åˆ†æ¯”ï¼Œ100è¡¨ç¤ºæœ€æ–°
        let allPerformanceData = []; // å­˜å‚¨æ‰€æœ‰æ€§èƒ½æ•°æ®ç”¨äºä¿å­˜
        
        // æ€§èƒ½é˜ˆå€¼é…ç½®
        let thresholds = {
            cpu: 80,
            memory: 200,
            fps: 30,
            threads: 50
        };
        
        // æ€§èƒ½ç»Ÿè®¡æ•°æ®
        let performanceStats = {
            cpu: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
            memory: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
            fps: { current: 0, avg: 0, min: Infinity, sum: 0, count: 0 },
            threads: { current: 0, avg: 0, max: 0, sum: 0, count: 0 }
        };
        
        // ä¸“ä¸šçº§å†…å­˜æ³„æ¼æ£€æµ‹ç³»ç»Ÿ
        let professionalMemoryLeakDetection = {
            // åœºæ™¯çŠ¶æ€æœº
            sceneStateMachine: {
                currentScene: 'unknown',
                previousScene: 'unknown',
                sceneHistory: [],
                sceneStartTime: null,
                sceneStartMemory: 0,
                sceneTransitionCount: 0
            },
            
            // åœºæ™¯å®šä¹‰å’ŒåŸºçº¿
            sceneProfiles: {
                'idle': { 
                    name: 'ç©ºé—²çŠ¶æ€', 
                    expectedMemory: { min: 80, max: 150 }, 
                    color: '#4CAF50',
                    priority: 1 
                },
                'launching': { 
                    name: 'åº”ç”¨å¯åŠ¨', 
                    expectedMemory: { min: 120, max: 200 }, 
                    color: '#FF9800',
                    priority: 3 
                },
                'video_playing': { 
                    name: 'è§†é¢‘æ’­æ”¾', 
                    expectedMemory: { min: 200, max: 400 }, 
                    color: '#F44336',
                    priority: 4 
                },
                'navigation': { 
                    name: 'ç•Œé¢å¯¼èˆª', 
                    expectedMemory: { min: 100, max: 180 }, 
                    color: '#2196F3',
                    priority: 2 
                },
                'background': { 
                    name: 'åå°è¿è¡Œ', 
                    expectedMemory: { min: 60, max: 120 }, 
                    color: '#9C27B0',
                    priority: 1 
                }
            },
            
            // å†…å­˜å†å²æ•°æ®
            memoryHistory: [],
            maxHistoryLength: 200,
            
            // æ£€æµ‹å‚æ•°
            detection: {
                minSampleSize: 15,              // æœ€å°æ ·æœ¬æ•°é‡
                sceneMinDuration: 10000,        // åœºæ™¯æœ€å°æŒç»­æ—¶é—´ (10ç§’)
                leakThreshold: 0.85,            // å†…å­˜å›æ”¶ç‡é˜ˆå€¼ (85%)
                anomalyThreshold: 2.5,          // å¼‚å¸¸æ£€æµ‹æ ‡å‡†å·®å€æ•°
                trendAnalysisWindow: 30,        // è¶‹åŠ¿åˆ†æçª—å£å¤§å°
                gcDetectionThreshold: 15        // GCæ£€æµ‹é˜ˆå€¼ (MB)
            },
            
            // æ£€æµ‹çŠ¶æ€
            status: {
                isLeaking: false,
                leakLevel: 'none',              // none, mild, moderate, severe
                leakSources: [],
                lastGCTime: null,
                gcFrequency: 0,
                suspiciousTransitions: []
            },
            
            // ç»Ÿè®¡æ•°æ®
            statistics: {
                totalLeaksDetected: 0,
                falsePositiveRate: 0,
                averageRecoveryRate: 0,
                sceneTransitionMatrix: {}
            }
        };
        
        // å…¼å®¹æ—§ç³»ç»Ÿ
        let memoryLeakDetection = {
            memoryHistory: [],
            leakThreshold: 2,
            detectionWindow: 300000,
            isLeaking: false
        };
        
        // æ´»è·ƒå‘Šè­¦åˆ—è¡¨
        let activeAlerts = [];
        let allTimeLabels = []; // å­˜å‚¨æ‰€æœ‰æ—¶é—´æ ‡ç­¾
        let allCpuData = []; // å­˜å‚¨æ‰€æœ‰CPUæ•°æ®
        let allMemoryData = []; // å­˜å‚¨æ‰€æœ‰å†…å­˜æ•°æ®
        let allFpsData = []; // å­˜å‚¨æ‰€æœ‰FPSæ•°æ®
        let allThreadsData = []; // å­˜å‚¨æ‰€æœ‰çº¿ç¨‹æ•°æ®
        let currentUpdateInterval = 1000; // å½“å‰æ›´æ–°é—´éš”
        let isFollowingLatest = true; // æ˜¯å¦è·Ÿéšæœ€æ–°æ•°æ®
        
        // åœºæ™¯é€‰æ‹©ç›¸å…³å˜é‡
        let isSelecting = false;
        let selectionStart = null;
        let selectionEnd = null;
        let currentSelection = null;
        let savedScenes = []; // ä¿å­˜çš„åœºæ™¯åˆ—è¡¨
        let isMouseDown = false;
        let selectionStartX = 0;
        
        // æ ‡ç­¾ç›¸å…³å˜é‡
        let savedTags = []; // ä¿å­˜çš„æ ‡ç­¾åˆ—è¡¨
        
        // å›¾è¡¨é…ç½®
        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: 'æ—¶é—´'
                    }
                },
                y: {
                    display: true,
                    beginAtZero: true
                }
            },
            elements: {
                line: {
                    tension: 0.4
                },
                point: {
                    radius: 3
                }
            }
        };

        // åˆå§‹åŒ–å›¾è¡¨
        function initCharts() {
            const cpuCtx = document.getElementById('cpuChart').getContext('2d');
            cpuChart = new Chart(cpuCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'CPUä½¿ç”¨ç‡ (%)',
                        data: [],
                        borderColor: '#ff3b30',
                        backgroundColor: 'rgba(255, 59, 48, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'CPUä½¿ç”¨ç‡ (%)'
                            }
                        }
                    }
                }
            });

            const memoryCtx = document.getElementById('memoryChart').getContext('2d');
            memoryChart = new Chart(memoryCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å†…å­˜ä½¿ç”¨ (MB)',
                        data: [],
                        borderColor: '#007aff',
                        backgroundColor: 'rgba(0, 122, 255, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'å†…å­˜ä½¿ç”¨ (MB)'
                            }
                        }
                    }
                }
            });

            const fpsCtx = document.getElementById('fpsChart').getContext('2d');
            fpsChart = new Chart(fpsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'å¸§ç‡ (FPS)',
                        data: [],
                        borderColor: '#34c759',
                        backgroundColor: 'rgba(52, 199, 89, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'å¸§ç‡ (FPS)'
                            },
                            max: 60
                        }
                    }
                }
            });

            const threadsCtx = document.getElementById('threadsChart').getContext('2d');
            threadsChart = new Chart(threadsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'çº¿ç¨‹æ•°é‡',
                        data: [],
                        borderColor: '#ff9500',
                        backgroundColor: 'rgba(255, 149, 0, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'çº¿ç¨‹æ•°é‡'
                            }
                        }
                    }
                }
            });
        }

        // æ·»åŠ æ•°æ®åˆ°å›¾è¡¨
        function addDataToChart(chart, label, data) {
            // å­˜å‚¨åˆ°å…¨å±€æ•°ç»„
            if (chart === cpuChart) {
                allTimeLabels.push(label);
                allCpuData.push(data);
            } else if (chart === memoryChart) {
                allMemoryData.push(data);
            } else if (chart === fpsChart) {
                allFpsData.push(data);
            } else if (chart === threadsChart) {
                allThreadsData.push(data);
            }
            
            // å¦‚æœæ­£åœ¨è·Ÿéšæœ€æ–°æ•°æ®ï¼Œæ›´æ–°æ˜¾ç¤º
            if (isFollowingLatest) {
                updateChartDisplay();
            }
            
            // æ›´æ–°æ ‡ç­¾ä½ç½®ï¼ˆä»…åœ¨CPUå›¾è¡¨æ›´æ–°æ—¶æ‰§è¡Œï¼Œé¿å…é‡å¤ï¼‰
            if (chart === cpuChart && savedTags.length > 0) {
                updateAllTagMarkers();
                updateTagList(); // æ›´æ–°æ ‡ç­¾åˆ—è¡¨çŠ¶æ€
            }
        }

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.classList.remove('hidden');
        }

        // éšè—çŠ¶æ€æ¶ˆæ¯
        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        // çª—å£å¤§å°å’Œæ—¶é—´ä½ç½®æ§åˆ¶å‡½æ•°
        function updateWindowSize(value) {
            windowSize = parseInt(value);
            document.getElementById('windowSizeValue').textContent = windowSize + 'ä¸ªç‚¹';
            updateChartDisplay();
        }

        function updateTimePosition(value) {
            timePosition = parseInt(value);
            isFollowingLatest = (timePosition === 100);
            
            if (isFollowingLatest) {
                document.getElementById('timePosition').textContent = 'æœ€æ–°';
            } else {
                const totalData = allTimeLabels.length;
                const endIndex = Math.floor((timePosition / 100) * totalData);
                const startIndex = Math.max(0, endIndex - windowSize);
                document.getElementById('timePosition').textContent = `${startIndex}-${endIndex}`;
            }
            
            updateChartDisplay();
        }

        function goToLatest() {
            timePosition = 100;
            isFollowingLatest = true;
            document.getElementById('timeSlider').value = 100;
            document.getElementById('timePosition').textContent = 'æœ€æ–°';
            updateChartDisplay();
        }

        function updateChartDisplay() {
            if (allTimeLabels.length === 0) return;

            let startIndex, endIndex;
            
            if (isFollowingLatest) {
                // è·Ÿéšæœ€æ–°æ•°æ®
                endIndex = allTimeLabels.length;
                startIndex = Math.max(0, endIndex - windowSize);
            } else {
                // æ ¹æ®æ—¶é—´ä½ç½®è®¡ç®—æ˜¾ç¤ºèŒƒå›´
                const totalData = allTimeLabels.length;
                endIndex = Math.floor((timePosition / 100) * totalData);
                startIndex = Math.max(0, endIndex - windowSize);
                endIndex = Math.min(totalData, startIndex + windowSize);
            }

            // æ›´æ–°æ‰€æœ‰å›¾è¡¨çš„æ˜¾ç¤ºæ•°æ®
            updateChartData(cpuChart, allTimeLabels.slice(startIndex, endIndex), allCpuData.slice(startIndex, endIndex));
            updateChartData(memoryChart, allTimeLabels.slice(startIndex, endIndex), allMemoryData.slice(startIndex, endIndex));
            updateChartData(fpsChart, allTimeLabels.slice(startIndex, endIndex), allFpsData.slice(startIndex, endIndex));
            updateChartData(threadsChart, allTimeLabels.slice(startIndex, endIndex), allThreadsData.slice(startIndex, endIndex));

            // æ›´æ–°æ‹–åŠ¨æ¡çš„èŒƒå›´
            if (allTimeLabels.length > windowSize) {
                const maxSliderValue = Math.floor(((allTimeLabels.length - windowSize) / allTimeLabels.length) * 100);
                document.getElementById('timeSlider').max = 100;
                if (!isFollowingLatest && timePosition > maxSliderValue) {
                    timePosition = maxSliderValue;
                    document.getElementById('timeSlider').value = timePosition;
                }
            }
            
            // æ›´æ–°æ ‡ç­¾ä½ç½®
            updateAllTagMarkers();
        }

        function updateChartData(chart, labels, data) {
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update('none');
        }

        function updateInterval(value) {
            currentUpdateInterval = parseInt(value);
            document.getElementById('intervalValue').textContent = value + 'ms';
        }

        // æ ‡ç­¾åŠŸèƒ½
        function enableDoubleClickTags() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('dblclick', onDoubleClickTag);
            });
        }

        function onDoubleClickTag(e) {
            if (isSelecting) return; // é€‰æ‹©æ¨¡å¼ä¸‹ä¸æ·»åŠ æ ‡ç­¾
            
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // è®¡ç®—æ—¶é—´ç´¢å¼•
            const clickIndex = Math.floor((clickX / chartWidth) * (cpuChart.data.labels.length));
            const timeLabel = cpuChart.data.labels[clickIndex];
            
            if (timeLabel) {
                // å¼¹å‡ºè¾“å…¥æ¡†è®©ç”¨æˆ·è¾“å…¥æ ‡ç­¾å†…å®¹
                const tagNote = prompt('è¯·è¾“å…¥æ ‡ç­¾å¤‡æ³¨:', '');
                if (tagNote !== null && tagNote.trim() !== '') {
                    addTag(timeLabel, tagNote.trim(), clickX, chartWidth);
                }
            }
        }

        function addTag(timeLabel, note, clickX, chartWidth) {
            const tag = {
                id: Date.now(),
                time: timeLabel,
                note: note,
                createdAt: new Date().toISOString()
            };

            savedTags.push(tag);
            updateTagList();
            
            // åœ¨æ‰€æœ‰å›¾è¡¨ä¸Šæ·»åŠ æ ‡ç­¾æ ‡è®°
            addTagMarkersToAllCharts(tag);
            
            showStatus(`æ ‡ç­¾ "${note}" å·²æ·»åŠ åˆ° ${timeLabel}`, 'success');
        }

        function addTagMarkersToAllCharts(tag) {
            // ä¸åœ¨è¿™é‡Œç›´æ¥æ·»åŠ DOMå…ƒç´ ï¼Œè€Œæ˜¯åœ¨updateAllTagMarkersä¸­ç»Ÿä¸€å¤„ç†
            updateAllTagMarkers();
        }

        function updateAllTagMarkers() {
            // åˆ é™¤æ‰€æœ‰ç°æœ‰çš„æ ‡è®°
            const existingMarkers = document.querySelectorAll('.chart-tag-marker');
            existingMarkers.forEach(marker => marker.remove());

            // é‡æ–°æ·»åŠ æ‰€æœ‰æ ‡ç­¾æ ‡è®°
            if (cpuChart && cpuChart.data.labels.length > 0) {
                savedTags.forEach(tag => {
                    // æ‰¾åˆ°æ ‡ç­¾æ—¶é—´åœ¨å½“å‰å›¾è¡¨ä¸­çš„ä½ç½®
                    const timeIndex = cpuChart.data.labels.findIndex(label => label === tag.time);
                    if (timeIndex !== -1 && timeIndex >= 0 && timeIndex < cpuChart.data.labels.length) {
                        // ç¡®ä¿ä½ç½®åœ¨0-100%èŒƒå›´å†…
                        const position = Math.max(0, Math.min(100, (timeIndex / Math.max(1, cpuChart.data.labels.length - 1)) * 100));
                        
                        const chartWrappers = document.querySelectorAll('.chart-wrapper');
                        chartWrappers.forEach(wrapper => {
                            const marker = document.createElement('div');
                            marker.className = 'chart-tag-marker';
                            marker.style.left = position + '%';
                            marker.title = `${tag.time}: ${tag.note}`;
                            marker.setAttribute('data-tag-id', tag.id);
                            wrapper.appendChild(marker);
                        });
                    }
                });
            }
        }

        function updateTagList() {
            const tagList = document.getElementById('tagList');
            tagList.innerHTML = '';
            
            savedTags.forEach(tag => {
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-item';
                
                // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦åœ¨å½“å‰æ—¶é—´çª—å£å†…
                const isVisible = cpuChart && cpuChart.data.labels.includes(tag.time);
                const statusText = isVisible ? '' : ' (å·²ç§»å‡ºæ—¶é—´çª—å£)';
                const statusStyle = isVisible ? '' : 'opacity: 0.6; font-style: italic;';
                
                tagItem.innerHTML = `
                    <div class="tag-info" style="${statusStyle}">
                        <div class="tag-time">${tag.time}${statusText}</div>
                        <div class="tag-note">${tag.note}</div>
                    </div>
                    <div class="tag-actions">
                        <button onclick="deleteTag(${tag.id})">åˆ é™¤</button>
                    </div>
                `;
                tagList.appendChild(tagItem);
            });
        }

        function deleteTag(tagId) {
            savedTags = savedTags.filter(tag => tag.id !== tagId);
            updateTagList();
            
            // é‡æ–°æ›´æ–°æ‰€æœ‰æ ‡ç­¾ä½ç½®
            updateAllTagMarkers();
            
            showStatus('æ ‡ç­¾å·²åˆ é™¤', 'info');
        }

        function clearAllTags() {
            if (savedTags.length === 0) return;
            if (confirm('ç¡®è®¤æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾ï¼Ÿ')) {
                savedTags = [];
                updateTagList();
                
                // é‡æ–°æ›´æ–°æ ‡ç­¾ï¼ˆä¼šæ¸…ç©ºæ‰€æœ‰ï¼‰
                updateAllTagMarkers();
                
                showStatus('æ‰€æœ‰æ ‡ç­¾å·²æ¸…ç©º', 'info');
            }
        }

        // ä¿å­˜æ•°æ®å‡½æ•°ï¼ˆè°ƒç”¨æ–°çš„åŒ…å«åœºæ™¯çš„ä¿å­˜åŠŸèƒ½ï¼‰
        function saveData() {
            saveDataWithScenes();
        }

        // å¯¼å…¥æ•°æ®å‡½æ•°
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.data || !Array.isArray(importedData.data)) {
                        showStatus('æ— æ•ˆçš„æ•°æ®æ–‡ä»¶æ ¼å¼', 'error');
                        return;
                    }

                    // åœæ­¢å½“å‰ç›‘æ§
                    if (isMonitoring) {
                        stopMonitoring();
                    }

                    // æ¸…ç©ºç°æœ‰å›¾è¡¨
                    clearAllCharts();
                    
                    // æ˜¾ç¤ºå›¾è¡¨åŒºåŸŸ
                    document.getElementById('chartsGrid').style.display = 'grid';
                    document.getElementById('currentValues').style.display = 'grid';
                    document.getElementById('timeControls').style.display = 'block';
                    document.getElementById('sceneControls').style.display = 'block';
                    document.getElementById('tagControls').style.display = 'block';
                    document.getElementById('scenarioControls').style.display = 'block';
                    initCharts();
                    enableDoubleClickTags(); // å¯ç”¨åŒå‡»æ ‡ç­¾åŠŸèƒ½

                    // æ¢å¤è®¾ç½®
                    if (importedData.settings) {
                        if (importedData.settings.isUnlimited) {
                            setUnlimited();
                        } else if (importedData.settings.maxDataPoints) {
                            document.getElementById('timeRange').value = importedData.settings.maxDataPoints;
                            updateTimeRange(importedData.settings.maxDataPoints);
                        }
                    }

                    // æ‰¹é‡æ·»åŠ å¯¼å…¥çš„æ•°æ®
                    let dataCount = 0;
                    importedData.data.forEach(item => {
                        // å…¼å®¹ä¸åŒçš„æ•°æ®æ ¼å¼
                        const timeValue = item.time || item.timestamp;
                        const hasPerformanceData = item.cpu !== undefined || item.memory !== undefined;
                        
                        if (hasPerformanceData || item.type === 'performance') {
                            // ç¡®ä¿æ•°æ®å®Œæ•´æ€§
                            const cpu = item.cpu || 0;
                            const memory = item.memory || 0;
                            const threads = item.threads || 0;
                            const fps = item.fps || 0;
                            
                            addDataToChart(cpuChart, timeValue, cpu);
                            addDataToChart(memoryChart, timeValue, memory);
                            addDataToChart(threadsChart, timeValue, threads);
                            addDataToChart(fpsChart, timeValue, fps);
                            
                            // æ›´æ–°å½“å‰å€¼æ˜¾ç¤º
                            document.getElementById('currentCpu').textContent = `${cpu}%`;
                            document.getElementById('currentMemory').textContent = `${memory.toFixed(1)}MB`;
                            document.getElementById('currentThreads').textContent = threads;
                            document.getElementById('currentFps').textContent = `${fps}FPS`;
                            
                            // æ›´æ–°æ€§èƒ½ç»Ÿè®¡åˆ†æ
                            updatePerformanceStats(cpu, memory, fps, threads);
                            
                            dataCount++;
                        }
                    });

                    // å¯¼å…¥åœºæ™¯æ•°æ®
                    if (importedData.scenes && Array.isArray(importedData.scenes)) {
                        savedScenes = importedData.scenes;
                        updateSceneList();
                    }

                    // å¯¼å…¥æ ‡ç­¾æ•°æ®
                    if (importedData.tags && Array.isArray(importedData.tags)) {
                        savedTags = importedData.tags;
                        updateTagList();
                        // æ¢å¤æ ‡ç­¾æ ‡è®°
                        updateAllTagMarkers();
                    }

                    let statusMessage = `æˆåŠŸå¯¼å…¥ ${dataCount} æ¡æ€§èƒ½è®°å½•`;
                    if (importedData.scenes && importedData.scenes.length > 0) {
                        statusMessage += `ï¼Œ${importedData.scenes.length} ä¸ªåœºæ™¯`;
                    }
                    if (importedData.tags && importedData.tags.length > 0) {
                        statusMessage += `ï¼Œ${importedData.tags.length} ä¸ªæ ‡ç­¾`;
                    }
                    statusMessage += `ï¼Œæ¥è‡ª ${importedData.timestamp}`;
                    showStatus(statusMessage, 'success');
                    
                    // æ›´æ–°æœ€ç»ˆçš„æ€§èƒ½è¯„åˆ†
                    updatePerformanceScores();
                    
                } catch (error) {
                    showStatus('æ–‡ä»¶è§£æå¤±è´¥: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
            
            // æ¸…ç©ºfile input
            event.target.value = '';
        }

        function clearAllCharts() {
            if (cpuChart) {
                cpuChart.data.labels = [];
                cpuChart.data.datasets[0].data = [];
                cpuChart.update();
                
                memoryChart.data.labels = [];
                memoryChart.data.datasets[0].data = [];
                memoryChart.update();
                
                fpsChart.data.labels = [];
                fpsChart.data.datasets[0].data = [];
                fpsChart.update();
                
                threadsChart.data.labels = [];
                threadsChart.data.datasets[0].data = [];
                threadsChart.update();
                
                // æ¸…ç©ºæ‰€æœ‰æ ‡ç­¾æ ‡è®°
                const existingMarkers = document.querySelectorAll('.chart-tag-marker');
                existingMarkers.forEach(marker => marker.remove());
            }
        }

        // å¼€å§‹ç›‘æ§
        function startMonitoring() {
            const udid = document.getElementById('udid').value.trim();
            const bundleId = document.getElementById('bundleId').value.trim();
            
            showStatus('æ­£åœ¨å¯åŠ¨ç›‘æ§...', 'info');
            
            // æ¸…ç©ºä¹‹å‰çš„æ•°æ®
            allPerformanceData = [];
            
            socket.emit('start_monitoring', {
                udid: udid,
                bundle_id: bundleId
            });
            
            isMonitoring = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('saveBtn').disabled = false;
        }

        // åœæ­¢ç›‘æ§
        function stopMonitoring() {
            isMonitoring = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            showStatus('ç›‘æ§å·²åœæ­¢', 'info');
            // ä¿æŒå›¾è¡¨æ˜¾ç¤ºï¼Œä¸éšè—
        }

        // Socket.IOäº‹ä»¶å¤„ç†
        // åœºæ™¯ç®¡ç†åŠŸèƒ½
        function toggleSelection() {
            isSelecting = !isSelecting;
            const btn = document.getElementById('startSelectionBtn');
            const statusEl = document.getElementById('selectionStatus');
            
            if (isSelecting) {
                btn.textContent = 'å–æ¶ˆé€‰æ‹©';
                btn.style.background = '#ff3b30';
                statusEl.textContent = 'è¯·åœ¨ä»»æ„å›¾è¡¨ä¸Šæ‹–æ‹½é€‰æ‹©æ—¶é—´åŒºåŸŸ';
                document.body.classList.add('selecting');
                enableChartSelection();
            } else {
                btn.textContent = 'å¼€å§‹é€‰æ‹©æ—¶é—´åŒºåŸŸ';
                btn.style.background = '#007aff';
                statusEl.textContent = '';
                document.body.classList.remove('selecting');
                disableChartSelection();
                clearCurrentSelection();
            }
        }

        function enableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('mousedown', onSelectionStart);
                wrapper.addEventListener('mousemove', onSelectionMove);
                wrapper.addEventListener('mouseup', onSelectionEnd);
                wrapper.addEventListener('mouseleave', onSelectionEnd);
            });
        }

        function disableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.removeEventListener('mousedown', onSelectionStart);
                wrapper.removeEventListener('mousemove', onSelectionMove);
                wrapper.removeEventListener('mouseup', onSelectionEnd);
                wrapper.removeEventListener('mouseleave', onSelectionEnd);
            });
        }

        function onSelectionStart(e) {
            if (!isSelecting) return;
            isMouseDown = true;
            const rect = e.currentTarget.getBoundingClientRect();
            selectionStartX = e.clientX - rect.left;
            clearCurrentSelection();
        }

        function onSelectionMove(e) {
            if (!isSelecting || !isMouseDown) return;
            const rect = e.currentTarget.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const width = Math.abs(currentX - selectionStartX);
            const left = Math.min(selectionStartX, currentX);
            
            // åŒæ­¥æ˜¾ç¤ºé€‰æ‹©åŒºåŸŸåˆ°æ‰€æœ‰å›¾è¡¨
            updateAllSelectionOverlays(left, width);
        }

        function onSelectionEnd(e) {
            if (!isSelecting || !isMouseDown) return;
            isMouseDown = false;
            
            const rect = e.currentTarget.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // è®¡ç®—æ—¶é—´ç´¢å¼•
            const startIndex = Math.floor((Math.min(selectionStartX, endX) / chartWidth) * maxDataPoints);
            const endIndex = Math.floor((Math.max(selectionStartX, endX) / chartWidth) * maxDataPoints);
            
            if (Math.abs(endX - selectionStartX) > 10) { // æœ€å°é€‰æ‹©å®½åº¦
                // è·å–æ—¶é—´æ ‡ç­¾
                const timeLabels = cpuChart.data.labels;
                selectionStart = timeLabels[Math.max(0, startIndex)] || '';
                selectionEnd = timeLabels[Math.min(timeLabels.length - 1, endIndex)] || '';
                
                if (selectionStart && selectionEnd) {
                    document.getElementById('saveSceneBtn').disabled = false;
                    document.getElementById('selectionStatus').textContent = 
                        `å·²é€‰æ‹©æ—¶é—´æ®µ: ${selectionStart} - ${selectionEnd}`;
                }
            }
        }

        function updateAllSelectionOverlays(left, width) {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                const overlay = document.getElementById(overlayId);
                overlay.style.display = 'block';
                overlay.style.left = left + 'px';
                overlay.style.width = width + 'px';
                overlay.style.top = '0px';
                overlay.style.height = '100%';
            });
        }

        function clearCurrentSelection() {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                document.getElementById(overlayId).style.display = 'none';
            });
            selectionStart = null;
            selectionEnd = null;
            document.getElementById('saveSceneBtn').disabled = true;
        }

        function saveScene() {
            const sceneName = document.getElementById('sceneNameInput').value.trim();
            if (!sceneName) {
                showStatus('è¯·è¾“å…¥åœºæ™¯åç§°', 'error');
                return;
            }
            
            if (!selectionStart || !selectionEnd) {
                showStatus('è¯·å…ˆé€‰æ‹©æ—¶é—´åŒºåŸŸ', 'error');
                return;
            }

            // è·å–é€‰æ‹©æ—¶é—´æ®µå†…çš„æ€§èƒ½æ•°æ®
            const sceneData = allPerformanceData.filter(item => {
                return item.time >= selectionStart && item.time <= selectionEnd;
            });

            const scene = {
                id: Date.now(),
                name: sceneName,
                startTime: selectionStart,
                endTime: selectionEnd,
                data: sceneData,
                createdAt: new Date().toISOString(),
                summary: generateSceneSummary(sceneData)
            };

            savedScenes.push(scene);
            updateSceneList();
            
            // åœ¨æ‰€æœ‰å›¾è¡¨ä¸Šæ·»åŠ æ°¸ä¹…æ ‡è®°
            addSceneMarkersToAllCharts(scene);
            
            // æ¸…ç©ºè¾“å…¥å’Œé€‰æ‹©
            document.getElementById('sceneNameInput').value = '';
            clearCurrentSelection();
            toggleSelection(); // é€€å‡ºé€‰æ‹©æ¨¡å¼
            
            showStatus(`åœºæ™¯ "${sceneName}" å·²ä¿å­˜`, 'success');
        }

        function generateSceneSummary(sceneData) {
            const perfData = sceneData.filter(item => item.type === 'performance');
            //const fpsData = sceneData.filter(item => item.type === 'fps');
            
            if (perfData.length === 0) return {};
            
            const cpuValues = perfData.map(item => item.cpu);
            const memoryValues = perfData.map(item => item.memory);
            const fpsValues = perfData.map(item => item.fps);
            
            return {
                duration: perfData.length,
                avgCpu: (cpuValues.reduce((a, b) => a + b, 0) / cpuValues.length).toFixed(2),
                maxCpu: Math.max(...cpuValues).toFixed(2),
                avgMemory: (memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length).toFixed(1),
                maxMemory: Math.max(...memoryValues).toFixed(1),
                avgFps: fpsValues.length > 0 ? (fpsValues.reduce((a, b) => a + b, 0) / fpsValues.length).toFixed(1) : 0,
                minFps: fpsValues.length > 0 ? Math.min(...fpsValues) : 0
            };
        }

        function addSceneMarkersToAllCharts(scene) {
            // è¿™é‡Œæ·»åŠ æ°¸ä¹…çš„åœºæ™¯æ ‡è®°åˆ°æ‰€æœ‰å›¾è¡¨
            // Chart.jsæ’ä»¶å¯ä»¥å®ç°ï¼Œä½†ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å…ˆåœ¨åœºæ™¯åˆ—è¡¨ä¸­æ˜¾ç¤º
        }

        function updateSceneList() {
            const sceneList = document.getElementById('sceneList');
            sceneList.innerHTML = '';
            
            savedScenes.forEach(scene => {
                const sceneItem = document.createElement('div');
                sceneItem.className = 'scene-item';
                sceneItem.innerHTML = `
                    <div class="scene-info">
                        <div><strong>${scene.name}</strong></div>
                        <div class="scene-time">${scene.startTime} - ${scene.endTime}</div>
                        <div style="font-size: 11px; color: #86868b;">
                            å¹³å‡CPU: ${scene.summary.avgCpu}% | å¹³å‡å†…å­˜: ${scene.summary.avgMemory}MB | å¹³å‡FPS: ${scene.summary.avgFps}
                        </div>
                    </div>
                    <div class="scene-actions">
                        <button onclick="deleteScene(${scene.id})">åˆ é™¤</button>
                    </div>
                `;
                sceneList.appendChild(sceneItem);
            });
        }

        function deleteScene(sceneId) {
            savedScenes = savedScenes.filter(scene => scene.id !== sceneId);
            updateSceneList();
            showStatus('åœºæ™¯å·²åˆ é™¤', 'info');
        }

        function clearAllScenes() {
            if (savedScenes.length === 0) return;
            if (confirm('ç¡®è®¤æ¸…ç©ºæ‰€æœ‰åœºæ™¯æ ‡è®°ï¼Ÿ')) {
                savedScenes = [];
                updateSceneList();
                showStatus('æ‰€æœ‰åœºæ™¯å·²æ¸…ç©º', 'info');
            }
        }

        // ä¿®æ”¹ä¿å­˜æ•°æ®å‡½æ•°ï¼ŒåŒ…å«åœºæ™¯å’Œæ ‡ç­¾ä¿¡æ¯
        function saveDataWithScenes() {
            if (allTimeLabels.length === 0 && savedScenes.length === 0 && savedTags.length === 0) {
                showStatus('æ²¡æœ‰æ•°æ®ã€åœºæ™¯æˆ–æ ‡ç­¾å¯ä¿å­˜', 'error');
                return;
            }

            // é‡æ–°æ„å»ºæ€§èƒ½æ•°æ®æ•°ç»„
            const performanceData = [];
            for (let i = 0; i < allTimeLabels.length; i++) {
                performanceData.push({
                    timestamp: allTimeLabels[i],
                    cpu: allCpuData[i] || 0,
                    memory: allMemoryData[i] || 0,
                    fps: allFpsData[i] || 0,
                    threads: allThreadsData[i] || 0
                });
            }

            const now = new Date();
            const filename = `ios_performance_complete_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}.json`;
            
            const dataToSave = {
                timestamp: now.toISOString(),
                device_udid: document.getElementById('udid').value.trim(),
                bundle_id: document.getElementById('bundleId').value.trim(),
                data: performanceData,
                scenes: savedScenes, // åŒ…å«åœºæ™¯ä¿¡æ¯
                tags: savedTags, // åŒ…å«æ ‡ç­¾ä¿¡æ¯
                settings: {
                    windowSize: windowSize,
                    timePosition: timePosition
                },
                summary: {
                    total_records: performanceData.length,
                    total_scenes: savedScenes.length,
                    total_tags: savedTags.length,
                    duration_seconds: performanceData.length > 0 ? 
                        Math.round((new Date(performanceData[performanceData.length-1].timestamp) - new Date(performanceData[0].timestamp)) / 1000) : 0
                }
            };

            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`æ•°æ®å’Œåœºæ™¯å·²ä¿å­˜åˆ° ${filename}`, 'success');
        }

        socket.on('monitoring_started', function(data) {
            if (data.status === 'success') {
                showStatus('ç›‘æ§å·²å¯åŠ¨ï¼Œæ­£åœ¨æ”¶é›†æ•°æ®...', 'success');
                document.getElementById('chartsGrid').style.display = 'grid';
                document.getElementById('currentValues').style.display = 'grid';
                document.getElementById('timeControls').style.display = 'block';
                document.getElementById('sceneControls').style.display = 'block';
                document.getElementById('tagControls').style.display = 'block';
                document.getElementById('scenarioControls').style.display = 'block';
                initCharts();
                enableDoubleClickTags(); // å¯ç”¨åŒå‡»æ ‡ç­¾åŠŸèƒ½
            }
        });

        socket.on('performance_data', function(data) {
            if (!isMonitoring) return;
            
            // ä¿å­˜åˆ°allPerformanceDataç”¨äºå¯¼å‡º
            allPerformanceData.push({
                type: 'performance',
                timestamp: new Date().toISOString(),
                time: data.time,
                cpu: data.cpu,
                memory: data.memory,
                fps: data.fps,
                threads: data.threads,
                pid: data.pid,
                name: data.name
            });

            // æ›´æ–°å½“å‰å€¼æ˜¾ç¤º
            document.getElementById('currentCpu').textContent = `${data.cpu}%`;
            document.getElementById('currentMemory').textContent = `${data.memory.toFixed(1)}MB`;
            document.getElementById('currentThreads').textContent = data.threads;
            // æ›´æ–°å½“å‰FPSæ˜¾ç¤º
            document.getElementById('currentFps').textContent = `${data.fps}FPS`;
            
            // æ·»åŠ æ•°æ®åˆ°å›¾è¡¨
            addDataToChart(cpuChart, data.time, data.cpu);
            addDataToChart(memoryChart, data.time, data.memory);
            addDataToChart(threadsChart, data.time, data.threads);
            // æ·»åŠ FPSæ•°æ®åˆ°å›¾è¡¨
            addDataToChart(fpsChart, data.time, data.fps);
            
            // æ›´æ–°æ€§èƒ½ç»Ÿè®¡åˆ†æ
            updatePerformanceStats(data.cpu, data.memory, data.fps || 0, data.threads);
            
            // æ£€æŸ¥æ€§èƒ½é˜ˆå€¼å‘Šè­¦
            checkPerformanceThresholds(data.cpu, data.memory, data.fps || 0, data.threads);
            
            // ä¸“ä¸šçº§å†…å­˜æ³„æ¼æ£€æµ‹ (ä¼ é€’æ‰€æœ‰æ€§èƒ½å‚æ•°)
            detectMemoryLeak(data.memory, data.cpu, data.fps || 0, data.threads);
            
            // æ›´æ–°å®æ—¶è¯„åˆ†
            updatePerformanceScores();
        });

        /*socket.on('fps_data', function(data) {
            if (!isMonitoring) return;

            // ä¿å­˜åˆ°allPerformanceDataç”¨äºå¯¼å‡º
            allPerformanceData.push({
                type: 'fps',
                timestamp: new Date().toISOString(),
                time: data.time,
                fps: data.fps
            });

            // æ›´æ–°å½“å‰FPSæ˜¾ç¤º
            document.getElementById('currentFps').textContent = `${data.fps}FPS`;

            // æ·»åŠ FPSæ•°æ®åˆ°å›¾è¡¨
            addDataToChart(fpsChart, data.time, data.fps);
        });*/

        socket.on('connect', function() {
            console.log('å·²è¿æ¥åˆ°æœåŠ¡å™¨');
        });

        socket.on('disconnect', function() {
            console.log('ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥');
            if (isMonitoring) {
                showStatus('ä¸æœåŠ¡å™¨è¿æ¥æ–­å¼€', 'error');
            }
        });

        // æ€§èƒ½ç»Ÿè®¡æ›´æ–°å‡½æ•°
        function updatePerformanceStats(cpu, memory, fps, threads) {
            // æ›´æ–°CPUç»Ÿè®¡
            performanceStats.cpu.current = cpu;
            performanceStats.cpu.sum += cpu;
            performanceStats.cpu.count++;
            performanceStats.cpu.avg = performanceStats.cpu.sum / performanceStats.cpu.count;
            performanceStats.cpu.max = Math.max(performanceStats.cpu.max, cpu);
            
            // æ›´æ–°å†…å­˜ç»Ÿè®¡
            performanceStats.memory.current = memory;
            performanceStats.memory.sum += memory;
            performanceStats.memory.count++;
            performanceStats.memory.avg = performanceStats.memory.sum / performanceStats.memory.count;
            performanceStats.memory.max = Math.max(performanceStats.memory.max, memory);
            
            // æ›´æ–°FPSç»Ÿè®¡
            if (fps > 0) {
                performanceStats.fps.current = fps;
                performanceStats.fps.sum += fps;
                performanceStats.fps.count++;
                performanceStats.fps.avg = performanceStats.fps.sum / performanceStats.fps.count;
                performanceStats.fps.min = Math.min(performanceStats.fps.min, fps);
            }
            
            // æ›´æ–°çº¿ç¨‹ç»Ÿè®¡
            performanceStats.threads.current = threads;
            performanceStats.threads.sum += threads;
            performanceStats.threads.count++;
            performanceStats.threads.avg = performanceStats.threads.sum / performanceStats.threads.count;
            performanceStats.threads.max = Math.max(performanceStats.threads.max, threads);
            
            // æ›´æ–°ç»Ÿè®¡é¢æ¿æ˜¾ç¤º
            updateStatisticsDisplay();
        }
        
        function updateStatisticsDisplay() {
            document.getElementById('statCpuCurrent').textContent = `${performanceStats.cpu.current.toFixed(1)}%`;
            document.getElementById('statCpuAvg').textContent = `${performanceStats.cpu.avg.toFixed(1)}%`;
            document.getElementById('statCpuMax').textContent = `${performanceStats.cpu.max.toFixed(1)}%`;
            
            document.getElementById('statMemoryCurrent').textContent = `${performanceStats.memory.current.toFixed(1)}MB`;
            document.getElementById('statMemoryAvg').textContent = `${performanceStats.memory.avg.toFixed(1)}MB`;
            document.getElementById('statMemoryMax').textContent = `${performanceStats.memory.max.toFixed(1)}MB`;
            
            if (performanceStats.fps.count > 0) {
                document.getElementById('statFpsCurrent').textContent = `${performanceStats.fps.current}FPS`;
                document.getElementById('statFpsAvg').textContent = `${performanceStats.fps.avg.toFixed(1)}FPS`;
                document.getElementById('statFpsMin').textContent = `${performanceStats.fps.min === Infinity ? 0 : performanceStats.fps.min}FPS`;
            }
            
            document.getElementById('statThreadsCurrent').textContent = performanceStats.threads.current;
            document.getElementById('statThreadsAvg').textContent = performanceStats.threads.avg.toFixed(1);
            document.getElementById('statThreadsMax').textContent = performanceStats.threads.max;
        }
        
        // æ€§èƒ½é˜ˆå€¼æ£€æŸ¥å‡½æ•°
        function checkPerformanceThresholds(cpu, memory, fps, threads) {
            // æ›´æ–°é˜ˆå€¼é…ç½®
            thresholds.cpu = parseInt(document.getElementById('cpuThreshold').value) || 80;
            thresholds.memory = parseInt(document.getElementById('memoryThreshold').value) || 200;
            thresholds.fps = parseInt(document.getElementById('fpsThreshold').value) || 30;
            thresholds.threads = parseInt(document.getElementById('threadsThreshold').value) || 50;
            
            activeAlerts = []; // æ¸…ç©ºå‘Šè­¦åˆ—è¡¨
            
            // æ£€æŸ¥CPUé˜ˆå€¼
            if (cpu > thresholds.cpu) {
                activeAlerts.push({
                    type: 'cpu',
                    level: cpu > thresholds.cpu * 1.2 ? 'critical' : 'warning',
                    message: `CPUä½¿ç”¨ç‡è¿‡é«˜: ${cpu.toFixed(1)}% (é˜ˆå€¼: ${thresholds.cpu}%)`
                });
            }
            
            // æ£€æŸ¥å†…å­˜é˜ˆå€¼
            if (memory > thresholds.memory) {
                activeAlerts.push({
                    type: 'memory',
                    level: memory > thresholds.memory * 1.2 ? 'critical' : 'warning',
                    message: `å†…å­˜ä½¿ç”¨é‡è¿‡é«˜: ${memory.toFixed(1)}MB (é˜ˆå€¼: ${thresholds.memory}MB)`
                });
            }
            
            // æ£€æŸ¥FPSé˜ˆå€¼
            if (fps > 0 && fps < thresholds.fps) {
                activeAlerts.push({
                    type: 'fps',
                    level: fps < thresholds.fps * 0.7 ? 'critical' : 'warning',
                    message: `å¸§ç‡è¿‡ä½: ${fps}FPS (é˜ˆå€¼: ${thresholds.fps}FPS)`
                });
            }
            
            // æ£€æŸ¥çº¿ç¨‹æ•°é˜ˆå€¼
            if (threads > thresholds.threads) {
                activeAlerts.push({
                    type: 'threads',
                    level: threads > thresholds.threads * 1.2 ? 'critical' : 'warning',
                    message: `çº¿ç¨‹æ•°è¿‡å¤š: ${threads} (é˜ˆå€¼: ${thresholds.threads})`
                });
            }
            
            updateAlertsDisplay();
        }
        
        function updateAlertsDisplay() {
            const alertPanel = document.getElementById('alertPanel');
            const alertList = document.getElementById('alertList');
            
            if (activeAlerts.length === 0) {
                alertPanel.style.display = 'none';
                return;
            }
            
            alertPanel.style.display = 'block';
            alertList.innerHTML = '';
            
            activeAlerts.forEach(alert => {
                const alertItem = document.createElement('div');
                alertItem.className = `alert-item ${alert.level}`;
                alertItem.innerHTML = `
                    <span>${alert.message}</span>
                    <span>âš ï¸</span>
                `;
                alertList.appendChild(alertItem);
            });
        }
        
        // ä¸“ä¸šçº§å†…å­˜æ³„æ¼æ£€æµ‹ä¸»å‡½æ•°
        function detectMemoryLeak(currentMemory, cpuUsage = 0, fpsRate = 0, threads = 0) {
            // ä½¿ç”¨æ–°çš„ä¸“ä¸šæ£€æµ‹ç³»ç»Ÿ
            runProfessionalMemoryLeakDetection(currentMemory, cpuUsage, fpsRate, threads);
            
            // å…¼å®¹æ—§UIæ˜¾ç¤º
            updateLegacyMemoryLeakUI(currentMemory);
        }
        
        function showMemoryLeakWarning(growthRate) {
            const warningEl = document.getElementById('leakWarning');
            const detailsEl = document.getElementById('leakDetails');
            
            detailsEl.innerHTML = `
                æ£€æµ‹åˆ°å†…å­˜æŒç»­å¢é•¿ï¼Œå¢é•¿ç‡: ${growthRate.toFixed(2)} MB/min<br>
                å»ºè®®æ£€æŸ¥åº”ç”¨æ˜¯å¦å­˜åœ¨å†…å­˜æ³„æ¼é—®é¢˜ã€‚<br>
                <small>æ£€æµ‹æ—¶é—´çª—å£: 5åˆ†é’Ÿ</small>
            `;
            
            warningEl.style.display = 'block';
            warningEl.classList.add('active');
        }
        
        function hideMemoryLeakWarning() {
            const warningEl = document.getElementById('leakWarning');
            warningEl.style.display = 'none';
            warningEl.classList.remove('active');
        }
        
        // æ€§èƒ½è¯„åˆ†è®¡ç®—å‡½æ•°
        function updatePerformanceScores() {
            const scores = calculatePerformanceScores();
            
            // æ›´æ–°CPUè¯„åˆ†
            updateScoreDisplay('cpu', scores.cpu);
            
            // æ›´æ–°å†…å­˜è¯„åˆ†
            updateScoreDisplay('memory', scores.memory);
            
            // æ›´æ–°FPSè¯„åˆ†
            updateScoreDisplay('fps', scores.fps);
            
            // æ›´æ–°æ€»ä½“è¯„åˆ†
            const overallScore = Math.round((scores.cpu.score + scores.memory.score + scores.fps.score) / 3);
            const overallGrade = getGradeFromScore(overallScore);
            updateScoreDisplay('overall', { score: overallScore, grade: overallGrade });
        }
        
        function calculatePerformanceScores() {
            const cpu = performanceStats.cpu.current;
            const memory = performanceStats.memory.current;
            const fps = performanceStats.fps.current;
            
            // CPUè¯„åˆ† (0-100)
            let cpuScore = Math.max(0, 100 - cpu);
            if (cpu < 30) cpuScore = 100;
            else if (cpu < 50) cpuScore = 90;
            else if (cpu < 70) cpuScore = 75;
            else if (cpu < 85) cpuScore = 60;
            else cpuScore = Math.max(0, 100 - cpu);
            
            // å†…å­˜è¯„åˆ† (å‡è®¾200MBä¸ºåŸºå‡†)
            let memoryScore = Math.max(0, 100 - (memory / 200) * 100);
            if (memory < 100) memoryScore = 100;
            else if (memory < 150) memoryScore = 90;
            else if (memory < 200) memoryScore = 75;
            else if (memory < 300) memoryScore = 60;
            else memoryScore = Math.max(0, 100 - ((memory - 200) / 200) * 100);
            
            // FPSè¯„åˆ†
            let fpsScore = 100;
            if (fps > 0) {
                if (fps >= 55) fpsScore = 100;
                else if (fps >= 45) fpsScore = 90;
                else if (fps >= 30) fpsScore = 75;
                else if (fps >= 20) fpsScore = 60;
                else fpsScore = Math.max(0, (fps / 20) * 60);
            }
            
            return {
                cpu: { score: Math.round(cpuScore), grade: getGradeFromScore(cpuScore) },
                memory: { score: Math.round(memoryScore), grade: getGradeFromScore(memoryScore) },
                fps: { score: Math.round(fpsScore), grade: getGradeFromScore(fpsScore) }
            };
        }
        
        function getGradeFromScore(score) {
            if (score >= 90) return 'A+';
            if (score >= 80) return 'A';
            if (score >= 70) return 'B';
            if (score >= 60) return 'C';
            if (score >= 50) return 'D';
            return 'F';
        }
        
        function updateScoreDisplay(type, scoreData) {
            const scoreEl = document.getElementById(`${type}Score`);
            const scoreNumEl = document.getElementById(`${type}ScoreNum`);
            
            if (scoreEl && scoreNumEl) {
                scoreEl.textContent = scoreData.grade;
                scoreNumEl.textContent = `(${scoreData.score})`;
                
                // æ›´æ–°é¢œè‰²
                scoreEl.className = 'score-value grade-' + scoreData.grade.toLowerCase().replace('+', '');
            }
        }
        
        function resetPerformanceStats() {
            performanceStats = {
                cpu: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
                memory: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
                fps: { current: 0, avg: 0, min: Infinity, sum: 0, count: 0 },
                threads: { current: 0, avg: 0, max: 0, sum: 0, count: 0 }
            };
            updateStatisticsDisplay();
            // é‡ç½®å†…å­˜æ³„æ¼æ£€æµ‹ç³»ç»Ÿ
            memoryLeakDetection.memoryHistory = [];
            professionalMemoryLeakDetection.memoryHistory = [];
            professionalMemoryLeakDetection.sceneStateMachine.currentScene = 'unknown';
            professionalMemoryLeakDetection.sceneStateMachine.sceneHistory = [];
            professionalMemoryLeakDetection.status.isLeaking = false;
            professionalMemoryLeakDetection.status.leakSources = [];
            professionalMemoryLeakDetection.status.suspiciousTransitions = [];
            professionalMemoryLeakDetection.statistics.totalLeaksDetected = 0;
            professionalMemoryLeakDetection.statistics.averageRecoveryRate = 0;
            activeAlerts = [];
            updateAlertsDisplay();
        }

        function calculateOverallScore() {
            const scores = calculatePerformanceScores();
            return Math.round((scores.cpu.score + scores.memory.score + scores.fps.score) / 3);
        }

        // é¢æ¿æ‹–æ‹½åŠŸèƒ½
        let draggedElement = null;
        let placeholder = null;
        let dragStartY = 0;
        let isDragging = false;

        function initDragAndDrop() {
            const container = document.querySelector('.container');
            const panels = document.querySelectorAll('.controls');
            
            panels.forEach(panel => {
                panel.setAttribute('draggable', 'true');
                
                panel.addEventListener('dragstart', function(e) {
                    draggedElement = this;
                    this.classList.add('dragging');
                    dragStartY = e.clientY;
                    isDragging = true;
                    
                    // åˆ›å»ºå ä½ç¬¦
                    placeholder = document.createElement('div');
                    placeholder.className = 'drag-placeholder';
                    
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', this.outerHTML);
                    
                    setTimeout(() => {
                        this.style.display = 'none';
                    }, 0);
                });
                
                panel.addEventListener('dragend', function(e) {
                    this.classList.remove('dragging');
                    this.style.display = 'block';
                    
                    if (placeholder && placeholder.parentNode) {
                        placeholder.parentNode.removeChild(placeholder);
                    }
                    
                    draggedElement = null;
                    placeholder = null;
                    isDragging = false;
                });
            });
            
            // å¤„ç†æ‹–æ”¾ç›®æ ‡
            container.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                if (isDragging && draggedElement && placeholder) {
                    const afterElement = getDragAfterElement(container, e.clientY);
                    if (afterElement == null) {
                        container.appendChild(placeholder);
                    } else {
                        container.insertBefore(placeholder, afterElement);
                    }
                }
            });
            
            container.addEventListener('drop', function(e) {
                e.preventDefault();
                
                if (draggedElement && placeholder && placeholder.parentNode) {
                    placeholder.parentNode.insertBefore(draggedElement, placeholder);
                    placeholder.parentNode.removeChild(placeholder);
                    
                    // ä¿å­˜æ–°çš„é¢æ¿é¡ºåºåˆ°localStorage
                    savePanelOrder();
                    
                    showStatus('é¢æ¿é¡ºåºå·²è°ƒæ•´', 'success');
                }
            });
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.controls:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function savePanelOrder() {
            const panels = document.querySelectorAll('.controls');
            const order = [];
            
            panels.forEach(panel => {
                if (panel.id) {
                    order.push(panel.id);
                }
            });
            
            localStorage.setItem('panelOrder', JSON.stringify(order));
        }

        function restorePanelOrder() {
            const savedOrder = localStorage.getItem('panelOrder');
            if (!savedOrder) return;
            
            try {
                const order = JSON.parse(savedOrder);
                const container = document.querySelector('.container');
                
                // æ‰¾åˆ°æ‰€æœ‰é¢æ¿
                const panels = {};
                document.querySelectorAll('.controls').forEach(panel => {
                    if (panel.id) {
                        panels[panel.id] = panel;
                    }
                });
                
                // æŒ‰ä¿å­˜çš„é¡ºåºé‡æ–°æ’åˆ—
                order.forEach(panelId => {
                    if (panels[panelId]) {
                        container.appendChild(panels[panelId]);
                    }
                });
                
                console.log('å·²æ¢å¤é¢æ¿é¡ºåº');
            } catch (error) {
                console.log('æ¢å¤é¢æ¿é¡ºåºå¤±è´¥:', error);
            }
        }

        // é‡ç½®é¢æ¿é¡ºåºåŠŸèƒ½
        function resetPanelOrder() {
            localStorage.removeItem('panelOrder');
            location.reload(); // ç®€å•é‡æ–°åŠ è½½é¡µé¢æ¥æ¢å¤é»˜è®¤é¡ºåº
        }

        // åˆ†äº«åŠŸèƒ½
        function showShareDialog() {
            const dialog = document.getElementById('shareDialog');
            const urlElement = document.getElementById('shareUrl');
            
            // è·å–å½“å‰é¡µé¢çš„åˆ†äº«URL
            const currentHost = window.location.hostname;
            const currentPort = window.location.port || (window.location.protocol === 'https:' ? '443' : '80');
            const shareUrl = `${window.location.protocol}//${currentHost}:${currentPort}`;
            
            urlElement.textContent = shareUrl;
            dialog.style.display = 'flex';
            
            // æ·»åŠ ç‚¹å‡»èƒŒæ™¯å…³é—­åŠŸèƒ½
            dialog.onclick = function(e) {
                if (e.target === dialog) {
                    closeShareDialog();
                }
            };
        }

        function closeShareDialog() {
            const dialog = document.getElementById('shareDialog');
            dialog.style.display = 'none';
        }

        function copyShareUrl() {
            const urlElement = document.getElementById('shareUrl');
            const shareUrl = urlElement.textContent;
            
            // ä½¿ç”¨ç°ä»£æµè§ˆå™¨çš„Clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(shareUrl).then(() => {
                    showCopySuccess();
                }).catch(() => {
                    fallbackCopyTextToClipboard(shareUrl);
                });
            } else {
                fallbackCopyTextToClipboard(shareUrl);
            }
        }

        function fallbackCopyTextToClipboard(text) {
            // åˆ›å»ºä¸´æ—¶æ–‡æœ¬åŸŸ
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-999999px";
            textArea.style.top = "-999999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showCopySuccess();
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                showStatus('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶é“¾æ¥', 'error');
            }
            
            document.body.removeChild(textArea);
        }

        function showCopySuccess() {
            const copyBtn = document.querySelector('.copy-btn');
            const originalText = copyBtn.textContent;
            
            copyBtn.textContent = 'âœ… å·²å¤åˆ¶';
            copyBtn.classList.add('copied');
            
            setTimeout(() => {
                copyBtn.textContent = originalText;
                copyBtn.classList.remove('copied');
            }, 2000);
            
            showStatus('åˆ†äº«é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
        }

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function(e) {
            // Ctrl+Shift+S æˆ– Cmd+Shift+S å¿«é€Ÿåˆ†äº«
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'S') {
                e.preventDefault();
                showShareDialog();
            }
            // ESCé”®å…³é—­åˆ†äº«å¯¹è¯æ¡†
            if (e.key === 'Escape') {
                closeShareDialog();
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('iOSæ€§èƒ½ç›‘æ§å¯è§†åŒ–ç•Œé¢å·²åŠ è½½');
            
            // åˆå§‹åŒ–æ‹–æ‹½åŠŸèƒ½
            setTimeout(() => {
                initDragAndDrop();
                restorePanelOrder();
            }, 100);
        });
        
        // ======================== ä¸“ä¸šçº§å†…å­˜æ³„æ¼æ£€æµ‹æ ¸å¿ƒå‡½æ•° ========================
        
        // æ™ºèƒ½åœºæ™¯è¯†åˆ«
        function detectCurrentScene(currentMemory, cpuUsage, fpsRate, threads) {
            const history = professionalMemoryLeakDetection.memoryHistory;
            
            if (history.length < 5) return 'unknown';
            
            // åˆ†æå†…å­˜å˜åŒ–æ¨¡å¼
            const recentMemory = history.slice(-5).map(h => h.memory);
            const memoryTrend = calculateTrend(recentMemory);
            const memoryVolatility = calculateVolatility(recentMemory);
            
            // åœºæ™¯è¯†åˆ«è§„åˆ™ (åŸºäºçœŸå®iOSåº”ç”¨ç‰¹å¾)
            if (currentMemory < 120 && cpuUsage < 20 && Math.abs(memoryTrend) < 2) {
                return currentMemory < 90 ? 'background' : 'idle';
            } else if (memoryTrend > 15 && cpuUsage > 40) {
                return currentMemory > 250 ? 'video_playing' : 'launching';
            } else if (memoryVolatility > 10 && cpuUsage > 15) {
                return 'navigation';
            } else if (currentMemory > 200 && fpsRate > 30) {
                return 'video_playing';
            }
            
            return 'idle';
        }
        
        // è®¡ç®—æ•°æ®è¶‹åŠ¿
        function calculateTrend(values) {
            if (values.length < 2) return 0;
            let sum = 0;
            for (let i = 1; i < values.length; i++) {
                sum += values[i] - values[i-1];
            }
            return sum / (values.length - 1);
        }
        
        // è®¡ç®—æ•°æ®æ³¢åŠ¨æ€§
        function calculateVolatility(values) {
            if (values.length < 2) return 0;
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            return Math.sqrt(variance);
        }
        
        // ä¸“ä¸šçº§æ£€æµ‹æ‰§è¡Œå™¨
        function runProfessionalMemoryLeakDetection(currentMemory, cpuUsage, fpsRate, threads) {
            const now = Date.now();
            const stateMachine = professionalMemoryLeakDetection.sceneStateMachine;
            const detection = professionalMemoryLeakDetection.detection;
            
            // è®°å½•å†…å­˜å†å²
            professionalMemoryLeakDetection.memoryHistory.push({
                time: now,
                memory: currentMemory,
                cpu: cpuUsage,
                fps: fpsRate,
                threads: threads,
                scene: null
            });
            
            // ä¿æŒå†å²è®°å½•é•¿åº¦
            if (professionalMemoryLeakDetection.memoryHistory.length > professionalMemoryLeakDetection.maxHistoryLength) {
                professionalMemoryLeakDetection.memoryHistory.shift();
            }
            
            // æ£€æµ‹å½“å‰åœºæ™¯
            const detectedScene = detectCurrentScene(currentMemory, cpuUsage, fpsRate, threads);
            professionalMemoryLeakDetection.memoryHistory[professionalMemoryLeakDetection.memoryHistory.length - 1].scene = detectedScene;
            
            // åœºæ™¯åˆ‡æ¢æ£€æµ‹
            if (detectedScene !== stateMachine.currentScene && stateMachine.currentScene !== 'unknown') {
                handleSceneTransition(stateMachine.currentScene, detectedScene, currentMemory, now);
            }
            
            // æ›´æ–°å½“å‰åœºæ™¯ä¿¡æ¯
            if (!stateMachine.sceneStartTime || detectedScene !== stateMachine.currentScene) {
                stateMachine.sceneStartTime = now;
                stateMachine.sceneStartMemory = currentMemory;
            }
            
            stateMachine.currentScene = detectedScene;
            
            // æ‰§è¡Œå¤šç»´åº¦æ£€æµ‹
            if (professionalMemoryLeakDetection.memoryHistory.length >= detection.minSampleSize) {
                performComprehensiveLeakDetection(currentMemory, now);
            }
            
            // æ›´æ–°UIæ˜¾ç¤º
            updateProfessionalMemoryLeakUI();
        }
        
        // å¤„ç†åœºæ™¯åˆ‡æ¢
        function handleSceneTransition(fromScene, toScene, currentMemory, timestamp) {
            const stateMachine = professionalMemoryLeakDetection.sceneStateMachine;
            const detection = professionalMemoryLeakDetection.detection;
            
            const sceneDuration = timestamp - stateMachine.sceneStartTime;
            
            // åªæœ‰åœºæ™¯æŒç»­è¶³å¤Ÿé•¿æ—¶é—´æ‰è¿›è¡Œåˆ†æ
            if (sceneDuration >= detection.sceneMinDuration) {
                analyzeSceneTransition(fromScene, toScene, stateMachine.sceneStartMemory, currentMemory, sceneDuration);
            }
            
            // è®°å½•åœºæ™¯åˆ‡æ¢å†å²
            stateMachine.sceneHistory.push({
                fromScene,
                toScene,
                startMemory: stateMachine.sceneStartMemory,
                endMemory: currentMemory,
                duration: sceneDuration,
                timestamp: timestamp,
                memoryDelta: currentMemory - stateMachine.sceneStartMemory
            });
            
            // ä¿æŒå†å²è®°å½•é•¿åº¦
            if (stateMachine.sceneHistory.length > 50) {
                stateMachine.sceneHistory.shift();
            }
            
            stateMachine.sceneTransitionCount++;
            console.log(`ğŸ”„ åœºæ™¯åˆ‡æ¢: ${fromScene} â†’ ${toScene}, å†…å­˜å˜åŒ–: ${(currentMemory - stateMachine.sceneStartMemory).toFixed(1)}MB`);
        }
        
        // åˆ†æåœºæ™¯åˆ‡æ¢çš„å†…å­˜å›æ”¶æƒ…å†µ
        function analyzeSceneTransition(fromScene, toScene, startMemory, endMemory, duration) {
            const profiles = professionalMemoryLeakDetection.sceneProfiles;
            const status = professionalMemoryLeakDetection.status;
            
            // æ£€æŸ¥æ˜¯å¦ä»é«˜å†…å­˜åœºæ™¯åˆ‡æ¢åˆ°ä½å†…å­˜åœºæ™¯
            const fromPriority = profiles[fromScene]?.priority || 0;
            const toPriority = profiles[toScene]?.priority || 0;
            
            if (fromPriority > toPriority) {
                // æœŸæœ›å†…å­˜ä¸‹é™
                const expectedDecrease = calculateExpectedMemoryDecrease(fromScene, toScene, startMemory);
                const actualDecrease = Math.max(0, startMemory - endMemory);
                const recoveryRate = expectedDecrease > 0 ? actualDecrease / expectedDecrease : 1;
                
                // æ›´æ–°ç»Ÿè®¡
                const stats = professionalMemoryLeakDetection.statistics;
                stats.averageRecoveryRate = (stats.averageRecoveryRate + recoveryRate) / 2;
                
                // æ£€æµ‹å†…å­˜æ³„æ¼
                if (recoveryRate < professionalMemoryLeakDetection.detection.leakThreshold && expectedDecrease > 10) {
                    const leakAmount = Math.max(0, expectedDecrease - actualDecrease);
                    reportMemoryLeak(fromScene, toScene, leakAmount, recoveryRate, 'scene_transition');
                }
                
                console.log(`ğŸ“Š åœºæ™¯åˆ‡æ¢åˆ†æ: ${fromScene} â†’ ${toScene}, æœŸæœ›å›æ”¶: ${expectedDecrease.toFixed(1)}MB, å®é™…å›æ”¶: ${actualDecrease.toFixed(1)}MB, å›æ”¶ç‡: ${(recoveryRate*100).toFixed(1)}%`);
            }
        }
        
        // è®¡ç®—æœŸæœ›çš„å†…å­˜ä¸‹é™é‡
        function calculateExpectedMemoryDecrease(fromScene, toScene, currentMemory) {
            const profiles = professionalMemoryLeakDetection.sceneProfiles;
            const fromProfile = profiles[fromScene];
            const toProfile = profiles[toScene];
            
            if (!fromProfile || !toProfile) return 0;
            
            // åŸºäºåœºæ™¯ç‰¹æ€§è®¡ç®—æœŸæœ›ä¸‹é™é‡
            const fromExpected = (fromProfile.expectedMemory.min + fromProfile.expectedMemory.max) / 2;
            const toExpected = (toProfile.expectedMemory.min + toProfile.expectedMemory.max) / 2;
            
            // è€ƒè™‘å½“å‰å†…å­˜æ°´å¹³çš„è°ƒæ•´å› å­
            const ratio = Math.min(1.0, Math.max(0.3, currentMemory / fromExpected));
            return Math.max(0, (fromExpected - toExpected) * ratio);
        }
        
        // æŠ¥å‘Šå†…å­˜æ³„æ¼
        function reportMemoryLeak(fromScene, toScene, leakAmount, recoveryRate, source) {
            const status = professionalMemoryLeakDetection.status;
            const statistics = professionalMemoryLeakDetection.statistics;
            
            statistics.totalLeaksDetected++;
            
            const leakReport = {
                source: source,
                fromScene: fromScene,
                toScene: toScene,
                leakAmount: leakAmount,
                recoveryRate: recoveryRate,
                timestamp: Date.now(),
                severity: leakAmount > 50 ? 'severe' : leakAmount > 20 ? 'moderate' : 'mild'
            };
            
            status.suspiciousTransitions.push(leakReport);
            
            // ä¿æŒè®°å½•é•¿åº¦
            if (status.suspiciousTransitions.length > 10) {
                status.suspiciousTransitions.shift();
            }
            
            console.log(`ğŸš¨ å†…å­˜æ³„æ¼æ£€æµ‹: ${fromScene} â†’ ${toScene}, æ³„æ¼é‡: ${leakAmount.toFixed(1)}MB, å›æ”¶ç‡: ${(recoveryRate*100).toFixed(1)}%`);
        }
        
        // ç»¼åˆæ³„æ¼æ£€æµ‹
        function performComprehensiveLeakDetection(currentMemory, timestamp) {
            const history = professionalMemoryLeakDetection.memoryHistory;
            const detection = professionalMemoryLeakDetection.detection;
            
            // 1. è¶‹åŠ¿åˆ†æ
            const trendWindow = Math.min(detection.trendAnalysisWindow, history.length);
            const recentHistory = history.slice(-trendWindow);
            const memoryTrend = calculateAdvancedTrend(recentHistory);
            
            // 2. å¼‚å¸¸æ£€æµ‹
            const anomalies = detectMemoryAnomalies(recentHistory);
            
            // 3. é•¿æœŸå†…å­˜å¢é•¿æ£€æµ‹
            const longTermGrowth = analyzeLongTermMemoryGrowth(history);
            
            // ç»¼åˆè¯„ä¼°
            evaluateOverallLeakStatus(memoryTrend, anomalies, longTermGrowth);
        }
        
        // é«˜çº§è¶‹åŠ¿åˆ†æ
        function calculateAdvancedTrend(historyWindow) {
            if (historyWindow.length < 10) return { slope: 0, confidence: 0, pattern: 'insufficient_data' };
            
            const memoryValues = historyWindow.map(h => h.memory);
            const timeValues = historyWindow.map((h, i) => i);
            
            // çº¿æ€§å›å½’
            const slope = calculateLinearRegressionSlope(timeValues, memoryValues);
            const correlation = calculateCorrelation(timeValues, memoryValues);
            
            return {
                slope: slope,
                confidence: Math.abs(correlation),
                pattern: identifyMemoryPattern(memoryValues),
                volatility: calculateVolatility(memoryValues)
            };
        }
        
        // çº¿æ€§å›å½’æ–œç‡è®¡ç®—
        function calculateLinearRegressionSlope(x, y) {
            const n = x.length;
            if (n < 2) return 0;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            
            const denominator = n * sumXX - sumX * sumX;
            return denominator === 0 ? 0 : (n * sumXY - sumX * sumY) / denominator;
        }
        
        // ç›¸å…³ç³»æ•°è®¡ç®—
        function calculateCorrelation(x, y) {
            const n = x.length;
            if (n < 2) return 0;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumYY = y.reduce((sum, yi) => sum + yi * yi, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }
        
        // å†…å­˜æ¨¡å¼è¯†åˆ«
        function identifyMemoryPattern(memoryValues) {
            const trend = calculateTrend(memoryValues);
            const volatility = calculateVolatility(memoryValues);
            
            if (Math.abs(trend) < 1 && volatility < 5) return 'stable';
            if (trend > 5) return 'increasing';
            if (trend < -5) return 'decreasing';
            if (volatility > 15) return 'volatile';
            return 'normal';
        }
        
        // å†…å­˜å¼‚å¸¸æ£€æµ‹
        function detectMemoryAnomalies(historyWindow) {
            if (historyWindow.length < 10) return [];
            
            const memoryValues = historyWindow.map(h => h.memory);
            const mean = memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length;
            const stdDev = Math.sqrt(memoryValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / memoryValues.length);
            
            if (stdDev === 0) return [];
            
            const threshold = professionalMemoryLeakDetection.detection.anomalyThreshold;
            const anomalies = [];
            
            memoryValues.forEach((value, index) => {
                const zScore = Math.abs((value - mean) / stdDev);
                if (zScore > threshold) {
                    anomalies.push({
                        index: index,
                        value: value,
                        zScore: zScore,
                        severity: zScore > 3 ? 'high' : 'medium'
                    });
                }
            });
            
            return anomalies;
        }
        
        // é•¿æœŸå†…å­˜å¢é•¿åˆ†æ
        function analyzeLongTermMemoryGrowth(fullHistory) {
            if (fullHistory.length < 50) return { growth: 0, significance: 'low' };
            
            const segments = Math.min(5, Math.floor(fullHistory.length / 20));
            const segmentSize = Math.floor(fullHistory.length / segments);
            const segmentAverages = [];
            
            for (let i = 0; i < segments; i++) {
                const start = i * segmentSize;
                const end = start + segmentSize;
                const segment = fullHistory.slice(start, end);
                const average = segment.reduce((sum, h) => sum + h.memory, 0) / segment.length;
                segmentAverages.push(average);
            }
            
            const overallGrowth = segmentAverages[segmentAverages.length - 1] - segmentAverages[0];
            const growthRate = overallGrowth / segmentAverages.length;
            
            return {
                growth: overallGrowth,
                growthRate: growthRate,
                significance: Math.abs(growthRate) > 5 ? 'high' : 'low',
                segmentAverages: segmentAverages
            };
        }
        
        // ç»¼åˆè¯„ä¼°æ³„æ¼çŠ¶æ€
        function evaluateOverallLeakStatus(trendAnalysis, anomalies, longTermGrowth) {
            const status = professionalMemoryLeakDetection.status;
            let leakScore = 0;
            const leakSources = [];
            
            // è¶‹åŠ¿åˆ†æè¯„åˆ†
            if (trendAnalysis.slope > 2 && trendAnalysis.confidence > 0.7) {
                leakScore += 30;
                leakSources.push(`æŒç»­å†…å­˜å¢é•¿è¶‹åŠ¿ (${trendAnalysis.slope.toFixed(2)} MB/æ ·æœ¬)`);
            }
            
            // å¼‚å¸¸æ£€æµ‹è¯„åˆ†
            if (anomalies.length > 0) {
                leakScore += Math.min(25, anomalies.length * 5);
                leakSources.push(`æ£€æµ‹åˆ° ${anomalies.length} ä¸ªå†…å­˜å¼‚å¸¸å³°å€¼`);
            }
            
            // é•¿æœŸå¢é•¿è¯„åˆ†
            if (longTermGrowth.significance === 'high' && longTermGrowth.growth > 30) {
                leakScore += 25;
                leakSources.push(`é•¿æœŸå†…å­˜å¢é•¿ ${longTermGrowth.growth.toFixed(1)} MB`);
            }
            
            // åœºæ™¯åˆ‡æ¢å¼‚å¸¸è¯„åˆ†
            if (status.suspiciousTransitions.length > 0) {
                leakScore += Math.min(20, status.suspiciousTransitions.length * 4);
                leakSources.push(`åœºæ™¯åˆ‡æ¢å¼‚å¸¸ ${status.suspiciousTransitions.length} æ¬¡`);
            }
            
            // ç¡®å®šæ³„æ¼ç­‰çº§
            let leakLevel = 'none';
            if (leakScore >= 70) leakLevel = 'severe';
            else if (leakScore >= 45) leakLevel = 'moderate';
            else if (leakScore >= 20) leakLevel = 'mild';
            
            // æ›´æ–°çŠ¶æ€
            const wasLeaking = status.isLeaking;
            status.isLeaking = leakLevel !== 'none';
            status.leakLevel = leakLevel;
            status.leakSources = leakSources;
            
            // å¦‚æœçŠ¶æ€æ”¹å˜ï¼Œè§¦å‘è­¦å‘Š
            if (status.isLeaking && !wasLeaking) {
                showProfessionalMemoryLeakWarning(leakLevel, leakSources, leakScore);
            } else if (!status.isLeaking && wasLeaking) {
                hideProfessionalMemoryLeakWarning();
            }
        }
        
        // æ›´æ–°ä¸“ä¸šçº§å†…å­˜æ³„æ¼UIæ˜¾ç¤º
        function updateProfessionalMemoryLeakUI() {
            const status = professionalMemoryLeakDetection.status;
            const stateMachine = professionalMemoryLeakDetection.sceneStateMachine;
            const statistics = professionalMemoryLeakDetection.statistics;
            
            // æ›´æ–°æ£€æµ‹çŠ¶æ€
            const leakStatusEl = document.getElementById('leakStatus');
            const memoryTrendEl = document.getElementById('memoryTrend');
            const leakRateEl = document.getElementById('leakRate');
            
            if (leakStatusEl) {
                if (status.isLeaking) {
                    const levelText = status.leakLevel === 'severe' ? 'ğŸ”´ ä¸¥é‡æ³„æ¼' : 
                                     status.leakLevel === 'moderate' ? 'ğŸŸ  ä¸­åº¦æ³„æ¼' : 'ğŸŸ¡ è½»å¾®æ³„æ¼';
                    leakStatusEl.textContent = levelText;
                } else {
                    leakStatusEl.textContent = 'âœ… æ­£å¸¸';
                }
            }
            
            if (memoryTrendEl) {
                const sceneName = professionalMemoryLeakDetection.sceneProfiles[stateMachine.currentScene]?.name || stateMachine.currentScene;
                memoryTrendEl.textContent = `å½“å‰åœºæ™¯: ${sceneName}`;
            }
            
            if (leakRateEl) {
                leakRateEl.textContent = `å¹³å‡å›æ”¶ç‡: ${(statistics.averageRecoveryRate * 100).toFixed(1)}%`;
            }
        }
        
        // ä¸“ä¸šçº§æ³„æ¼è­¦å‘Šæ˜¾ç¤º
        function showProfessionalMemoryLeakWarning(leakLevel, leakSources, leakScore) {
            const warningEl = document.getElementById('leakWarning');
            const detailsEl = document.getElementById('leakDetails');
            
            if (detailsEl) {
                const severityText = leakLevel === 'severe' ? 'ğŸ”´ ä¸¥é‡' : leakLevel === 'moderate' ? 'ğŸŸ  ä¸­åº¦' : 'ğŸŸ¡ è½»å¾®';
                
                detailsEl.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <strong>${severityText} å†…å­˜æ³„æ¼æ£€æµ‹ (è¯„åˆ†: ${leakScore})</strong>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <strong>æ£€æµ‹æº:</strong>
                        ${leakSources.map(source => `<div style="margin-left: 10px;">â€¢ ${source}</div>`).join('')}
                    </div>
                    <div style="font-size: 12px; color: #666; margin-top: 8px;">
                        ğŸ¯ <strong>ä¸“ä¸šçº§æ£€æµ‹æ–¹æ³•:</strong><br>
                        â€¢ åœºæ™¯åˆ‡æ¢å†…å­˜å›æ”¶ç‡åˆ†æ<br>
                        â€¢ ç»Ÿè®¡å­¦å¼‚å¸¸æ£€æµ‹ (Z-Score)<br>
                        â€¢ çº¿æ€§å›å½’è¶‹åŠ¿åˆ†æ<br>
                        â€¢ é•¿æœŸå†…å­˜å¢é•¿æ¨¡å¼è¯†åˆ«
                    </div>
                `;
            }
            
            if (warningEl) {
                warningEl.style.display = 'block';
                warningEl.classList.add('active');
            }
            
            console.log(`ğŸš¨ ä¸“ä¸šçº§å†…å­˜æ³„æ¼æ£€æµ‹: ${leakLevel}, è¯„åˆ†: ${leakScore}, æº: ${leakSources.join(', ')}`);
        }
        
        // éšè—ä¸“ä¸šçº§æ³„æ¼è­¦å‘Š
        function hideProfessionalMemoryLeakWarning() {
            const warningEl = document.getElementById('leakWarning');
            if (warningEl) {
                warningEl.style.display = 'none';
                warningEl.classList.remove('active');
            }
        }
        
        // å…¼å®¹æ—§ç³»ç»Ÿçš„å†…å­˜æ³„æ¼UIæ›´æ–°
        function updateLegacyMemoryLeakUI(currentMemory) {
            const now = Date.now();
            memoryLeakDetection.memoryHistory.push({
                time: now,
                memory: currentMemory
            });
            
            // ä¿æŒæ£€æµ‹çª—å£å¤§å°
            const windowStart = now - memoryLeakDetection.detectionWindow;
            memoryLeakDetection.memoryHistory = memoryLeakDetection.memoryHistory.filter(
                item => item.time >= windowStart
            );
            
            // ä½¿ç”¨ä¸“ä¸šæ£€æµ‹ç»“æœæ›´æ–°æ—§ç³»ç»ŸçŠ¶æ€
            memoryLeakDetection.isLeaking = professionalMemoryLeakDetection.status.isLeaking;
            
            // å¦‚æœæ²¡æœ‰ä¸“ä¸šçº§è­¦å‘Šæ˜¾ç¤ºï¼Œä½¿ç”¨æ—§çš„ç®€å•æ˜¾ç¤º
            if (!professionalMemoryLeakDetection.status.isLeaking && memoryLeakDetection.memoryHistory.length >= 10) {
                const timeSpan = (now - memoryLeakDetection.memoryHistory[0].time) / 60000;
                const memoryIncrease = currentMemory - memoryLeakDetection.memoryHistory[0].memory;
                const growthRate = memoryIncrease / timeSpan;
                
                const leakRateEl = document.getElementById('leakRate');
                if (leakRateEl && !professionalMemoryLeakDetection.status.isLeaking) {
                    leakRateEl.textContent = `å¢é•¿ç‡: ${growthRate.toFixed(2)} MB/min`;
                }
            }
        }
        
        // ================== æµ‹è¯•åœºæ™¯è‡ªåŠ¨åŒ–åŠŸèƒ½ ==================
        
        // å¯åŠ¨æµ‹è¯•åœºæ™¯
        function startTestScenario() {
            const scenarioType = document.getElementById('scenarioType').value;
            const udid = document.getElementById('udid').value;
            const bundleId = document.getElementById('bundleId').value;
            
            console.log(`ğŸ§ª å¯åŠ¨æµ‹è¯•åœºæ™¯: ${scenarioType}`);
            
            // æ˜¾ç¤ºçŠ¶æ€é¢æ¿
            const statusPanel = document.getElementById('scenarioStatus');
            const resultsPanel = document.getElementById('scenarioResults');
            statusPanel.style.display = 'block';
            resultsPanel.style.display = 'block';
            
            // æ›´æ–°çŠ¶æ€
            updateScenarioStatus('ğŸ”„', 'æ­£åœ¨å¯åŠ¨æµ‹è¯•...', 0);
            clearScenarioLog();
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('startScenarioBtn').disabled = true;
            document.getElementById('stopScenarioBtn').disabled = false;
            
            // å‘é€å¯åŠ¨è¯·æ±‚åˆ°åç«¯
            socket.emit('start_test_scenario', {
                scenario_type: scenarioType,
                udid: udid,
                bundle_id: bundleId
            });
            
            addScenarioLog(`ğŸ“‹ å¼€å§‹æ‰§è¡Œæµ‹è¯•åœºæ™¯: ${getScenarioDisplayName(scenarioType)}`);
        }
        
        // åœæ­¢æµ‹è¯•åœºæ™¯
        function stopTestScenario() {
            console.log('â¹ï¸ åœæ­¢æµ‹è¯•åœºæ™¯');
            
            // å‘é€åœæ­¢è¯·æ±‚åˆ°åç«¯
            socket.emit('stop_test_scenario');
            
            // æ›´æ–°çŠ¶æ€
            updateScenarioStatus('â¹ï¸', 'æ­£åœ¨åœæ­¢æµ‹è¯•...', 0);
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('startScenarioBtn').disabled = false;
            document.getElementById('stopScenarioBtn').disabled = true;
            
            addScenarioLog('â¹ï¸ ç”¨æˆ·æ‰‹åŠ¨åœæ­¢æµ‹è¯•');
        }
        
        // æ›´æ–°æµ‹è¯•åœºæ™¯çŠ¶æ€
        function updateScenarioStatus(icon, text, progress) {
            document.getElementById('scenarioStatusIcon').textContent = icon;
            document.getElementById('scenarioStatusText').textContent = text;
            document.getElementById('scenarioProgress').style.width = progress + '%';
        }
        
        // æ·»åŠ æµ‹è¯•æ—¥å¿—
        function addScenarioLog(message) {
            const logContainer = document.getElementById('scenarioLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // æ¸…ç©ºæµ‹è¯•æ—¥å¿—
        function clearScenarioLog() {
            document.getElementById('scenarioLog').innerHTML = '';
        }
        
        // è·å–åœºæ™¯æ˜¾ç¤ºåç§°
        function getScenarioDisplayName(scenarioType) {
            const names = {
                'app_launch': 'åº”ç”¨å¯åŠ¨æµ‹è¯•',
                'memory_stress': 'å†…å­˜å‹åŠ›æµ‹è¯•', 
                'ui_interaction': 'ç•Œé¢äº¤äº’æµ‹è¯•',
                'background_switch': 'åå°åˆ‡æ¢æµ‹è¯•'
            };
            return names[scenarioType] || scenarioType;
        }
        
        // ================== Socket.IO æµ‹è¯•åœºæ™¯äº‹ä»¶å¤„ç† ==================
        
        // æµ‹è¯•åœºæ™¯å¯åŠ¨æˆåŠŸ
        socket.on('scenario_started', function(data) {
            console.log('âœ… æµ‹è¯•åœºæ™¯å¯åŠ¨æˆåŠŸ:', data);
            updateScenarioStatus('âœ…', 'æµ‹è¯•åœºæ™¯å·²å¯åŠ¨', 10);
            addScenarioLog(`âœ… æµ‹è¯•åœºæ™¯å¯åŠ¨æˆåŠŸ: ${getScenarioDisplayName(data.type)}`);
        });
        
        // æµ‹è¯•åœºæ™¯åœæ­¢
        socket.on('scenario_stopped', function(data) {
            console.log('â¹ï¸ æµ‹è¯•åœºæ™¯å·²åœæ­¢:', data);
            updateScenarioStatus('â¹ï¸', 'æµ‹è¯•å·²åœæ­¢', 0);
            addScenarioLog('â¹ï¸ æµ‹è¯•åœºæ™¯å·²åœæ­¢');
            
            // æ¢å¤æŒ‰é’®çŠ¶æ€
            document.getElementById('startScenarioBtn').disabled = false;
            document.getElementById('stopScenarioBtn').disabled = true;
        });
        
        // æµ‹è¯•åœºæ™¯é”™è¯¯
        socket.on('scenario_error', function(data) {
            console.error('âŒ æµ‹è¯•åœºæ™¯é”™è¯¯:', data);
            updateScenarioStatus('âŒ', `é”™è¯¯: ${data.message}`, 0);
            addScenarioLog(`âŒ é”™è¯¯: ${data.message}`);
            
            // æ¢å¤æŒ‰é’®çŠ¶æ€
            document.getElementById('startScenarioBtn').disabled = false;
            document.getElementById('stopScenarioBtn').disabled = true;
        });
        
        // æµ‹è¯•åœºæ™¯äº‹ä»¶ï¼ˆå®æ—¶æ›´æ–°ï¼‰
        socket.on('scenario_event', function(data) {
            console.log('ğŸ“Š æµ‹è¯•åœºæ™¯äº‹ä»¶:', data);
            
            switch(data.type) {
                case 'test_start':
                    updateScenarioStatus('ğŸš€', data.message, 20);
                    addScenarioLog(`ğŸš€ ${data.message}`);
                    break;
                case 'progress':
                    updateScenarioStatus('ğŸ”„', data.message, data.progress || 50);
                    addScenarioLog(`ğŸ”„ ${data.message}`);
                    break;
                case 'launch_result':
                    addScenarioLog(`âš¡ ${data.message}`);
                    break;
                case 'manual_prompt':
                    updateScenarioStatus('ğŸ‘†', data.message, 50);
                    addScenarioLog(`ğŸ‘† ${data.message}`);
                    break;
                case 'manual_success':
                    addScenarioLog(`âœ… ${data.message}`);
                    break;
                case 'test_complete':
                    updateScenarioStatus('âœ…', data.message, 100);
                    addScenarioLog(`ğŸ‰ ${data.message}`);
                    
                    // 5ç§’åæ¢å¤æŒ‰é’®çŠ¶æ€
                    setTimeout(() => {
                        document.getElementById('startScenarioBtn').disabled = false;
                        document.getElementById('stopScenarioBtn').disabled = true;
                    }, 5000);
                    break;
                case 'error':
                    updateScenarioStatus('âŒ', data.message, 0);
                    addScenarioLog(`âŒ ${data.message}`);
                    
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    document.getElementById('startScenarioBtn').disabled = false;
                    document.getElementById('stopScenarioBtn').disabled = true;
                    break;
            }
        });
        
        // æµ‹è¯•æ ‡è®°äº‹ä»¶ï¼ˆåœ¨å›¾è¡¨ä¸Šæ·»åŠ æ ‡è®°ï¼‰
        socket.on('test_marker', function(data) {
            console.log('ğŸ·ï¸ æµ‹è¯•æ ‡è®°:', data);
            
            // åœ¨å›¾è¡¨ä¸Šæ·»åŠ æµ‹è¯•æ ‡è®°
            const timestamp = new Date().toLocaleTimeString();
            addScenarioLog(`ğŸ·ï¸ ${data.message} (${timestamp})`);
            
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ åœ¨å›¾è¡¨ä¸Šæ˜¾ç¤ºæ ‡è®°çš„é€»è¾‘
            // ä¾‹å¦‚åœ¨å½“å‰æ—¶é—´ç‚¹æ·»åŠ å‚ç›´çº¿æˆ–æ ‡è®°
        });
        
        // ç›‘æ§å¯åŠ¨æ—¶å¯ç”¨æµ‹è¯•åœºæ™¯æŒ‰é’®
        socket.on('monitoring_started', function(data) {
            if (data.status === 'success') {
                document.getElementById('startScenarioBtn').disabled = false;
                addScenarioLog('ğŸ“± æ€§èƒ½ç›‘æ§å·²å¯åŠ¨ï¼Œå¯ä»¥å¼€å§‹æµ‹è¯•åœºæ™¯');
            }
        });
        
        // ç›‘æ§åœæ­¢æ—¶ç¦ç”¨æµ‹è¯•åœºæ™¯æŒ‰é’®
        socket.on('monitoring_stopped', function(data) {
            document.getElementById('startScenarioBtn').disabled = true;
            document.getElementById('stopScenarioBtn').disabled = true;
            updateScenarioStatus('â¸ï¸', 'ç›‘æ§å·²åœæ­¢', 0);
            addScenarioLog('â¸ï¸ æ€§èƒ½ç›‘æ§å·²åœæ­¢ï¼Œæµ‹è¯•åœºæ™¯åŠŸèƒ½æš‚åœ');
        });
    </script>
</body>
</html>
