<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOSÊÄßËÉΩÁõëÊéßÂèØËßÜÂåñ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f7;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #1d1d1f;
            margin-bottom: 10px;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }
        .controls h3 {
            margin-top: 0;
            color: #1d1d1f;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #424245;
        }
        .form-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        .form-group input:focus {
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }
        .btn {
            background: #007aff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .btn:hover {
            background: #0056cc;
        }
        .btn:disabled {
            background: #d2d2d7;
            cursor: not-allowed;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .chart-container h3 {
            margin: 0 0 20px 0;
            color: #1d1d1f;
            font-size: 18px;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .current-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .value-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .value-card .label {
            font-size: 12px;
            color: #86868b;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        .value-card .value {
            font-size: 24px;
            font-weight: 600;
            color: #1d1d1f;
        }
        .hidden {
            display: none;
        }
        .scene-controls {
            background: #f0f8ff;
            border: 1px solid #007aff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .scene-controls h4 {
            margin: 0 0 10px 0;
            color: #007aff;
        }
        .scene-list {
            margin-top: 15px;
        }
        .scene-item {
            background: white;
            border: 1px solid #d2d2d7;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: between;
            align-items: center;
            font-size: 14px;
        }
        .scene-item .scene-info {
            flex: 1;
        }
        .scene-item .scene-time {
            color: #86868b;
            font-size: 12px;
        }
        .scene-item .scene-actions {
            margin-left: 10px;
        }
        .scene-item button {
            background: #ff3b30;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        .chart-selection-overlay {
            position: absolute;
            background: rgba(0, 122, 255, 0.2);
            border: 2px solid #007aff;
            pointer-events: none;
            display: none;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
            cursor: crosshair;
        }
        .selecting .chart-wrapper {
            cursor: crosshair;
        }
        .tag-controls {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .tag-controls h4 {
            margin: 0 0 10px 0;
            color: #856404;
        }
        .tag-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }
        .tag-item .tag-info {
            flex: 1;
        }
        .tag-item .tag-time {
            color: #6c757d;
            font-size: 12px;
        }
        .tag-item .tag-note {
            color: #495057;
            font-style: italic;
            margin-top: 3px;
        }
        .tag-item .tag-actions {
            margin-left: 10px;
        }
        .tag-item button {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
        }
        .chart-tag-marker {
            position: absolute;
            width: 2px;
            background: #ffc107;
            top: 0;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .chart-tag-marker::after {
            content: 'üè∑Ô∏è';
            position: absolute;
            top: -5px;
            left: -8px;
            font-size: 16px;
        }
        
        /* ÊÄßËÉΩÈòàÂÄºÂíåÂëäË≠¶Ê†∑Âºè */
        .alert-panel {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .alert-item {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 6px;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .alert-item.warning {
            background: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }
        .alert-item.critical {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
            animation: pulse 2s infinite;
        }
        
        /* ÊÄßËÉΩËØÑÂàÜÊ†∑Âºè */
        .score-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .score-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .score-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
        }
        .score-value {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .score-value.grade-a { color: #28a745; }
        .score-value.grade-b { color: #17a2b8; }
        .score-value.grade-c { color: #ffc107; }
        .score-value.grade-d { color: #fd7e14; }
        .score-value.grade-f { color: #dc3545; }
        .score-number {
            font-size: 12px;
            color: #888;
        }
        
        /* ÁªüËÆ°Èù¢ÊùøÊ†∑Âºè */
        .stat-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        .stat-current {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 8px;
        }
        .stat-details {
            font-size: 11px;
            color: #888;
            line-height: 1.4;
        }
        
        /* ÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµãÊ†∑Âºè */
        .leak-warning {
            background: #f8d7da;
            border: 2px solid #dc3545;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }
        .leak-warning.active {
            display: block;
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        /* ÊãñÊãΩÂäüËÉΩÊ†∑Âºè */
        .controls {
            position: relative;
            cursor: move;
            transition: transform 0.2s ease;
        }
        
        .controls:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        
        .controls.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        .controls h3 {
            user-select: none;
            position: relative;
        }
        
        .controls h3::before {
            content: '‚ãÆ‚ãÆ';
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
            font-size: 14px;
            line-height: 1;
        }
        
        .controls:hover h3::before {
            color: #666;
        }
        
        .drag-placeholder {
            height: 100px;
            background: linear-gradient(90deg, #e3f2fd, #f5f5f5);
            border: 2px dashed #2196f3;
            border-radius: 12px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #2196f3;
            font-weight: bold;
            opacity: 0.7;
        }
        
        .drag-placeholder::before {
            content: 'ÈáäÊîæÂà∞ËøôÈáå';
        }
        
        /* ÈáçÁΩÆÊåâÈíÆÊ†∑Âºè */
        .header .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .header .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .header small {
            opacity: 0.8;
            font-style: italic;
        }
        
        /* ÂàÜ‰∫´ÂØπËØùÊ°ÜÊ†∑Âºè */
        .share-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }
        
        .share-dialog-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }
        
        .share-url {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
            position: relative;
        }
        
        .copy-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
            transition: background 0.3s ease;
        }
        
        .copy-btn:hover {
            background: #218838;
        }
        
        .copy-btn.copied {
            background: #17a2b8;
        }
        
        .close-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
        }
        
        .close-btn:hover {
            background: #5a6268;
        }
        
        .share-tips {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            text-align: left;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .share-tips h4 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }
        
        .share-tips ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .share-tips li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì± iOSÊÄßËÉΩÁõëÊéßÂèØËßÜÂåñ</h1>
            <p>Âü∫‰∫éÂéüÂßãmain.pyÈÄªËæëÁöÑÂÆûÊó∂ÊÄßËÉΩÂõæË°®ÊòæÁ§∫</p>
            <div style="margin-top: 15px;">
                <button class="btn" onclick="resetPanelOrder()" title="ÊÅ¢Â§çÈù¢ÊùøÈªòËÆ§È°∫Â∫è">üîÑ ÈáçÁΩÆÈù¢ÊùøÈ°∫Â∫è</button>
                <button class="btn" onclick="showShareDialog()" title="Ëé∑ÂèñÂàÜ‰∫´ÈìæÊé•">üîó ÂàÜ‰∫´Êï∞ÊçÆ</button>
                <small style="margin-left: 10px; color: #666;">üí° ÊèêÁ§∫: ÁÇπÂáªÈù¢ÊùøÊ†áÈ¢òÂ∑¶‰æßÁöÑ ‚ãÆ‚ãÆ ÂõæÊ†áÂèØÊãñÊãΩË∞ÉÊï¥È°∫Â∫è</small>
            </div>
        </div>

        <div class="controls">
            <h3>üîß ÁõëÊéßÈÖçÁΩÆ</h3>
            <div class="form-group">
                <label for="udid">ËÆæÂ§áUDIDÔºàÂèØÈÄâÔºâ:</label>
                <input type="text" id="udid" value="00008020-000A09960121002E" placeholder="ÁïôÁ©∫‰ΩøÁî®ÈªòËÆ§ËÆæÂ§á">
            </div>
            <div class="form-group">
                <label for="bundleId">Â∫îÁî®Bundle ID:</label>
                <input type="text" id="bundleId" value="com.newleaf.app.ios.vic" placeholder="ÈªòËÆ§Â∫îÁî®">
            </div>
            <button class="btn" id="startBtn" onclick="startMonitoring()">ÂºÄÂßãÁõëÊéß</button>
            <button class="btn" id="stopBtn" onclick="stopMonitoring()" disabled>ÂÅúÊ≠¢ÁõëÊéß</button>
            <button class="btn" id="saveBtn" onclick="saveData()" disabled>‰øùÂ≠òÊï∞ÊçÆ</button>
            <button class="btn" id="importBtn" onclick="document.getElementById('fileInput').click()">ÂØºÂÖ•Êï∞ÊçÆ</button>
            <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="importData(event)">
        </div>

        <div id="status" class="status hidden"></div>

        <!-- Êó∂Èó¥ËåÉÂõ¥ÊéßÂà∂ -->
        <div class="controls" id="timeControls" style="display: none;">
            <h3>‚è∞ Êó∂Èó¥ËåÉÂõ¥ÊéßÂà∂</h3>
            <div style="display: flex; gap: 15px; align-items: center;">
                <div style="flex: 1;">
                    <label for="windowSize">ÊòæÁ§∫Á™óÂè£Â§ßÂ∞è:</label>
                    <input type="number" id="windowSize" min="10" max="500" value="50" step="10" oninput="updateWindowSize(this.value)" style="width: 80px; padding: 4px;">
                    <span id="windowSizeValue">50‰∏™ÁÇπ</span>
                </div>
                <div style="flex: 2;">
                    <label for="timeSlider">Êó∂Èó¥ËΩ¥ÊãñÂä®:</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="timeSlider" min="0" max="100" value="100" oninput="updateTimePosition(this.value)" style="flex: 1;">
                        <span id="timePosition">ÊúÄÊñ∞</span>
                        <button onclick="goToLatest()" style="padding: 4px 8px; background: #007aff; color: white; border: none; border-radius: 4px; font-size: 12px;">Ë∑≥Âà∞ÊúÄÊñ∞</button>
                    </div>
                </div>
                <div class="form-group" style="flex: 1; margin-bottom: 0;">
                    <label for="updateInterval">Êõ¥Êñ∞Èó¥ÈöîÔºàÊØ´ÁßíÔºâ:</label>
                    <input type="range" id="updateInterval" min="500" max="5000" value="1000" oninput="updateInterval(this.value)">
                    <span id="intervalValue">1000ms</span>
                </div>
            </div>
        </div>

        <!-- Âú∫ÊôØÊ†áËÆ∞ÊéßÂà∂ -->
        <div class="scene-controls" id="sceneControls" style="display: none;">
            <h4>üé¨ Âú∫ÊôØÊ†áËÆ∞</h4>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <button class="btn" id="startSelectionBtn" onclick="toggleSelection()">ÂºÄÂßãÈÄâÊã©Êó∂Èó¥Âå∫Âüü</button>
                <input type="text" id="sceneNameInput" placeholder="Âú∫ÊôØÂêçÁß∞" style="padding: 8px; border: 1px solid #d2d2d7; border-radius: 6px; width: 200px;">
                <button class="btn" id="saveSceneBtn" onclick="saveScene()" disabled>‰øùÂ≠òÂú∫ÊôØ</button>
                <button class="btn" id="clearScenesBtn" onclick="clearAllScenes()">Ê∏ÖÁ©∫ÊâÄÊúâÂú∫ÊôØ</button>
            </div>
            <div id="selectionStatus" style="font-size: 14px; color: #86868b; margin-bottom: 10px;"></div>
            <div class="scene-list" id="sceneList"></div>
        </div>

        <!-- ÂçïÁÇπÊ†áÁ≠æÊéßÂà∂ -->
        <div class="tag-controls" id="tagControls" style="display: none;">
            <h4>üè∑Ô∏è ÂçïÁÇπÊ†áÁ≠æ</h4>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <span style="font-size: 14px; color: #856404;">ÂèåÂáªÂõæË°®‰ªªÊÑè‰ΩçÁΩÆÊ∑ªÂä†Ê†áÁ≠æ</span>
                <button class="btn" id="clearTagsBtn" onclick="clearAllTags()">Ê∏ÖÁ©∫ÊâÄÊúâÊ†áÁ≠æ</button>
            </div>
            <div class="scene-list" id="tagList"></div>
        </div>

        <!-- ÊµãËØïÂú∫ÊôØËá™Âä®ÂåñÊéßÂà∂ -->
        <div class="controls" id="scenarioControls" style="display: none;">
            <h3>üß™ ÊµãËØïÂú∫ÊôØËá™Âä®Âåñ</h3>
            <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 15px; border-radius: 6px;">
                <div style="font-size: 14px; color: #1976d2; margin-bottom: 8px;">
                    <strong>üí° Êô∫ËÉΩÊµãËØïÂä©Êâã</strong>
                </div>
                <div style="font-size: 13px; color: #424242; line-height: 1.4;">
                    Âú®ÊÄßËÉΩÁõëÊéßËøêË°åÊó∂ÔºåÂèØ‰ª•ÂêØÂä®Ëá™Âä®ÂåñÊµãËØïÂú∫ÊôØÔºåÁ≥ªÁªüÂ∞ÜËá™Âä®ÊâßË°åÊµãËØïÊìç‰ΩúÂπ∂Âú®ÂõæË°®‰∏äÊ†áËÆ∞ÂÖ≥ÈîÆÊó∂Èó¥ÁÇπ
                </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label style="display: block; margin-bottom: 5px; font-weight: 500;">ÊµãËØïÂú∫ÊôØÁ±ªÂûã:</label>
                    <select id="scenarioType" style="width: 100%; padding: 8px; border: 1px solid #d2d2d7; border-radius: 6px;">
                        <option value="app_launch">Â∫îÁî®ÂêØÂä®ÊµãËØï</option>
                        <option value="memory_stress">ÂÜÖÂ≠òÂéãÂäõÊµãËØï</option>
                        <option value="ui_interaction">ÁïåÈù¢‰∫§‰∫íÊµãËØï</option>
                        <option value="background_switch">ÂêéÂè∞ÂàáÊç¢ÊµãËØï</option>
                    </select>
                </div>
                <div style="display: flex; align-items: end; gap: 10px;">
                    <button class="btn" id="startScenarioBtn" onclick="startTestScenario()" disabled>üöÄ ÂºÄÂßãÊµãËØï</button>
                    <button class="btn" id="stopScenarioBtn" onclick="stopTestScenario()" disabled style="background: #dc3545;">‚èπÔ∏è ÂÅúÊ≠¢ÊµãËØï</button>
                </div>
            </div>
            
            <!-- ÊµãËØïÁä∂ÊÄÅÂíåËøõÂ∫¶ÊòæÁ§∫ -->
            <div id="scenarioStatus" style="display: none; background: #f8f9fa; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span id="scenarioStatusIcon">üîÑ</span>
                    <span id="scenarioStatusText">ÂáÜÂ§á‰∏≠...</span>
                </div>
                <div style="background: #e9ecef; border-radius: 3px; height: 6px; overflow: hidden;">
                    <div id="scenarioProgress" style="background: #28a745; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>
            </div>
            
            <!-- ÊµãËØïÁªìÊûúÂíåÊó•Âøó -->
            <div id="scenarioResults" style="display: none;">
                <h4 style="margin: 15px 0 10px 0; color: #1d1d1f;">üìã ÊµãËØïÊó•Âøó</h4>
                <div id="scenarioLog" style="background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 10px; max-height: 200px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.4;"></div>
            </div>
        </div>

        <div class="current-values" id="currentValues" style="display: none;">
            <div class="value-card">
                <div class="label">CPU‰ΩøÁî®Áéá</div>
                <div class="value" id="currentCpu">0%</div>
            </div>
            <div class="value-card">
                <div class="label">ÂÜÖÂ≠ò‰ΩøÁî®</div>
                <div class="value" id="currentMemory">0MB</div>
            </div>
            <div class="value-card">
                <div class="label">Â∏ßÁéá</div>
                <div class="value" id="currentFps">0FPS</div>
            </div>
            <div class="value-card">
                <div class="label">Á∫øÁ®ãÊï∞</div>
                <div class="value" id="currentThreads">0</div>
            </div>
        </div>

        <div class="charts-grid" id="chartsGrid" style="display: none;">
            <div class="chart-container">
                <h3>üìä CPU‰ΩøÁî®Áéá</h3>
                <div class="chart-wrapper" data-chart="cpu">
                    <canvas id="cpuChart"></canvas>
                    <div class="chart-selection-overlay" id="cpuOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>üíæ ÂÜÖÂ≠ò‰ΩøÁî®Èáè</h3>
                <div class="chart-wrapper" data-chart="memory">
                    <canvas id="memoryChart"></canvas>
                    <div class="chart-selection-overlay" id="memoryOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>üéÆ Â∏ßÁéá(FPS)</h3>
                <div class="chart-wrapper" data-chart="fps">
                    <canvas id="fpsChart"></canvas>
                    <div class="chart-selection-overlay" id="fpsOverlay"></div>
                </div>
            </div>
            <div class="chart-container">
                <h3>üßµ Á∫øÁ®ãÊï∞Èáè</h3>
                <div class="chart-wrapper" data-chart="threads">
                    <canvas id="threadsChart"></canvas>
                    <div class="chart-selection-overlay" id="threadsOverlay"></div>
                </div>
            </div>
        </div>

        <!-- ÊÄßËÉΩÈòàÂÄºÊéßÂà∂Èù¢Êùø -->
        <div class="controls" id="thresholdControls">
            <h3>üö® ÊÄßËÉΩÈòàÂÄºÂëäË≠¶</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div>
                    <label>CPUÈòàÂÄº (%):</label>
                    <input type="number" id="cpuThreshold" value="80" min="0" max="100">
                </div>
                <div>
                    <label>ÂÜÖÂ≠òÈòàÂÄº (MB):</label>
                    <input type="number" id="memoryThreshold" value="200" min="0">
                </div>
                <div>
                    <label>FPSÊúÄ‰ΩéÂÄº:</label>
                    <input type="number" id="fpsThreshold" value="30" min="0" max="60">
                </div>
                <div>
                    <label>Á∫øÁ®ãÊï∞‰∏äÈôê:</label>
                    <input type="number" id="threadsThreshold" value="50" min="0">
                </div>
            </div>
            <div id="alertPanel" class="alert-panel" style="display: none;">
                <h4>‚ö†Ô∏è ÊÄßËÉΩÂëäË≠¶</h4>
                <div id="alertList"></div>
            </div>
        </div>

        <!-- ÊÄßËÉΩËØÑÂàÜÈù¢Êùø -->
        <div class="controls" id="scoringPanel">
            <h3>üìä ÂÆûÊó∂ÊÄßËÉΩËØÑÂàÜ</h3>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                <div class="score-item">
                    <div class="score-label">CPUËØÑÂàÜ</div>
                    <div class="score-value" id="cpuScore">A+</div>
                    <div class="score-number" id="cpuScoreNum">(95)</div>
                </div>
                <div class="score-item">
                    <div class="score-label">ÂÜÖÂ≠òËØÑÂàÜ</div>
                    <div class="score-value" id="memoryScore">A+</div>
                    <div class="score-number" id="memoryScoreNum">(95)</div>
                </div>
                <div class="score-item">
                    <div class="score-label">FPSËØÑÂàÜ</div>
                    <div class="score-value" id="fpsScore">A+</div>
                    <div class="score-number" id="fpsScoreNum">(95)</div>
                </div>
                <div class="score-item">
                    <div class="score-label">ÊÄª‰ΩìËØÑÂàÜ</div>
                    <div class="score-value" id="overallScore">A+</div>
                    <div class="score-number" id="overallScoreNum">(95)</div>
                </div>
            </div>
        </div>

        <!-- ÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµãÈù¢Êùø -->
        <div class="controls" id="memoryLeakPanel">
            <h3>üß† ÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµã</h3>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div class="stat-card">
                    <div class="stat-label">Ê£ÄÊµãÁä∂ÊÄÅ</div>
                    <div class="stat-value" id="leakStatus">Ê≠£Â∏∏</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ÂÜÖÂ≠òË∂ãÂäø</div>
                    <div class="stat-value" id="memoryTrend">Á®≥ÂÆö</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Â¢ûÈïøÁéá</div>
                    <div class="stat-value" id="leakRate">0 MB/min</div>
                </div>
            </div>
            <div class="leak-warning" id="leakWarning" style="display: none;">
                <h4>‚ö†Ô∏è Áñë‰ººÂÜÖÂ≠òÊ≥ÑÊºè</h4>
                <div id="leakDetails"></div>
            </div>
        </div>

        <!-- Êï∞ÊçÆÁªüËÆ°Èù¢Êùø -->
        <div class="controls" id="statisticsPanel">
            <h3>üìà Êï∞ÊçÆÁªüËÆ°</h3>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                <div class="stat-card">
                    <div class="stat-label">CPU‰ΩøÁî®Áéá</div>
                    <div class="stat-current" id="statCpuCurrent">0%</div>
                    <div class="stat-details">
                        Âπ≥Âùá: <span id="statCpuAvg">0%</span> | 
                        ÊúÄÂ§ß: <span id="statCpuMax">0%</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ÂÜÖÂ≠ò‰ΩøÁî®</div>
                    <div class="stat-current" id="statMemoryCurrent">0MB</div>
                    <div class="stat-details">
                        Âπ≥Âùá: <span id="statMemoryAvg">0MB</span> | 
                        ÊúÄÂ§ß: <span id="statMemoryMax">0MB</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Â∏ßÁéá</div>
                    <div class="stat-current" id="statFpsCurrent">0FPS</div>
                    <div class="stat-details">
                        Âπ≥Âùá: <span id="statFpsAvg">0FPS</span> | 
                        ÊúÄ‰Ωé: <span id="statFpsMin">0FPS</span>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Á∫øÁ®ãÊï∞</div>
                    <div class="stat-current" id="statThreadsCurrent">0</div>
                    <div class="stat-details">
                        Âπ≥Âùá: <span id="statThreadsAvg">0</span> | 
                        ÊúÄÂ§ß: <span id="statThreadsMax">0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ÂàÜ‰∫´ÂØπËØùÊ°Ü -->
    <div id="shareDialog" class="share-dialog">
        <div class="share-dialog-content">
            <h3>üîó ÂàÜ‰∫´ÂÆûÊó∂Êï∞ÊçÆ</h3>
            <p>Â∞Ü‰ª•‰∏ãÈìæÊé•ÂàÜ‰∫´ÁªôÂÖ∂‰ªñ‰∫∫Ôºå‰ªñ‰ª¨ÂèØ‰ª•ÂÆûÊó∂Êü•Áúã‰Ω†ÁöÑÊÄßËÉΩÁõëÊéßÊï∞ÊçÆÔºö</p>
            
            <div class="share-url" id="shareUrl">
                Ê≠£Âú®Ëé∑ÂèñÂàÜ‰∫´ÈìæÊé•...
            </div>
            
            <div>
                <button class="copy-btn" onclick="copyShareUrl()">üìã Â§çÂà∂ÈìæÊé•</button>
                <button class="close-btn" onclick="closeShareDialog()">ÂÖ≥Èó≠</button>
            </div>
            
            <div class="share-tips">
                <h4>üí° ‰ΩøÁî®ËØ¥ÊòéÔºö</h4>
                <ul>
                    <li>Á°Æ‰øùÂàÜ‰∫´ÂØπË±°‰∏é‰Ω†Âú®Âêå‰∏ÄÁΩëÁªúÁéØÂ¢É‰∏≠ÔºàÂ¶ÇÂêå‰∏ÄWiFiÔºâ</li>
                    <li>Â¶ÇÊûúÊó†Ê≥ïËÆøÈóÆÔºåÂèØËÉΩÈúÄË¶ÅÂÖ≥Èó≠Èò≤ÁÅ´Â¢ôÊàñÂÖÅËÆ∏Á´ØÂè£5001</li>
                    <li>ÂàÜ‰∫´ÁöÑÊòØÂÆûÊó∂Êï∞ÊçÆÔºå‰ªñ‰ª¨ËÉΩÁúãÂà∞‰Ω†ÂΩìÂâçÁöÑÊÄßËÉΩÁõëÊéßÁä∂ÊÄÅ</li>
                    <li>ÂÅúÊ≠¢ÁõëÊéßÂêéÔºåÂàÜ‰∫´ÁöÑÈ°µÈù¢‰πü‰ºöÂÅúÊ≠¢Êõ¥Êñ∞</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // WebSocketËøûÊé•
        const socket = io();
        
        // ÂõæË°®ÂÆû‰æã
        let cpuChart, memoryChart, fpsChart, threadsChart;
        
        // Êï∞ÊçÆÂ≠òÂÇ®
        let isMonitoring = false;
        let windowSize = 50; // ÊòæÁ§∫Á™óÂè£Â§ßÂ∞è
        let timePosition = 100; // Êó∂Èó¥‰ΩçÁΩÆÁôæÂàÜÊØîÔºå100Ë°®Á§∫ÊúÄÊñ∞
        let allPerformanceData = []; // Â≠òÂÇ®ÊâÄÊúâÊÄßËÉΩÊï∞ÊçÆÁî®‰∫é‰øùÂ≠ò
        
        // ÊÄßËÉΩÈòàÂÄºÈÖçÁΩÆ
        let thresholds = {
            cpu: 80,
            memory: 200,
            fps: 30,
            threads: 50
        };
        
        // ÊÄßËÉΩÁªüËÆ°Êï∞ÊçÆ
        let performanceStats = {
            cpu: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
            memory: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
            fps: { current: 0, avg: 0, min: Infinity, sum: 0, count: 0 },
            threads: { current: 0, avg: 0, max: 0, sum: 0, count: 0 }
        };
        
        // ‰∏ì‰∏öÁ∫ßÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµãÁ≥ªÁªü
        let professionalMemoryLeakDetection = {
            // Âú∫ÊôØÁä∂ÊÄÅÊú∫
            sceneStateMachine: {
                currentScene: 'unknown',
                previousScene: 'unknown',
                sceneHistory: [],
                sceneStartTime: null,
                sceneStartMemory: 0,
                sceneTransitionCount: 0
            },
            
            // Âú∫ÊôØÂÆö‰πâÂíåÂü∫Á∫ø
            sceneProfiles: {
                'idle': { 
                    name: 'Á©∫Èó≤Áä∂ÊÄÅ', 
                    expectedMemory: { min: 80, max: 150 }, 
                    color: '#4CAF50',
                    priority: 1 
                },
                'launching': { 
                    name: 'Â∫îÁî®ÂêØÂä®', 
                    expectedMemory: { min: 120, max: 200 }, 
                    color: '#FF9800',
                    priority: 3 
                },
                'video_playing': { 
                    name: 'ËßÜÈ¢ëÊí≠Êîæ', 
                    expectedMemory: { min: 200, max: 400 }, 
                    color: '#F44336',
                    priority: 4 
                },
                'navigation': { 
                    name: 'ÁïåÈù¢ÂØºËà™', 
                    expectedMemory: { min: 100, max: 180 }, 
                    color: '#2196F3',
                    priority: 2 
                },
                'background': { 
                    name: 'ÂêéÂè∞ËøêË°å', 
                    expectedMemory: { min: 60, max: 120 }, 
                    color: '#9C27B0',
                    priority: 1 
                }
            },
            
            // ÂÜÖÂ≠òÂéÜÂè≤Êï∞ÊçÆ
            memoryHistory: [],
            maxHistoryLength: 200,
            
            // Ê£ÄÊµãÂèÇÊï∞
            detection: {
                minSampleSize: 15,              // ÊúÄÂ∞èÊ†∑Êú¨Êï∞Èáè
                sceneMinDuration: 10000,        // Âú∫ÊôØÊúÄÂ∞èÊåÅÁª≠Êó∂Èó¥ (10Áßí)
                leakThreshold: 0.85,            // ÂÜÖÂ≠òÂõûÊî∂ÁéáÈòàÂÄº (85%)
                anomalyThreshold: 2.5,          // ÂºÇÂ∏∏Ê£ÄÊµãÊ†áÂáÜÂ∑ÆÂÄçÊï∞
                trendAnalysisWindow: 30,        // Ë∂ãÂäøÂàÜÊûêÁ™óÂè£Â§ßÂ∞è
                gcDetectionThreshold: 15        // GCÊ£ÄÊµãÈòàÂÄº (MB)
            },
            
            // Ê£ÄÊµãÁä∂ÊÄÅ
            status: {
                isLeaking: false,
                leakLevel: 'none',              // none, mild, moderate, severe
                leakSources: [],
                lastGCTime: null,
                gcFrequency: 0,
                suspiciousTransitions: []
            },
            
            // ÁªüËÆ°Êï∞ÊçÆ
            statistics: {
                totalLeaksDetected: 0,
                falsePositiveRate: 0,
                averageRecoveryRate: 0,
                sceneTransitionMatrix: {}
            }
        };
        
        // ÂÖºÂÆπÊóßÁ≥ªÁªü
        let memoryLeakDetection = {
            memoryHistory: [],
            leakThreshold: 2,
            detectionWindow: 300000,
            isLeaking: false
        };
        
        // Ê¥ªË∑ÉÂëäË≠¶ÂàóË°®
        let activeAlerts = [];
        let allTimeLabels = []; // Â≠òÂÇ®ÊâÄÊúâÊó∂Èó¥Ê†áÁ≠æ
        let allCpuData = []; // Â≠òÂÇ®ÊâÄÊúâCPUÊï∞ÊçÆ
        let allMemoryData = []; // Â≠òÂÇ®ÊâÄÊúâÂÜÖÂ≠òÊï∞ÊçÆ
        let allFpsData = []; // Â≠òÂÇ®ÊâÄÊúâFPSÊï∞ÊçÆ
        let allThreadsData = []; // Â≠òÂÇ®ÊâÄÊúâÁ∫øÁ®ãÊï∞ÊçÆ
        let currentUpdateInterval = 1000; // ÂΩìÂâçÊõ¥Êñ∞Èó¥Èöî
        let isFollowingLatest = true; // ÊòØÂê¶Ë∑üÈöèÊúÄÊñ∞Êï∞ÊçÆ
        
        // Âú∫ÊôØÈÄâÊã©Áõ∏ÂÖ≥ÂèòÈáè
        let isSelecting = false;
        let selectionStart = null;
        let selectionEnd = null;
        let currentSelection = null;
        let savedScenes = []; // ‰øùÂ≠òÁöÑÂú∫ÊôØÂàóË°®
        let isMouseDown = false;
        let selectionStartX = 0;
        
        // Ê†áÁ≠æÁõ∏ÂÖ≥ÂèòÈáè
        let savedTags = []; // ‰øùÂ≠òÁöÑÊ†áÁ≠æÂàóË°®
        
        // ÂõæË°®ÈÖçÁΩÆ
        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: 'Êó∂Èó¥'
                    }
                },
                y: {
                    display: true,
                    beginAtZero: true
                }
            },
            elements: {
                line: {
                    tension: 0.4
                },
                point: {
                    radius: 3
                }
            }
        };

        // ÂàùÂßãÂåñÂõæË°®
        function initCharts() {
            const cpuCtx = document.getElementById('cpuChart').getContext('2d');
            cpuChart = new Chart(cpuCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'CPU‰ΩøÁî®Áéá (%)',
                        data: [],
                        borderColor: '#ff3b30',
                        backgroundColor: 'rgba(255, 59, 48, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'CPU‰ΩøÁî®Áéá (%)'
                            }
                        }
                    }
                }
            });

            const memoryCtx = document.getElementById('memoryChart').getContext('2d');
            memoryChart = new Chart(memoryCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'ÂÜÖÂ≠ò‰ΩøÁî® (MB)',
                        data: [],
                        borderColor: '#007aff',
                        backgroundColor: 'rgba(0, 122, 255, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'ÂÜÖÂ≠ò‰ΩøÁî® (MB)'
                            }
                        }
                    }
                }
            });

            const fpsCtx = document.getElementById('fpsChart').getContext('2d');
            fpsChart = new Chart(fpsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Â∏ßÁéá (FPS)',
                        data: [],
                        borderColor: '#34c759',
                        backgroundColor: 'rgba(52, 199, 89, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Â∏ßÁéá (FPS)'
                            },
                            max: 60
                        }
                    }
                }
            });

            const threadsCtx = document.getElementById('threadsChart').getContext('2d');
            threadsChart = new Chart(threadsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Á∫øÁ®ãÊï∞Èáè',
                        data: [],
                        borderColor: '#ff9500',
                        backgroundColor: 'rgba(255, 149, 0, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Á∫øÁ®ãÊï∞Èáè'
                            }
                        }
                    }
                }
            });
        }

        // Ê∑ªÂä†Êï∞ÊçÆÂà∞ÂõæË°®
        function addDataToChart(chart, label, data) {
            // Â≠òÂÇ®Âà∞ÂÖ®Â±ÄÊï∞ÁªÑ
            if (chart === cpuChart) {
                allTimeLabels.push(label);
                allCpuData.push(data);
            } else if (chart === memoryChart) {
                allMemoryData.push(data);
            } else if (chart === fpsChart) {
                allFpsData.push(data);
            } else if (chart === threadsChart) {
                allThreadsData.push(data);
            }
            
            // Â¶ÇÊûúÊ≠£Âú®Ë∑üÈöèÊúÄÊñ∞Êï∞ÊçÆÔºåÊõ¥Êñ∞ÊòæÁ§∫
            if (isFollowingLatest) {
                updateChartDisplay();
            }
            
            // Êõ¥Êñ∞Ê†áÁ≠æ‰ΩçÁΩÆÔºà‰ªÖÂú®CPUÂõæË°®Êõ¥Êñ∞Êó∂ÊâßË°åÔºåÈÅøÂÖçÈáçÂ§çÔºâ
            if (chart === cpuChart && savedTags.length > 0) {
                updateAllTagMarkers();
                updateTagList(); // Êõ¥Êñ∞Ê†áÁ≠æÂàóË°®Áä∂ÊÄÅ
            }
        }

        // ÊòæÁ§∫Áä∂ÊÄÅÊ∂àÊÅØ
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.classList.remove('hidden');
        }

        // ÈöêËóèÁä∂ÊÄÅÊ∂àÊÅØ
        function hideStatus() {
            document.getElementById('status').classList.add('hidden');
        }

        // Á™óÂè£Â§ßÂ∞èÂíåÊó∂Èó¥‰ΩçÁΩÆÊéßÂà∂ÂáΩÊï∞
        function updateWindowSize(value) {
            windowSize = parseInt(value);
            document.getElementById('windowSizeValue').textContent = windowSize + '‰∏™ÁÇπ';
            updateChartDisplay();
        }

        function updateTimePosition(value) {
            timePosition = parseInt(value);
            isFollowingLatest = (timePosition === 100);
            
            if (isFollowingLatest) {
                document.getElementById('timePosition').textContent = 'ÊúÄÊñ∞';
            } else {
                const totalData = allTimeLabels.length;
                const endIndex = Math.floor((timePosition / 100) * totalData);
                const startIndex = Math.max(0, endIndex - windowSize);
                document.getElementById('timePosition').textContent = `${startIndex}-${endIndex}`;
            }
            
            updateChartDisplay();
        }

        function goToLatest() {
            timePosition = 100;
            isFollowingLatest = true;
            document.getElementById('timeSlider').value = 100;
            document.getElementById('timePosition').textContent = 'ÊúÄÊñ∞';
            updateChartDisplay();
        }

        function updateChartDisplay() {
            if (allTimeLabels.length === 0) return;

            let startIndex, endIndex;
            
            if (isFollowingLatest) {
                // Ë∑üÈöèÊúÄÊñ∞Êï∞ÊçÆ
                endIndex = allTimeLabels.length;
                startIndex = Math.max(0, endIndex - windowSize);
            } else {
                // Ê†πÊçÆÊó∂Èó¥‰ΩçÁΩÆËÆ°ÁÆóÊòæÁ§∫ËåÉÂõ¥
                const totalData = allTimeLabels.length;
                endIndex = Math.floor((timePosition / 100) * totalData);
                startIndex = Math.max(0, endIndex - windowSize);
                endIndex = Math.min(totalData, startIndex + windowSize);
            }

            // Êõ¥Êñ∞ÊâÄÊúâÂõæË°®ÁöÑÊòæÁ§∫Êï∞ÊçÆ
            updateChartData(cpuChart, allTimeLabels.slice(startIndex, endIndex), allCpuData.slice(startIndex, endIndex));
            updateChartData(memoryChart, allTimeLabels.slice(startIndex, endIndex), allMemoryData.slice(startIndex, endIndex));
            updateChartData(fpsChart, allTimeLabels.slice(startIndex, endIndex), allFpsData.slice(startIndex, endIndex));
            updateChartData(threadsChart, allTimeLabels.slice(startIndex, endIndex), allThreadsData.slice(startIndex, endIndex));

            // Êõ¥Êñ∞ÊãñÂä®Êù°ÁöÑËåÉÂõ¥
            if (allTimeLabels.length > windowSize) {
                const maxSliderValue = Math.floor(((allTimeLabels.length - windowSize) / allTimeLabels.length) * 100);
                document.getElementById('timeSlider').max = 100;
                if (!isFollowingLatest && timePosition > maxSliderValue) {
                    timePosition = maxSliderValue;
                    document.getElementById('timeSlider').value = timePosition;
                }
            }
            
            // Êõ¥Êñ∞Ê†áÁ≠æ‰ΩçÁΩÆ
            updateAllTagMarkers();
        }

        function updateChartData(chart, labels, data) {
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update('none');
        }

        function updateInterval(value) {
            currentUpdateInterval = parseInt(value);
            document.getElementById('intervalValue').textContent = value + 'ms';
        }

        // Ê†áÁ≠æÂäüËÉΩ
        function enableDoubleClickTags() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('dblclick', onDoubleClickTag);
            });
        }

        function onDoubleClickTag(e) {
            if (isSelecting) return; // ÈÄâÊã©Ê®°Âºè‰∏ã‰∏çÊ∑ªÂä†Ê†áÁ≠æ
            
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // ËÆ°ÁÆóÊó∂Èó¥Á¥¢Âºï
            const clickIndex = Math.floor((clickX / chartWidth) * (cpuChart.data.labels.length));
            const timeLabel = cpuChart.data.labels[clickIndex];
            
            if (timeLabel) {
                // ÂºπÂá∫ËæìÂÖ•Ê°ÜËÆ©Áî®Êà∑ËæìÂÖ•Ê†áÁ≠æÂÜÖÂÆπ
                const tagNote = prompt('ËØ∑ËæìÂÖ•Ê†áÁ≠æÂ§áÊ≥®:', '');
                if (tagNote !== null && tagNote.trim() !== '') {
                    addTag(timeLabel, tagNote.trim(), clickX, chartWidth);
                }
            }
        }

        function addTag(timeLabel, note, clickX, chartWidth) {
            const tag = {
                id: Date.now(),
                time: timeLabel,
                note: note,
                createdAt: new Date().toISOString()
            };

            savedTags.push(tag);
            updateTagList();
            
            // Âú®ÊâÄÊúâÂõæË°®‰∏äÊ∑ªÂä†Ê†áÁ≠æÊ†áËÆ∞
            addTagMarkersToAllCharts(tag);
            
            showStatus(`Ê†áÁ≠æ "${note}" Â∑≤Ê∑ªÂä†Âà∞ ${timeLabel}`, 'success');
        }

        function addTagMarkersToAllCharts(tag) {
            // ‰∏çÂú®ËøôÈáåÁõ¥Êé•Ê∑ªÂä†DOMÂÖÉÁ¥†ÔºåËÄåÊòØÂú®updateAllTagMarkers‰∏≠Áªü‰∏ÄÂ§ÑÁêÜ
            updateAllTagMarkers();
        }

        function updateAllTagMarkers() {
            // Âà†Èô§ÊâÄÊúâÁé∞ÊúâÁöÑÊ†áËÆ∞
            const existingMarkers = document.querySelectorAll('.chart-tag-marker');
            existingMarkers.forEach(marker => marker.remove());

            // ÈáçÊñ∞Ê∑ªÂä†ÊâÄÊúâÊ†áÁ≠æÊ†áËÆ∞
            if (cpuChart && cpuChart.data.labels.length > 0) {
                savedTags.forEach(tag => {
                    // ÊâæÂà∞Ê†áÁ≠æÊó∂Èó¥Âú®ÂΩìÂâçÂõæË°®‰∏≠ÁöÑ‰ΩçÁΩÆ
                    const timeIndex = cpuChart.data.labels.findIndex(label => label === tag.time);
                    if (timeIndex !== -1 && timeIndex >= 0 && timeIndex < cpuChart.data.labels.length) {
                        // Á°Æ‰øù‰ΩçÁΩÆÂú®0-100%ËåÉÂõ¥ÂÜÖ
                        const position = Math.max(0, Math.min(100, (timeIndex / Math.max(1, cpuChart.data.labels.length - 1)) * 100));
                        
                        const chartWrappers = document.querySelectorAll('.chart-wrapper');
                        chartWrappers.forEach(wrapper => {
                            const marker = document.createElement('div');
                            marker.className = 'chart-tag-marker';
                            marker.style.left = position + '%';
                            marker.title = `${tag.time}: ${tag.note}`;
                            marker.setAttribute('data-tag-id', tag.id);
                            wrapper.appendChild(marker);
                        });
                    }
                });
            }
        }

        function updateTagList() {
            const tagList = document.getElementById('tagList');
            tagList.innerHTML = '';
            
            savedTags.forEach(tag => {
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-item';
                
                // Ê£ÄÊü•Ê†áÁ≠æÊòØÂê¶Âú®ÂΩìÂâçÊó∂Èó¥Á™óÂè£ÂÜÖ
                const isVisible = cpuChart && cpuChart.data.labels.includes(tag.time);
                const statusText = isVisible ? '' : ' (Â∑≤ÁßªÂá∫Êó∂Èó¥Á™óÂè£)';
                const statusStyle = isVisible ? '' : 'opacity: 0.6; font-style: italic;';
                
                tagItem.innerHTML = `
                    <div class="tag-info" style="${statusStyle}">
                        <div class="tag-time">${tag.time}${statusText}</div>
                        <div class="tag-note">${tag.note}</div>
                    </div>
                    <div class="tag-actions">
                        <button onclick="deleteTag(${tag.id})">Âà†Èô§</button>
                    </div>
                `;
                tagList.appendChild(tagItem);
            });
        }

        function deleteTag(tagId) {
            savedTags = savedTags.filter(tag => tag.id !== tagId);
            updateTagList();
            
            // ÈáçÊñ∞Êõ¥Êñ∞ÊâÄÊúâÊ†áÁ≠æ‰ΩçÁΩÆ
            updateAllTagMarkers();
            
            showStatus('Ê†áÁ≠æÂ∑≤Âà†Èô§', 'info');
        }

        function clearAllTags() {
            if (savedTags.length === 0) return;
            if (confirm('Á°ÆËÆ§Ê∏ÖÁ©∫ÊâÄÊúâÊ†áÁ≠æÔºü')) {
                savedTags = [];
                updateTagList();
                
                // ÈáçÊñ∞Êõ¥Êñ∞Ê†áÁ≠æÔºà‰ºöÊ∏ÖÁ©∫ÊâÄÊúâÔºâ
                updateAllTagMarkers();
                
                showStatus('ÊâÄÊúâÊ†áÁ≠æÂ∑≤Ê∏ÖÁ©∫', 'info');
            }
        }

        // ‰øùÂ≠òÊï∞ÊçÆÂáΩÊï∞ÔºàË∞ÉÁî®Êñ∞ÁöÑÂåÖÂê´Âú∫ÊôØÁöÑ‰øùÂ≠òÂäüËÉΩÔºâ
        function saveData() {
            saveDataWithScenes();
        }

        // ÂØºÂÖ•Êï∞ÊçÆÂáΩÊï∞
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.data || !Array.isArray(importedData.data)) {
                        showStatus('Êó†ÊïàÁöÑÊï∞ÊçÆÊñá‰ª∂Ê†ºÂºè', 'error');
                        return;
                    }

                    // ÂÅúÊ≠¢ÂΩìÂâçÁõëÊéß
                    if (isMonitoring) {
                        stopMonitoring();
                    }

                    // Ê∏ÖÁ©∫Áé∞ÊúâÂõæË°®
                    clearAllCharts();
                    
                    // ÊòæÁ§∫ÂõæË°®Âå∫Âüü
                    document.getElementById('chartsGrid').style.display = 'grid';
                    document.getElementById('currentValues').style.display = 'grid';
                    document.getElementById('timeControls').style.display = 'block';
                    document.getElementById('sceneControls').style.display = 'block';
                    document.getElementById('tagControls').style.display = 'block';
                    document.getElementById('scenarioControls').style.display = 'block';
                    initCharts();
                    enableDoubleClickTags(); // ÂêØÁî®ÂèåÂáªÊ†áÁ≠æÂäüËÉΩ

                    // ÊÅ¢Â§çËÆæÁΩÆ
                    if (importedData.settings) {
                        if (importedData.settings.isUnlimited) {
                            setUnlimited();
                        } else if (importedData.settings.maxDataPoints) {
                            document.getElementById('timeRange').value = importedData.settings.maxDataPoints;
                            updateTimeRange(importedData.settings.maxDataPoints);
                        }
                    }

                    // ÊâπÈáèÊ∑ªÂä†ÂØºÂÖ•ÁöÑÊï∞ÊçÆ
                    let dataCount = 0;
                    importedData.data.forEach(item => {
                        // ÂÖºÂÆπ‰∏çÂêåÁöÑÊï∞ÊçÆÊ†ºÂºè
                        const timeValue = item.time || item.timestamp;
                        const hasPerformanceData = item.cpu !== undefined || item.memory !== undefined;
                        
                        if (hasPerformanceData || item.type === 'performance') {
                            // Á°Æ‰øùÊï∞ÊçÆÂÆåÊï¥ÊÄß
                            const cpu = item.cpu || 0;
                            const memory = item.memory || 0;
                            const threads = item.threads || 0;
                            const fps = item.fps || 0;
                            
                            addDataToChart(cpuChart, timeValue, cpu);
                            addDataToChart(memoryChart, timeValue, memory);
                            addDataToChart(threadsChart, timeValue, threads);
                            addDataToChart(fpsChart, timeValue, fps);
                            
                            // Êõ¥Êñ∞ÂΩìÂâçÂÄºÊòæÁ§∫
                            document.getElementById('currentCpu').textContent = `${cpu}%`;
                            document.getElementById('currentMemory').textContent = `${memory.toFixed(1)}MB`;
                            document.getElementById('currentThreads').textContent = threads;
                            document.getElementById('currentFps').textContent = `${fps}FPS`;
                            
                            // Êõ¥Êñ∞ÊÄßËÉΩÁªüËÆ°ÂàÜÊûê
                            updatePerformanceStats(cpu, memory, fps, threads);
                            
                            dataCount++;
                        }
                    });

                    // ÂØºÂÖ•Âú∫ÊôØÊï∞ÊçÆ
                    if (importedData.scenes && Array.isArray(importedData.scenes)) {
                        savedScenes = importedData.scenes;
                        updateSceneList();
                    }

                    // ÂØºÂÖ•Ê†áÁ≠æÊï∞ÊçÆ
                    if (importedData.tags && Array.isArray(importedData.tags)) {
                        savedTags = importedData.tags;
                        updateTagList();
                        // ÊÅ¢Â§çÊ†áÁ≠æÊ†áËÆ∞
                        updateAllTagMarkers();
                    }

                    let statusMessage = `ÊàêÂäüÂØºÂÖ• ${dataCount} Êù°ÊÄßËÉΩËÆ∞ÂΩï`;
                    if (importedData.scenes && importedData.scenes.length > 0) {
                        statusMessage += `Ôºå${importedData.scenes.length} ‰∏™Âú∫ÊôØ`;
                    }
                    if (importedData.tags && importedData.tags.length > 0) {
                        statusMessage += `Ôºå${importedData.tags.length} ‰∏™Ê†áÁ≠æ`;
                    }
                    statusMessage += `ÔºåÊù•Ëá™ ${importedData.timestamp}`;
                    showStatus(statusMessage, 'success');
                    
                    // Êõ¥Êñ∞ÊúÄÁªàÁöÑÊÄßËÉΩËØÑÂàÜ
                    updatePerformanceScores();
                    
                } catch (error) {
                    showStatus('Êñá‰ª∂Ëß£ÊûêÂ§±Ë¥•: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
            
            // Ê∏ÖÁ©∫file input
            event.target.value = '';
        }

        function clearAllCharts() {
            if (cpuChart) {
                cpuChart.data.labels = [];
                cpuChart.data.datasets[0].data = [];
                cpuChart.update();
                
                memoryChart.data.labels = [];
                memoryChart.data.datasets[0].data = [];
                memoryChart.update();
                
                fpsChart.data.labels = [];
                fpsChart.data.datasets[0].data = [];
                fpsChart.update();
                
                threadsChart.data.labels = [];
                threadsChart.data.datasets[0].data = [];
                threadsChart.update();
                
                // Ê∏ÖÁ©∫ÊâÄÊúâÊ†áÁ≠æÊ†áËÆ∞
                const existingMarkers = document.querySelectorAll('.chart-tag-marker');
                existingMarkers.forEach(marker => marker.remove());
            }
        }

        // ÂºÄÂßãÁõëÊéß
        function startMonitoring() {
            const udid = document.getElementById('udid').value.trim();
            const bundleId = document.getElementById('bundleId').value.trim();
            
            showStatus('Ê≠£Âú®ÂêØÂä®ÁõëÊéß...', 'info');
            
            // Ê∏ÖÁ©∫‰πãÂâçÁöÑÊï∞ÊçÆ
            allPerformanceData = [];
            
            socket.emit('start_monitoring', {
                udid: udid,
                bundle_id: bundleId
            });
            
            isMonitoring = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('saveBtn').disabled = false;
        }

        // ÂÅúÊ≠¢ÁõëÊéß
        function stopMonitoring() {
            isMonitoring = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            showStatus('ÁõëÊéßÂ∑≤ÂÅúÊ≠¢', 'info');
            // ‰øùÊåÅÂõæË°®ÊòæÁ§∫Ôºå‰∏çÈöêËóè
        }

        // Socket.IO‰∫ã‰ª∂Â§ÑÁêÜ
        // Âú∫ÊôØÁÆ°ÁêÜÂäüËÉΩ
        function toggleSelection() {
            isSelecting = !isSelecting;
            const btn = document.getElementById('startSelectionBtn');
            const statusEl = document.getElementById('selectionStatus');
            
            if (isSelecting) {
                btn.textContent = 'ÂèñÊ∂àÈÄâÊã©';
                btn.style.background = '#ff3b30';
                statusEl.textContent = 'ËØ∑Âú®‰ªªÊÑèÂõæË°®‰∏äÊãñÊãΩÈÄâÊã©Êó∂Èó¥Âå∫Âüü';
                document.body.classList.add('selecting');
                enableChartSelection();
            } else {
                btn.textContent = 'ÂºÄÂßãÈÄâÊã©Êó∂Èó¥Âå∫Âüü';
                btn.style.background = '#007aff';
                statusEl.textContent = '';
                document.body.classList.remove('selecting');
                disableChartSelection();
                clearCurrentSelection();
            }
        }

        function enableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.addEventListener('mousedown', onSelectionStart);
                wrapper.addEventListener('mousemove', onSelectionMove);
                wrapper.addEventListener('mouseup', onSelectionEnd);
                wrapper.addEventListener('mouseleave', onSelectionEnd);
            });
        }

        function disableChartSelection() {
            const chartWrappers = document.querySelectorAll('.chart-wrapper');
            chartWrappers.forEach(wrapper => {
                wrapper.removeEventListener('mousedown', onSelectionStart);
                wrapper.removeEventListener('mousemove', onSelectionMove);
                wrapper.removeEventListener('mouseup', onSelectionEnd);
                wrapper.removeEventListener('mouseleave', onSelectionEnd);
            });
        }

        function onSelectionStart(e) {
            if (!isSelecting) return;
            isMouseDown = true;
            const rect = e.currentTarget.getBoundingClientRect();
            selectionStartX = e.clientX - rect.left;
            clearCurrentSelection();
        }

        function onSelectionMove(e) {
            if (!isSelecting || !isMouseDown) return;
            const rect = e.currentTarget.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const width = Math.abs(currentX - selectionStartX);
            const left = Math.min(selectionStartX, currentX);
            
            // ÂêåÊ≠•ÊòæÁ§∫ÈÄâÊã©Âå∫ÂüüÂà∞ÊâÄÊúâÂõæË°®
            updateAllSelectionOverlays(left, width);
        }

        function onSelectionEnd(e) {
            if (!isSelecting || !isMouseDown) return;
            isMouseDown = false;
            
            const rect = e.currentTarget.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const chartWidth = rect.width;
            
            // ËÆ°ÁÆóÊó∂Èó¥Á¥¢Âºï
            const startIndex = Math.floor((Math.min(selectionStartX, endX) / chartWidth) * maxDataPoints);
            const endIndex = Math.floor((Math.max(selectionStartX, endX) / chartWidth) * maxDataPoints);
            
            if (Math.abs(endX - selectionStartX) > 10) { // ÊúÄÂ∞èÈÄâÊã©ÂÆΩÂ∫¶
                // Ëé∑ÂèñÊó∂Èó¥Ê†áÁ≠æ
                const timeLabels = cpuChart.data.labels;
                selectionStart = timeLabels[Math.max(0, startIndex)] || '';
                selectionEnd = timeLabels[Math.min(timeLabels.length - 1, endIndex)] || '';
                
                if (selectionStart && selectionEnd) {
                    document.getElementById('saveSceneBtn').disabled = false;
                    document.getElementById('selectionStatus').textContent = 
                        `Â∑≤ÈÄâÊã©Êó∂Èó¥ÊÆµ: ${selectionStart} - ${selectionEnd}`;
                }
            }
        }

        function updateAllSelectionOverlays(left, width) {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                const overlay = document.getElementById(overlayId);
                overlay.style.display = 'block';
                overlay.style.left = left + 'px';
                overlay.style.width = width + 'px';
                overlay.style.top = '0px';
                overlay.style.height = '100%';
            });
        }

        function clearCurrentSelection() {
            const overlays = ['cpuOverlay', 'memoryOverlay', 'fpsOverlay', 'threadsOverlay'];
            overlays.forEach(overlayId => {
                document.getElementById(overlayId).style.display = 'none';
            });
            selectionStart = null;
            selectionEnd = null;
            document.getElementById('saveSceneBtn').disabled = true;
        }

        function saveScene() {
            const sceneName = document.getElementById('sceneNameInput').value.trim();
            if (!sceneName) {
                showStatus('ËØ∑ËæìÂÖ•Âú∫ÊôØÂêçÁß∞', 'error');
                return;
            }
            
            if (!selectionStart || !selectionEnd) {
                showStatus('ËØ∑ÂÖàÈÄâÊã©Êó∂Èó¥Âå∫Âüü', 'error');
                return;
            }

            // Ëé∑ÂèñÈÄâÊã©Êó∂Èó¥ÊÆµÂÜÖÁöÑÊÄßËÉΩÊï∞ÊçÆ
            const sceneData = allPerformanceData.filter(item => {
                return item.time >= selectionStart && item.time <= selectionEnd;
            });

            const scene = {
                id: Date.now(),
                name: sceneName,
                startTime: selectionStart,
                endTime: selectionEnd,
                data: sceneData,
                createdAt: new Date().toISOString(),
                summary: generateSceneSummary(sceneData)
            };

            savedScenes.push(scene);
            updateSceneList();
            
            // Âú®ÊâÄÊúâÂõæË°®‰∏äÊ∑ªÂä†Ê∞∏‰πÖÊ†áËÆ∞
            addSceneMarkersToAllCharts(scene);
            
            // Ê∏ÖÁ©∫ËæìÂÖ•ÂíåÈÄâÊã©
            document.getElementById('sceneNameInput').value = '';
            clearCurrentSelection();
            toggleSelection(); // ÈÄÄÂá∫ÈÄâÊã©Ê®°Âºè
            
            showStatus(`Âú∫ÊôØ "${sceneName}" Â∑≤‰øùÂ≠ò`, 'success');
        }

        function generateSceneSummary(sceneData) {
            const perfData = sceneData.filter(item => item.type === 'performance');
            //const fpsData = sceneData.filter(item => item.type === 'fps');
            
            if (perfData.length === 0) return {};
            
            const cpuValues = perfData.map(item => item.cpu);
            const memoryValues = perfData.map(item => item.memory);
            const fpsValues = perfData.map(item => item.fps);
            
            return {
                duration: perfData.length,
                avgCpu: (cpuValues.reduce((a, b) => a + b, 0) / cpuValues.length).toFixed(2),
                maxCpu: Math.max(...cpuValues).toFixed(2),
                avgMemory: (memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length).toFixed(1),
                maxMemory: Math.max(...memoryValues).toFixed(1),
                avgFps: fpsValues.length > 0 ? (fpsValues.reduce((a, b) => a + b, 0) / fpsValues.length).toFixed(1) : 0,
                minFps: fpsValues.length > 0 ? Math.min(...fpsValues) : 0
            };
        }

        function addSceneMarkersToAllCharts(scene) {
            // ËøôÈáåÊ∑ªÂä†Ê∞∏‰πÖÁöÑÂú∫ÊôØÊ†áËÆ∞Âà∞ÊâÄÊúâÂõæË°®
            // Chart.jsÊèí‰ª∂ÂèØ‰ª•ÂÆûÁé∞Ôºå‰ΩÜ‰∏∫‰∫ÜÁÆÄÂåñÔºåÊàë‰ª¨ÂÖàÂú®Âú∫ÊôØÂàóË°®‰∏≠ÊòæÁ§∫
        }

        function updateSceneList() {
            const sceneList = document.getElementById('sceneList');
            sceneList.innerHTML = '';
            
            savedScenes.forEach(scene => {
                const sceneItem = document.createElement('div');
                sceneItem.className = 'scene-item';
                sceneItem.innerHTML = `
                    <div class="scene-info">
                        <div><strong>${scene.name}</strong></div>
                        <div class="scene-time">${scene.startTime} - ${scene.endTime}</div>
                        <div style="font-size: 11px; color: #86868b;">
                            Âπ≥ÂùáCPU: ${scene.summary.avgCpu}% | Âπ≥ÂùáÂÜÖÂ≠ò: ${scene.summary.avgMemory}MB | Âπ≥ÂùáFPS: ${scene.summary.avgFps}
                        </div>
                    </div>
                    <div class="scene-actions">
                        <button onclick="deleteScene(${scene.id})">Âà†Èô§</button>
                    </div>
                `;
                sceneList.appendChild(sceneItem);
            });
        }

        function deleteScene(sceneId) {
            savedScenes = savedScenes.filter(scene => scene.id !== sceneId);
            updateSceneList();
            showStatus('Âú∫ÊôØÂ∑≤Âà†Èô§', 'info');
        }

        function clearAllScenes() {
            if (savedScenes.length === 0) return;
            if (confirm('Á°ÆËÆ§Ê∏ÖÁ©∫ÊâÄÊúâÂú∫ÊôØÊ†áËÆ∞Ôºü')) {
                savedScenes = [];
                updateSceneList();
                showStatus('ÊâÄÊúâÂú∫ÊôØÂ∑≤Ê∏ÖÁ©∫', 'info');
            }
        }

        // ‰øÆÊîπ‰øùÂ≠òÊï∞ÊçÆÂáΩÊï∞ÔºåÂåÖÂê´Âú∫ÊôØÂíåÊ†áÁ≠æ‰ø°ÊÅØ
        function saveDataWithScenes() {
            if (allTimeLabels.length === 0 && savedScenes.length === 0 && savedTags.length === 0) {
                showStatus('Ê≤°ÊúâÊï∞ÊçÆ„ÄÅÂú∫ÊôØÊàñÊ†áÁ≠æÂèØ‰øùÂ≠ò', 'error');
                return;
            }

            // ÈáçÊñ∞ÊûÑÂª∫ÊÄßËÉΩÊï∞ÊçÆÊï∞ÁªÑ
            const performanceData = [];
            for (let i = 0; i < allTimeLabels.length; i++) {
                performanceData.push({
                    timestamp: allTimeLabels[i],
                    cpu: allCpuData[i] || 0,
                    memory: allMemoryData[i] || 0,
                    fps: allFpsData[i] || 0,
                    threads: allThreadsData[i] || 0
                });
            }

            const now = new Date();
            const filename = `ios_performance_complete_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}.json`;
            
            const dataToSave = {
                timestamp: now.toISOString(),
                device_udid: document.getElementById('udid').value.trim(),
                bundle_id: document.getElementById('bundleId').value.trim(),
                data: performanceData,
                scenes: savedScenes, // ÂåÖÂê´Âú∫ÊôØ‰ø°ÊÅØ
                tags: savedTags, // ÂåÖÂê´Ê†áÁ≠æ‰ø°ÊÅØ
                settings: {
                    windowSize: windowSize,
                    timePosition: timePosition
                },
                summary: {
                    total_records: performanceData.length,
                    total_scenes: savedScenes.length,
                    total_tags: savedTags.length,
                    duration_seconds: performanceData.length > 0 ? 
                        Math.round((new Date(performanceData[performanceData.length-1].timestamp) - new Date(performanceData[0].timestamp)) / 1000) : 0
                }
            };

            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`Êï∞ÊçÆÂíåÂú∫ÊôØÂ∑≤‰øùÂ≠òÂà∞ ${filename}`, 'success');
        }

        socket.on('monitoring_started', function(data) {
            if (data.status === 'success') {
                showStatus('ÁõëÊéßÂ∑≤ÂêØÂä®ÔºåÊ≠£Âú®Êî∂ÈõÜÊï∞ÊçÆ...', 'success');
                document.getElementById('chartsGrid').style.display = 'grid';
                document.getElementById('currentValues').style.display = 'grid';
                document.getElementById('timeControls').style.display = 'block';
                document.getElementById('sceneControls').style.display = 'block';
                document.getElementById('tagControls').style.display = 'block';
                document.getElementById('scenarioControls').style.display = 'block';
                initCharts();
                enableDoubleClickTags(); // ÂêØÁî®ÂèåÂáªÊ†áÁ≠æÂäüËÉΩ
            }
        });

        socket.on('performance_data', function(data) {
            if (!isMonitoring) return;
            
            // ‰øùÂ≠òÂà∞allPerformanceDataÁî®‰∫éÂØºÂá∫
            allPerformanceData.push({
                type: 'performance',
                timestamp: new Date().toISOString(),
                time: data.time,
                cpu: data.cpu,
                memory: data.memory,
                fps: data.fps,
                threads: data.threads,
                pid: data.pid,
                name: data.name
            });

            // Êõ¥Êñ∞ÂΩìÂâçÂÄºÊòæÁ§∫
            document.getElementById('currentCpu').textContent = `${data.cpu}%`;
            document.getElementById('currentMemory').textContent = `${data.memory.toFixed(1)}MB`;
            document.getElementById('currentThreads').textContent = data.threads;
            // Êõ¥Êñ∞ÂΩìÂâçFPSÊòæÁ§∫
            document.getElementById('currentFps').textContent = `${data.fps}FPS`;
            
            // Ê∑ªÂä†Êï∞ÊçÆÂà∞ÂõæË°®
            addDataToChart(cpuChart, data.time, data.cpu);
            addDataToChart(memoryChart, data.time, data.memory);
            addDataToChart(threadsChart, data.time, data.threads);
            // Ê∑ªÂä†FPSÊï∞ÊçÆÂà∞ÂõæË°®
            addDataToChart(fpsChart, data.time, data.fps);
            
            // Êõ¥Êñ∞ÊÄßËÉΩÁªüËÆ°ÂàÜÊûê
            updatePerformanceStats(data.cpu, data.memory, data.fps || 0, data.threads);
            
            // Ê£ÄÊü•ÊÄßËÉΩÈòàÂÄºÂëäË≠¶
            checkPerformanceThresholds(data.cpu, data.memory, data.fps || 0, data.threads);
            
            // ‰∏ì‰∏öÁ∫ßÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµã (‰º†ÈÄíÊâÄÊúâÊÄßËÉΩÂèÇÊï∞)
            detectMemoryLeak(data.memory, data.cpu, data.fps || 0, data.threads);
            
            // Êõ¥Êñ∞ÂÆûÊó∂ËØÑÂàÜ
            updatePerformanceScores();
        });

        /*socket.on('fps_data', function(data) {
            if (!isMonitoring) return;

            // ‰øùÂ≠òÂà∞allPerformanceDataÁî®‰∫éÂØºÂá∫
            allPerformanceData.push({
                type: 'fps',
                timestamp: new Date().toISOString(),
                time: data.time,
                fps: data.fps
            });

            // Êõ¥Êñ∞ÂΩìÂâçFPSÊòæÁ§∫
            document.getElementById('currentFps').textContent = `${data.fps}FPS`;

            // Ê∑ªÂä†FPSÊï∞ÊçÆÂà∞ÂõæË°®
            addDataToChart(fpsChart, data.time, data.fps);
        });*/

        socket.on('connect', function() {
            console.log('Â∑≤ËøûÊé•Âà∞ÊúçÂä°Âô®');
        });

        socket.on('disconnect', function() {
            console.log('‰∏éÊúçÂä°Âô®Êñ≠ÂºÄËøûÊé•');
            if (isMonitoring) {
                showStatus('‰∏éÊúçÂä°Âô®ËøûÊé•Êñ≠ÂºÄ', 'error');
            }
        });

        // ÊÄßËÉΩÁªüËÆ°Êõ¥Êñ∞ÂáΩÊï∞
        function updatePerformanceStats(cpu, memory, fps, threads) {
            // Êõ¥Êñ∞CPUÁªüËÆ°
            performanceStats.cpu.current = cpu;
            performanceStats.cpu.sum += cpu;
            performanceStats.cpu.count++;
            performanceStats.cpu.avg = performanceStats.cpu.sum / performanceStats.cpu.count;
            performanceStats.cpu.max = Math.max(performanceStats.cpu.max, cpu);
            
            // Êõ¥Êñ∞ÂÜÖÂ≠òÁªüËÆ°
            performanceStats.memory.current = memory;
            performanceStats.memory.sum += memory;
            performanceStats.memory.count++;
            performanceStats.memory.avg = performanceStats.memory.sum / performanceStats.memory.count;
            performanceStats.memory.max = Math.max(performanceStats.memory.max, memory);
            
            // Êõ¥Êñ∞FPSÁªüËÆ°
            if (fps > 0) {
                performanceStats.fps.current = fps;
                performanceStats.fps.sum += fps;
                performanceStats.fps.count++;
                performanceStats.fps.avg = performanceStats.fps.sum / performanceStats.fps.count;
                performanceStats.fps.min = Math.min(performanceStats.fps.min, fps);
            }
            
            // Êõ¥Êñ∞Á∫øÁ®ãÁªüËÆ°
            performanceStats.threads.current = threads;
            performanceStats.threads.sum += threads;
            performanceStats.threads.count++;
            performanceStats.threads.avg = performanceStats.threads.sum / performanceStats.threads.count;
            performanceStats.threads.max = Math.max(performanceStats.threads.max, threads);
            
            // Êõ¥Êñ∞ÁªüËÆ°Èù¢ÊùøÊòæÁ§∫
            updateStatisticsDisplay();
        }
        
        function updateStatisticsDisplay() {
            document.getElementById('statCpuCurrent').textContent = `${performanceStats.cpu.current.toFixed(1)}%`;
            document.getElementById('statCpuAvg').textContent = `${performanceStats.cpu.avg.toFixed(1)}%`;
            document.getElementById('statCpuMax').textContent = `${performanceStats.cpu.max.toFixed(1)}%`;
            
            document.getElementById('statMemoryCurrent').textContent = `${performanceStats.memory.current.toFixed(1)}MB`;
            document.getElementById('statMemoryAvg').textContent = `${performanceStats.memory.avg.toFixed(1)}MB`;
            document.getElementById('statMemoryMax').textContent = `${performanceStats.memory.max.toFixed(1)}MB`;
            
            if (performanceStats.fps.count > 0) {
                document.getElementById('statFpsCurrent').textContent = `${performanceStats.fps.current}FPS`;
                document.getElementById('statFpsAvg').textContent = `${performanceStats.fps.avg.toFixed(1)}FPS`;
                document.getElementById('statFpsMin').textContent = `${performanceStats.fps.min === Infinity ? 0 : performanceStats.fps.min}FPS`;
            }
            
            document.getElementById('statThreadsCurrent').textContent = performanceStats.threads.current;
            document.getElementById('statThreadsAvg').textContent = performanceStats.threads.avg.toFixed(1);
            document.getElementById('statThreadsMax').textContent = performanceStats.threads.max;
        }
        
        // ÊÄßËÉΩÈòàÂÄºÊ£ÄÊü•ÂáΩÊï∞
        function checkPerformanceThresholds(cpu, memory, fps, threads) {
            // Êõ¥Êñ∞ÈòàÂÄºÈÖçÁΩÆ
            thresholds.cpu = parseInt(document.getElementById('cpuThreshold').value) || 80;
            thresholds.memory = parseInt(document.getElementById('memoryThreshold').value) || 200;
            thresholds.fps = parseInt(document.getElementById('fpsThreshold').value) || 30;
            thresholds.threads = parseInt(document.getElementById('threadsThreshold').value) || 50;
            
            activeAlerts = []; // Ê∏ÖÁ©∫ÂëäË≠¶ÂàóË°®
            
            // Ê£ÄÊü•CPUÈòàÂÄº
            if (cpu > thresholds.cpu) {
                activeAlerts.push({
                    type: 'cpu',
                    level: cpu > thresholds.cpu * 1.2 ? 'critical' : 'warning',
                    message: `CPU‰ΩøÁî®ÁéáËøáÈ´ò: ${cpu.toFixed(1)}% (ÈòàÂÄº: ${thresholds.cpu}%)`
                });
            }
            
            // Ê£ÄÊü•ÂÜÖÂ≠òÈòàÂÄº
            if (memory > thresholds.memory) {
                activeAlerts.push({
                    type: 'memory',
                    level: memory > thresholds.memory * 1.2 ? 'critical' : 'warning',
                    message: `ÂÜÖÂ≠ò‰ΩøÁî®ÈáèËøáÈ´ò: ${memory.toFixed(1)}MB (ÈòàÂÄº: ${thresholds.memory}MB)`
                });
            }
            
            // Ê£ÄÊü•FPSÈòàÂÄº
            if (fps > 0 && fps < thresholds.fps) {
                activeAlerts.push({
                    type: 'fps',
                    level: fps < thresholds.fps * 0.7 ? 'critical' : 'warning',
                    message: `Â∏ßÁéáËøá‰Ωé: ${fps}FPS (ÈòàÂÄº: ${thresholds.fps}FPS)`
                });
            }
            
            // Ê£ÄÊü•Á∫øÁ®ãÊï∞ÈòàÂÄº
            if (threads > thresholds.threads) {
                activeAlerts.push({
                    type: 'threads',
                    level: threads > thresholds.threads * 1.2 ? 'critical' : 'warning',
                    message: `Á∫øÁ®ãÊï∞ËøáÂ§ö: ${threads} (ÈòàÂÄº: ${thresholds.threads})`
                });
            }
            
            updateAlertsDisplay();
        }
        
        function updateAlertsDisplay() {
            const alertPanel = document.getElementById('alertPanel');
            const alertList = document.getElementById('alertList');
            
            if (activeAlerts.length === 0) {
                alertPanel.style.display = 'none';
                return;
            }
            
            alertPanel.style.display = 'block';
            alertList.innerHTML = '';
            
            activeAlerts.forEach(alert => {
                const alertItem = document.createElement('div');
                alertItem.className = `alert-item ${alert.level}`;
                alertItem.innerHTML = `
                    <span>${alert.message}</span>
                    <span>‚ö†Ô∏è</span>
                `;
                alertList.appendChild(alertItem);
            });
        }
        
        // ‰∏ì‰∏öÁ∫ßÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµã‰∏ªÂáΩÊï∞
        function detectMemoryLeak(currentMemory, cpuUsage = 0, fpsRate = 0, threads = 0) {
            // ‰ΩøÁî®Êñ∞ÁöÑ‰∏ì‰∏öÊ£ÄÊµãÁ≥ªÁªü
            runProfessionalMemoryLeakDetection(currentMemory, cpuUsage, fpsRate, threads);
            
            // ÂÖºÂÆπÊóßUIÊòæÁ§∫
            updateLegacyMemoryLeakUI(currentMemory);
        }
        
        function showMemoryLeakWarning(growthRate) {
            const warningEl = document.getElementById('leakWarning');
            const detailsEl = document.getElementById('leakDetails');
            
            detailsEl.innerHTML = `
                Ê£ÄÊµãÂà∞ÂÜÖÂ≠òÊåÅÁª≠Â¢ûÈïøÔºåÂ¢ûÈïøÁéá: ${growthRate.toFixed(2)} MB/min<br>
                Âª∫ËÆÆÊ£ÄÊü•Â∫îÁî®ÊòØÂê¶Â≠òÂú®ÂÜÖÂ≠òÊ≥ÑÊºèÈóÆÈ¢ò„ÄÇ<br>
                <small>Ê£ÄÊµãÊó∂Èó¥Á™óÂè£: 5ÂàÜÈíü</small>
            `;
            
            warningEl.style.display = 'block';
            warningEl.classList.add('active');
        }
        
        function hideMemoryLeakWarning() {
            const warningEl = document.getElementById('leakWarning');
            warningEl.style.display = 'none';
            warningEl.classList.remove('active');
        }
        
        // ÊÄßËÉΩËØÑÂàÜËÆ°ÁÆóÂáΩÊï∞
        function updatePerformanceScores() {
            const scores = calculatePerformanceScores();
            
            // Êõ¥Êñ∞CPUËØÑÂàÜ
            updateScoreDisplay('cpu', scores.cpu);
            
            // Êõ¥Êñ∞ÂÜÖÂ≠òËØÑÂàÜ
            updateScoreDisplay('memory', scores.memory);
            
            // Êõ¥Êñ∞FPSËØÑÂàÜ
            updateScoreDisplay('fps', scores.fps);
            
            // Êõ¥Êñ∞ÊÄª‰ΩìËØÑÂàÜ
            const overallScore = Math.round((scores.cpu.score + scores.memory.score + scores.fps.score) / 3);
            const overallGrade = getGradeFromScore(overallScore);
            updateScoreDisplay('overall', { score: overallScore, grade: overallGrade });
        }
        
        function calculatePerformanceScores() {
            const cpu = performanceStats.cpu.current;
            const memory = performanceStats.memory.current;
            const fps = performanceStats.fps.current;
            
            // CPUËØÑÂàÜ (0-100)
            let cpuScore = Math.max(0, 100 - cpu);
            if (cpu < 30) cpuScore = 100;
            else if (cpu < 50) cpuScore = 90;
            else if (cpu < 70) cpuScore = 75;
            else if (cpu < 85) cpuScore = 60;
            else cpuScore = Math.max(0, 100 - cpu);
            
            // ÂÜÖÂ≠òËØÑÂàÜ (ÂÅáËÆæ200MB‰∏∫Âü∫ÂáÜ)
            let memoryScore = Math.max(0, 100 - (memory / 200) * 100);
            if (memory < 100) memoryScore = 100;
            else if (memory < 150) memoryScore = 90;
            else if (memory < 200) memoryScore = 75;
            else if (memory < 300) memoryScore = 60;
            else memoryScore = Math.max(0, 100 - ((memory - 200) / 200) * 100);
            
            // FPSËØÑÂàÜ
            let fpsScore = 100;
            if (fps > 0) {
                if (fps >= 55) fpsScore = 100;
                else if (fps >= 45) fpsScore = 90;
                else if (fps >= 30) fpsScore = 75;
                else if (fps >= 20) fpsScore = 60;
                else fpsScore = Math.max(0, (fps / 20) * 60);
            }
            
            return {
                cpu: { score: Math.round(cpuScore), grade: getGradeFromScore(cpuScore) },
                memory: { score: Math.round(memoryScore), grade: getGradeFromScore(memoryScore) },
                fps: { score: Math.round(fpsScore), grade: getGradeFromScore(fpsScore) }
            };
        }
        
        function getGradeFromScore(score) {
            if (score >= 90) return 'A+';
            if (score >= 80) return 'A';
            if (score >= 70) return 'B';
            if (score >= 60) return 'C';
            if (score >= 50) return 'D';
            return 'F';
        }
        
        function updateScoreDisplay(type, scoreData) {
            const scoreEl = document.getElementById(`${type}Score`);
            const scoreNumEl = document.getElementById(`${type}ScoreNum`);
            
            if (scoreEl && scoreNumEl) {
                scoreEl.textContent = scoreData.grade;
                scoreNumEl.textContent = `(${scoreData.score})`;
                
                // Êõ¥Êñ∞È¢úËâ≤
                scoreEl.className = 'score-value grade-' + scoreData.grade.toLowerCase().replace('+', '');
            }
        }
        
        function resetPerformanceStats() {
            performanceStats = {
                cpu: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
                memory: { current: 0, avg: 0, max: 0, sum: 0, count: 0 },
                fps: { current: 0, avg: 0, min: Infinity, sum: 0, count: 0 },
                threads: { current: 0, avg: 0, max: 0, sum: 0, count: 0 }
            };
            updateStatisticsDisplay();
            // ÈáçÁΩÆÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµãÁ≥ªÁªü
            memoryLeakDetection.memoryHistory = [];
            professionalMemoryLeakDetection.memoryHistory = [];
            professionalMemoryLeakDetection.sceneStateMachine.currentScene = 'unknown';
            professionalMemoryLeakDetection.sceneStateMachine.sceneHistory = [];
            professionalMemoryLeakDetection.status.isLeaking = false;
            professionalMemoryLeakDetection.status.leakSources = [];
            professionalMemoryLeakDetection.status.suspiciousTransitions = [];
            professionalMemoryLeakDetection.statistics.totalLeaksDetected = 0;
            professionalMemoryLeakDetection.statistics.averageRecoveryRate = 0;
            activeAlerts = [];
            updateAlertsDisplay();
        }

        function calculateOverallScore() {
            const scores = calculatePerformanceScores();
            return Math.round((scores.cpu.score + scores.memory.score + scores.fps.score) / 3);
        }

        // Èù¢ÊùøÊãñÊãΩÂäüËÉΩ
        let draggedElement = null;
        let placeholder = null;
        let dragStartY = 0;
        let isDragging = false;

        function initDragAndDrop() {
            const container = document.querySelector('.container');
            const panels = document.querySelectorAll('.controls');
            
            panels.forEach(panel => {
                panel.setAttribute('draggable', 'true');
                
                panel.addEventListener('dragstart', function(e) {
                    draggedElement = this;
                    this.classList.add('dragging');
                    dragStartY = e.clientY;
                    isDragging = true;
                    
                    // ÂàõÂª∫Âç†‰ΩçÁ¨¶
                    placeholder = document.createElement('div');
                    placeholder.className = 'drag-placeholder';
                    
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', this.outerHTML);
                    
                    setTimeout(() => {
                        this.style.display = 'none';
                    }, 0);
                });
                
                panel.addEventListener('dragend', function(e) {
                    this.classList.remove('dragging');
                    this.style.display = 'block';
                    
                    if (placeholder && placeholder.parentNode) {
                        placeholder.parentNode.removeChild(placeholder);
                    }
                    
                    draggedElement = null;
                    placeholder = null;
                    isDragging = false;
                });
            });
            
            // Â§ÑÁêÜÊãñÊîæÁõÆÊ†á
            container.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                if (isDragging && draggedElement && placeholder) {
                    const afterElement = getDragAfterElement(container, e.clientY);
                    if (afterElement == null) {
                        container.appendChild(placeholder);
                    } else {
                        container.insertBefore(placeholder, afterElement);
                    }
                }
            });
            
            container.addEventListener('drop', function(e) {
                e.preventDefault();
                
                if (draggedElement && placeholder && placeholder.parentNode) {
                    placeholder.parentNode.insertBefore(draggedElement, placeholder);
                    placeholder.parentNode.removeChild(placeholder);
                    
                    // ‰øùÂ≠òÊñ∞ÁöÑÈù¢ÊùøÈ°∫Â∫èÂà∞localStorage
                    savePanelOrder();
                    
                    showStatus('Èù¢ÊùøÈ°∫Â∫èÂ∑≤Ë∞ÉÊï¥', 'success');
                }
            });
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.controls:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function savePanelOrder() {
            const panels = document.querySelectorAll('.controls');
            const order = [];
            
            panels.forEach(panel => {
                if (panel.id) {
                    order.push(panel.id);
                }
            });
            
            localStorage.setItem('panelOrder', JSON.stringify(order));
        }

        function restorePanelOrder() {
            const savedOrder = localStorage.getItem('panelOrder');
            if (!savedOrder) return;
            
            try {
                const order = JSON.parse(savedOrder);
                const container = document.querySelector('.container');
                
                // ÊâæÂà∞ÊâÄÊúâÈù¢Êùø
                const panels = {};
                document.querySelectorAll('.controls').forEach(panel => {
                    if (panel.id) {
                        panels[panel.id] = panel;
                    }
                });
                
                // Êåâ‰øùÂ≠òÁöÑÈ°∫Â∫èÈáçÊñ∞ÊéíÂàó
                order.forEach(panelId => {
                    if (panels[panelId]) {
                        container.appendChild(panels[panelId]);
                    }
                });
                
                console.log('Â∑≤ÊÅ¢Â§çÈù¢ÊùøÈ°∫Â∫è');
            } catch (error) {
                console.log('ÊÅ¢Â§çÈù¢ÊùøÈ°∫Â∫èÂ§±Ë¥•:', error);
            }
        }

        // ÈáçÁΩÆÈù¢ÊùøÈ°∫Â∫èÂäüËÉΩ
        function resetPanelOrder() {
            localStorage.removeItem('panelOrder');
            location.reload(); // ÁÆÄÂçïÈáçÊñ∞Âä†ËΩΩÈ°µÈù¢Êù•ÊÅ¢Â§çÈªòËÆ§È°∫Â∫è
        }

        // ÂàÜ‰∫´ÂäüËÉΩ
        function showShareDialog() {
            const dialog = document.getElementById('shareDialog');
            const urlElement = document.getElementById('shareUrl');
            
            // Ëé∑ÂèñÂΩìÂâçÈ°µÈù¢ÁöÑÂàÜ‰∫´URL
            const currentHost = window.location.hostname;
            const currentPort = window.location.port || (window.location.protocol === 'https:' ? '443' : '80');
            const shareUrl = `${window.location.protocol}//${currentHost}:${currentPort}`;
            
            urlElement.textContent = shareUrl;
            dialog.style.display = 'flex';
            
            // Ê∑ªÂä†ÁÇπÂáªËÉåÊôØÂÖ≥Èó≠ÂäüËÉΩ
            dialog.onclick = function(e) {
                if (e.target === dialog) {
                    closeShareDialog();
                }
            };
        }

        function closeShareDialog() {
            const dialog = document.getElementById('shareDialog');
            dialog.style.display = 'none';
        }

        function copyShareUrl() {
            const urlElement = document.getElementById('shareUrl');
            const shareUrl = urlElement.textContent;
            
            // ‰ΩøÁî®Áé∞‰ª£ÊµèËßàÂô®ÁöÑClipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(shareUrl).then(() => {
                    showCopySuccess();
                }).catch(() => {
                    fallbackCopyTextToClipboard(shareUrl);
                });
            } else {
                fallbackCopyTextToClipboard(shareUrl);
            }
        }

        function fallbackCopyTextToClipboard(text) {
            // ÂàõÂª∫‰∏¥Êó∂ÊñáÊú¨Âüü
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-999999px";
            textArea.style.top = "-999999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showCopySuccess();
            } catch (err) {
                console.error('Â§çÂà∂Â§±Ë¥•:', err);
                showStatus('Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÊâãÂä®Â§çÂà∂ÈìæÊé•', 'error');
            }
            
            document.body.removeChild(textArea);
        }

        function showCopySuccess() {
            const copyBtn = document.querySelector('.copy-btn');
            const originalText = copyBtn.textContent;
            
            copyBtn.textContent = '‚úÖ Â∑≤Â§çÂà∂';
            copyBtn.classList.add('copied');
            
            setTimeout(() => {
                copyBtn.textContent = originalText;
                copyBtn.classList.remove('copied');
            }, 2000);
            
            showStatus('ÂàÜ‰∫´ÈìæÊé•Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø', 'success');
        }

        // ÈîÆÁõòÂø´Êç∑ÈîÆ
        document.addEventListener('keydown', function(e) {
            // Ctrl+Shift+S Êàñ Cmd+Shift+S Âø´ÈÄüÂàÜ‰∫´
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'S') {
                e.preventDefault();
                showShareDialog();
            }
            // ESCÈîÆÂÖ≥Èó≠ÂàÜ‰∫´ÂØπËØùÊ°Ü
            if (e.key === 'Escape') {
                closeShareDialog();
            }
        });

        // È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÁöÑÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', function() {
            console.log('iOSÊÄßËÉΩÁõëÊéßÂèØËßÜÂåñÁïåÈù¢Â∑≤Âä†ËΩΩ');
            
            // ÂàùÂßãÂåñÊãñÊãΩÂäüËÉΩ
            setTimeout(() => {
                initDragAndDrop();
                restorePanelOrder();
            }, 100);
        });
        
        // ======================== ‰∏ì‰∏öÁ∫ßÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµãÊ†∏ÂøÉÂáΩÊï∞ ========================
        
        // Êô∫ËÉΩÂú∫ÊôØËØÜÂà´
        function detectCurrentScene(currentMemory, cpuUsage, fpsRate, threads) {
            const history = professionalMemoryLeakDetection.memoryHistory;
            
            if (history.length < 5) return 'unknown';
            
            // ÂàÜÊûêÂÜÖÂ≠òÂèòÂåñÊ®°Âºè
            const recentMemory = history.slice(-5).map(h => h.memory);
            const memoryTrend = calculateTrend(recentMemory);
            const memoryVolatility = calculateVolatility(recentMemory);
            
            // Âú∫ÊôØËØÜÂà´ËßÑÂàô (Âü∫‰∫éÁúüÂÆûiOSÂ∫îÁî®ÁâπÂæÅ)
            if (currentMemory < 120 && cpuUsage < 20 && Math.abs(memoryTrend) < 2) {
                return currentMemory < 90 ? 'background' : 'idle';
            } else if (memoryTrend > 15 && cpuUsage > 40) {
                return currentMemory > 250 ? 'video_playing' : 'launching';
            } else if (memoryVolatility > 10 && cpuUsage > 15) {
                return 'navigation';
            } else if (currentMemory > 200 && fpsRate > 30) {
                return 'video_playing';
            }
            
            return 'idle';
        }
        
        // ËÆ°ÁÆóÊï∞ÊçÆË∂ãÂäø
        function calculateTrend(values) {
            if (values.length < 2) return 0;
            let sum = 0;
            for (let i = 1; i < values.length; i++) {
                sum += values[i] - values[i-1];
            }
            return sum / (values.length - 1);
        }
        
        // ËÆ°ÁÆóÊï∞ÊçÆÊ≥¢Âä®ÊÄß
        function calculateVolatility(values) {
            if (values.length < 2) return 0;
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            return Math.sqrt(variance);
        }
        
        // ‰∏ì‰∏öÁ∫ßÊ£ÄÊµãÊâßË°åÂô®
        function runProfessionalMemoryLeakDetection(currentMemory, cpuUsage, fpsRate, threads) {
            const now = Date.now();
            const stateMachine = professionalMemoryLeakDetection.sceneStateMachine;
            const detection = professionalMemoryLeakDetection.detection;
            
            // ËÆ∞ÂΩïÂÜÖÂ≠òÂéÜÂè≤
            professionalMemoryLeakDetection.memoryHistory.push({
                time: now,
                memory: currentMemory,
                cpu: cpuUsage,
                fps: fpsRate,
                threads: threads,
                scene: null
            });
            
            // ‰øùÊåÅÂéÜÂè≤ËÆ∞ÂΩïÈïøÂ∫¶
            if (professionalMemoryLeakDetection.memoryHistory.length > professionalMemoryLeakDetection.maxHistoryLength) {
                professionalMemoryLeakDetection.memoryHistory.shift();
            }
            
            // Ê£ÄÊµãÂΩìÂâçÂú∫ÊôØ
            const detectedScene = detectCurrentScene(currentMemory, cpuUsage, fpsRate, threads);
            professionalMemoryLeakDetection.memoryHistory[professionalMemoryLeakDetection.memoryHistory.length - 1].scene = detectedScene;
            
            // Âú∫ÊôØÂàáÊç¢Ê£ÄÊµã
            if (detectedScene !== stateMachine.currentScene && stateMachine.currentScene !== 'unknown') {
                handleSceneTransition(stateMachine.currentScene, detectedScene, currentMemory, now);
            }
            
            // Êõ¥Êñ∞ÂΩìÂâçÂú∫ÊôØ‰ø°ÊÅØ
            if (!stateMachine.sceneStartTime || detectedScene !== stateMachine.currentScene) {
                stateMachine.sceneStartTime = now;
                stateMachine.sceneStartMemory = currentMemory;
            }
            
            stateMachine.currentScene = detectedScene;
            
            // ÊâßË°åÂ§öÁª¥Â∫¶Ê£ÄÊµã
            if (professionalMemoryLeakDetection.memoryHistory.length >= detection.minSampleSize) {
                performComprehensiveLeakDetection(currentMemory, now);
            }
            
            // Êõ¥Êñ∞UIÊòæÁ§∫
            updateProfessionalMemoryLeakUI();
        }
        
        // Â§ÑÁêÜÂú∫ÊôØÂàáÊç¢
        function handleSceneTransition(fromScene, toScene, currentMemory, timestamp) {
            const stateMachine = professionalMemoryLeakDetection.sceneStateMachine;
            const detection = professionalMemoryLeakDetection.detection;
            
            const sceneDuration = timestamp - stateMachine.sceneStartTime;
            
            // Âè™ÊúâÂú∫ÊôØÊåÅÁª≠Ë∂≥Â§üÈïøÊó∂Èó¥ÊâçËøõË°åÂàÜÊûê
            if (sceneDuration >= detection.sceneMinDuration) {
                analyzeSceneTransition(fromScene, toScene, stateMachine.sceneStartMemory, currentMemory, sceneDuration);
            }
            
            // ËÆ∞ÂΩïÂú∫ÊôØÂàáÊç¢ÂéÜÂè≤
            stateMachine.sceneHistory.push({
                fromScene,
                toScene,
                startMemory: stateMachine.sceneStartMemory,
                endMemory: currentMemory,
                duration: sceneDuration,
                timestamp: timestamp,
                memoryDelta: currentMemory - stateMachine.sceneStartMemory
            });
            
            // ‰øùÊåÅÂéÜÂè≤ËÆ∞ÂΩïÈïøÂ∫¶
            if (stateMachine.sceneHistory.length > 50) {
                stateMachine.sceneHistory.shift();
            }
            
            stateMachine.sceneTransitionCount++;
            console.log(`üîÑ Âú∫ÊôØÂàáÊç¢: ${fromScene} ‚Üí ${toScene}, ÂÜÖÂ≠òÂèòÂåñ: ${(currentMemory - stateMachine.sceneStartMemory).toFixed(1)}MB`);
        }
        
        // ÂàÜÊûêÂú∫ÊôØÂàáÊç¢ÁöÑÂÜÖÂ≠òÂõûÊî∂ÊÉÖÂÜµ
        function analyzeSceneTransition(fromScene, toScene, startMemory, endMemory, duration) {
            const profiles = professionalMemoryLeakDetection.sceneProfiles;
            const status = professionalMemoryLeakDetection.status;
            
            // Ê£ÄÊü•ÊòØÂê¶‰ªéÈ´òÂÜÖÂ≠òÂú∫ÊôØÂàáÊç¢Âà∞‰ΩéÂÜÖÂ≠òÂú∫ÊôØ
            const fromPriority = profiles[fromScene]?.priority || 0;
            const toPriority = profiles[toScene]?.priority || 0;
            
            if (fromPriority > toPriority) {
                // ÊúüÊúõÂÜÖÂ≠ò‰∏ãÈôç
                const expectedDecrease = calculateExpectedMemoryDecrease(fromScene, toScene, startMemory);
                const actualDecrease = Math.max(0, startMemory - endMemory);
                const recoveryRate = expectedDecrease > 0 ? actualDecrease / expectedDecrease : 1;
                
                // Êõ¥Êñ∞ÁªüËÆ°
                const stats = professionalMemoryLeakDetection.statistics;
                stats.averageRecoveryRate = (stats.averageRecoveryRate + recoveryRate) / 2;
                
                // Ê£ÄÊµãÂÜÖÂ≠òÊ≥ÑÊºè
                if (recoveryRate < professionalMemoryLeakDetection.detection.leakThreshold && expectedDecrease > 10) {
                    const leakAmount = Math.max(0, expectedDecrease - actualDecrease);
                    reportMemoryLeak(fromScene, toScene, leakAmount, recoveryRate, 'scene_transition');
                }
                
                console.log(`üìä Âú∫ÊôØÂàáÊç¢ÂàÜÊûê: ${fromScene} ‚Üí ${toScene}, ÊúüÊúõÂõûÊî∂: ${expectedDecrease.toFixed(1)}MB, ÂÆûÈôÖÂõûÊî∂: ${actualDecrease.toFixed(1)}MB, ÂõûÊî∂Áéá: ${(recoveryRate*100).toFixed(1)}%`);
            }
        }
        
        // ËÆ°ÁÆóÊúüÊúõÁöÑÂÜÖÂ≠ò‰∏ãÈôçÈáè
        function calculateExpectedMemoryDecrease(fromScene, toScene, currentMemory) {
            const profiles = professionalMemoryLeakDetection.sceneProfiles;
            const fromProfile = profiles[fromScene];
            const toProfile = profiles[toScene];
            
            if (!fromProfile || !toProfile) return 0;
            
            // Âü∫‰∫éÂú∫ÊôØÁâπÊÄßËÆ°ÁÆóÊúüÊúõ‰∏ãÈôçÈáè
            const fromExpected = (fromProfile.expectedMemory.min + fromProfile.expectedMemory.max) / 2;
            const toExpected = (toProfile.expectedMemory.min + toProfile.expectedMemory.max) / 2;
            
            // ËÄÉËôëÂΩìÂâçÂÜÖÂ≠òÊ∞¥Âπ≥ÁöÑË∞ÉÊï¥Âõ†Â≠ê
            const ratio = Math.min(1.0, Math.max(0.3, currentMemory / fromExpected));
            return Math.max(0, (fromExpected - toExpected) * ratio);
        }
        
        // Êä•ÂëäÂÜÖÂ≠òÊ≥ÑÊºè
        function reportMemoryLeak(fromScene, toScene, leakAmount, recoveryRate, source) {
            const status = professionalMemoryLeakDetection.status;
            const statistics = professionalMemoryLeakDetection.statistics;
            
            statistics.totalLeaksDetected++;
            
            const leakReport = {
                source: source,
                fromScene: fromScene,
                toScene: toScene,
                leakAmount: leakAmount,
                recoveryRate: recoveryRate,
                timestamp: Date.now(),
                severity: leakAmount > 50 ? 'severe' : leakAmount > 20 ? 'moderate' : 'mild'
            };
            
            status.suspiciousTransitions.push(leakReport);
            
            // ‰øùÊåÅËÆ∞ÂΩïÈïøÂ∫¶
            if (status.suspiciousTransitions.length > 10) {
                status.suspiciousTransitions.shift();
            }
            
            console.log(`üö® ÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµã: ${fromScene} ‚Üí ${toScene}, Ê≥ÑÊºèÈáè: ${leakAmount.toFixed(1)}MB, ÂõûÊî∂Áéá: ${(recoveryRate*100).toFixed(1)}%`);
        }
        
        // ÁªºÂêàÊ≥ÑÊºèÊ£ÄÊµã
        function performComprehensiveLeakDetection(currentMemory, timestamp) {
            const history = professionalMemoryLeakDetection.memoryHistory;
            const detection = professionalMemoryLeakDetection.detection;
            
            // 1. Ë∂ãÂäøÂàÜÊûê
            const trendWindow = Math.min(detection.trendAnalysisWindow, history.length);
            const recentHistory = history.slice(-trendWindow);
            const memoryTrend = calculateAdvancedTrend(recentHistory);
            
            // 2. ÂºÇÂ∏∏Ê£ÄÊµã
            const anomalies = detectMemoryAnomalies(recentHistory);
            
            // 3. ÈïøÊúüÂÜÖÂ≠òÂ¢ûÈïøÊ£ÄÊµã
            const longTermGrowth = analyzeLongTermMemoryGrowth(history);
            
            // ÁªºÂêàËØÑ‰º∞
            evaluateOverallLeakStatus(memoryTrend, anomalies, longTermGrowth);
        }
        
        // È´òÁ∫ßË∂ãÂäøÂàÜÊûê
        function calculateAdvancedTrend(historyWindow) {
            if (historyWindow.length < 10) return { slope: 0, confidence: 0, pattern: 'insufficient_data' };
            
            const memoryValues = historyWindow.map(h => h.memory);
            const timeValues = historyWindow.map((h, i) => i);
            
            // Á∫øÊÄßÂõûÂΩí
            const slope = calculateLinearRegressionSlope(timeValues, memoryValues);
            const correlation = calculateCorrelation(timeValues, memoryValues);
            
            return {
                slope: slope,
                confidence: Math.abs(correlation),
                pattern: identifyMemoryPattern(memoryValues),
                volatility: calculateVolatility(memoryValues)
            };
        }
        
        // Á∫øÊÄßÂõûÂΩíÊñúÁéáËÆ°ÁÆó
        function calculateLinearRegressionSlope(x, y) {
            const n = x.length;
            if (n < 2) return 0;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            
            const denominator = n * sumXX - sumX * sumX;
            return denominator === 0 ? 0 : (n * sumXY - sumX * sumY) / denominator;
        }
        
        // Áõ∏ÂÖ≥Á≥ªÊï∞ËÆ°ÁÆó
        function calculateCorrelation(x, y) {
            const n = x.length;
            if (n < 2) return 0;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumYY = y.reduce((sum, yi) => sum + yi * yi, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }
        
        // ÂÜÖÂ≠òÊ®°ÂºèËØÜÂà´
        function identifyMemoryPattern(memoryValues) {
            const trend = calculateTrend(memoryValues);
            const volatility = calculateVolatility(memoryValues);
            
            if (Math.abs(trend) < 1 && volatility < 5) return 'stable';
            if (trend > 5) return 'increasing';
            if (trend < -5) return 'decreasing';
            if (volatility > 15) return 'volatile';
            return 'normal';
        }
        
        // ÂÜÖÂ≠òÂºÇÂ∏∏Ê£ÄÊµã
        function detectMemoryAnomalies(historyWindow) {
            if (historyWindow.length < 10) return [];
            
            const memoryValues = historyWindow.map(h => h.memory);
            const mean = memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length;
            const stdDev = Math.sqrt(memoryValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / memoryValues.length);
            
            if (stdDev === 0) return [];
            
            const threshold = professionalMemoryLeakDetection.detection.anomalyThreshold;
            const anomalies = [];
            
            memoryValues.forEach((value, index) => {
                const zScore = Math.abs((value - mean) / stdDev);
                if (zScore > threshold) {
                    anomalies.push({
                        index: index,
                        value: value,
                        zScore: zScore,
                        severity: zScore > 3 ? 'high' : 'medium'
                    });
                }
            });
            
            return anomalies;
        }
        
        // ÈïøÊúüÂÜÖÂ≠òÂ¢ûÈïøÂàÜÊûê
        function analyzeLongTermMemoryGrowth(fullHistory) {
            if (fullHistory.length < 50) return { growth: 0, significance: 'low' };
            
            const segments = Math.min(5, Math.floor(fullHistory.length / 20));
            const segmentSize = Math.floor(fullHistory.length / segments);
            const segmentAverages = [];
            
            for (let i = 0; i < segments; i++) {
                const start = i * segmentSize;
                const end = start + segmentSize;
                const segment = fullHistory.slice(start, end);
                const average = segment.reduce((sum, h) => sum + h.memory, 0) / segment.length;
                segmentAverages.push(average);
            }
            
            const overallGrowth = segmentAverages[segmentAverages.length - 1] - segmentAverages[0];
            const growthRate = overallGrowth / segmentAverages.length;
            
            return {
                growth: overallGrowth,
                growthRate: growthRate,
                significance: Math.abs(growthRate) > 5 ? 'high' : 'low',
                segmentAverages: segmentAverages
            };
        }
        
        // ÁªºÂêàËØÑ‰º∞Ê≥ÑÊºèÁä∂ÊÄÅ
        function evaluateOverallLeakStatus(trendAnalysis, anomalies, longTermGrowth) {
            const status = professionalMemoryLeakDetection.status;
            let leakScore = 0;
            const leakSources = [];
            
            // Ë∂ãÂäøÂàÜÊûêËØÑÂàÜ
            if (trendAnalysis.slope > 2 && trendAnalysis.confidence > 0.7) {
                leakScore += 30;
                leakSources.push(`ÊåÅÁª≠ÂÜÖÂ≠òÂ¢ûÈïøË∂ãÂäø (${trendAnalysis.slope.toFixed(2)} MB/Ê†∑Êú¨)`);
            }
            
            // ÂºÇÂ∏∏Ê£ÄÊµãËØÑÂàÜ
            if (anomalies.length > 0) {
                leakScore += Math.min(25, anomalies.length * 5);
                leakSources.push(`Ê£ÄÊµãÂà∞ ${anomalies.length} ‰∏™ÂÜÖÂ≠òÂºÇÂ∏∏Â≥∞ÂÄº`);
            }
            
            // ÈïøÊúüÂ¢ûÈïøËØÑÂàÜ
            if (longTermGrowth.significance === 'high' && longTermGrowth.growth > 30) {
                leakScore += 25;
                leakSources.push(`ÈïøÊúüÂÜÖÂ≠òÂ¢ûÈïø ${longTermGrowth.growth.toFixed(1)} MB`);
            }
            
            // Âú∫ÊôØÂàáÊç¢ÂºÇÂ∏∏ËØÑÂàÜ
            if (status.suspiciousTransitions.length > 0) {
                leakScore += Math.min(20, status.suspiciousTransitions.length * 4);
                leakSources.push(`Âú∫ÊôØÂàáÊç¢ÂºÇÂ∏∏ ${status.suspiciousTransitions.length} Ê¨°`);
            }
            
            // Á°ÆÂÆöÊ≥ÑÊºèÁ≠âÁ∫ß
            let leakLevel = 'none';
            if (leakScore >= 70) leakLevel = 'severe';
            else if (leakScore >= 45) leakLevel = 'moderate';
            else if (leakScore >= 20) leakLevel = 'mild';
            
            // Êõ¥Êñ∞Áä∂ÊÄÅ
            const wasLeaking = status.isLeaking;
            status.isLeaking = leakLevel !== 'none';
            status.leakLevel = leakLevel;
            status.leakSources = leakSources;
            
            // Â¶ÇÊûúÁä∂ÊÄÅÊîπÂèòÔºåËß¶ÂèëË≠¶Âëä
            if (status.isLeaking && !wasLeaking) {
                showProfessionalMemoryLeakWarning(leakLevel, leakSources, leakScore);
            } else if (!status.isLeaking && wasLeaking) {
                hideProfessionalMemoryLeakWarning();
            }
        }
        
        // Êõ¥Êñ∞‰∏ì‰∏öÁ∫ßÂÜÖÂ≠òÊ≥ÑÊºèUIÊòæÁ§∫
        function updateProfessionalMemoryLeakUI() {
            const status = professionalMemoryLeakDetection.status;
            const stateMachine = professionalMemoryLeakDetection.sceneStateMachine;
            const statistics = professionalMemoryLeakDetection.statistics;
            
            // Êõ¥Êñ∞Ê£ÄÊµãÁä∂ÊÄÅ
            const leakStatusEl = document.getElementById('leakStatus');
            const memoryTrendEl = document.getElementById('memoryTrend');
            const leakRateEl = document.getElementById('leakRate');
            
            if (leakStatusEl) {
                if (status.isLeaking) {
                    const levelText = status.leakLevel === 'severe' ? 'üî¥ ‰∏•ÈáçÊ≥ÑÊºè' : 
                                     status.leakLevel === 'moderate' ? 'üü† ‰∏≠Â∫¶Ê≥ÑÊºè' : 'üü° ËΩªÂæÆÊ≥ÑÊºè';
                    leakStatusEl.textContent = levelText;
                } else {
                    leakStatusEl.textContent = '‚úÖ Ê≠£Â∏∏';
                }
            }
            
            if (memoryTrendEl) {
                const sceneName = professionalMemoryLeakDetection.sceneProfiles[stateMachine.currentScene]?.name || stateMachine.currentScene;
                memoryTrendEl.textContent = `ÂΩìÂâçÂú∫ÊôØ: ${sceneName}`;
            }
            
            if (leakRateEl) {
                leakRateEl.textContent = `Âπ≥ÂùáÂõûÊî∂Áéá: ${(statistics.averageRecoveryRate * 100).toFixed(1)}%`;
            }
        }
        
        // ‰∏ì‰∏öÁ∫ßÊ≥ÑÊºèË≠¶ÂëäÊòæÁ§∫
        function showProfessionalMemoryLeakWarning(leakLevel, leakSources, leakScore) {
            const warningEl = document.getElementById('leakWarning');
            const detailsEl = document.getElementById('leakDetails');
            
            if (detailsEl) {
                const severityText = leakLevel === 'severe' ? 'üî¥ ‰∏•Èáç' : leakLevel === 'moderate' ? 'üü† ‰∏≠Â∫¶' : 'üü° ËΩªÂæÆ';
                
                detailsEl.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <strong>${severityText} ÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµã (ËØÑÂàÜ: ${leakScore})</strong>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <strong>Ê£ÄÊµãÊ∫ê:</strong>
                        ${leakSources.map(source => `<div style="margin-left: 10px;">‚Ä¢ ${source}</div>`).join('')}
                    </div>
                    <div style="font-size: 12px; color: #666; margin-top: 8px;">
                        üéØ <strong>‰∏ì‰∏öÁ∫ßÊ£ÄÊµãÊñπÊ≥ï:</strong><br>
                        ‚Ä¢ Âú∫ÊôØÂàáÊç¢ÂÜÖÂ≠òÂõûÊî∂ÁéáÂàÜÊûê<br>
                        ‚Ä¢ ÁªüËÆ°Â≠¶ÂºÇÂ∏∏Ê£ÄÊµã (Z-Score)<br>
                        ‚Ä¢ Á∫øÊÄßÂõûÂΩíË∂ãÂäøÂàÜÊûê<br>
                        ‚Ä¢ ÈïøÊúüÂÜÖÂ≠òÂ¢ûÈïøÊ®°ÂºèËØÜÂà´
                    </div>
                `;
            }
            
            if (warningEl) {
                warningEl.style.display = 'block';
                warningEl.classList.add('active');
            }
            
            console.log(`üö® ‰∏ì‰∏öÁ∫ßÂÜÖÂ≠òÊ≥ÑÊºèÊ£ÄÊµã: ${leakLevel}, ËØÑÂàÜ: ${leakScore}, Ê∫ê: ${leakSources.join(', ')}`);
        }
        
        // ÈöêËóè‰∏ì‰∏öÁ∫ßÊ≥ÑÊºèË≠¶Âëä
        function hideProfessionalMemoryLeakWarning() {
            const warningEl = document.getElementById('leakWarning');
            if (warningEl) {
                warningEl.style.display = 'none';
                warningEl.classList.remove('active');
            }
        }
        
        // ÂÖºÂÆπÊóßÁ≥ªÁªüÁöÑÂÜÖÂ≠òÊ≥ÑÊºèUIÊõ¥Êñ∞
        function updateLegacyMemoryLeakUI(currentMemory) {
            const now = Date.now();
            memoryLeakDetection.memoryHistory.push({
                time: now,
                memory: currentMemory
            });
            
            // ‰øùÊåÅÊ£ÄÊµãÁ™óÂè£Â§ßÂ∞è
            const windowStart = now - memoryLeakDetection.detectionWindow;
            memoryLeakDetection.memoryHistory = memoryLeakDetection.memoryHistory.filter(
                item => item.time >= windowStart
            );
            
            // ‰ΩøÁî®‰∏ì‰∏öÊ£ÄÊµãÁªìÊûúÊõ¥Êñ∞ÊóßÁ≥ªÁªüÁä∂ÊÄÅ
            memoryLeakDetection.isLeaking = professionalMemoryLeakDetection.status.isLeaking;
            
            // Â¶ÇÊûúÊ≤°Êúâ‰∏ì‰∏öÁ∫ßË≠¶ÂëäÊòæÁ§∫Ôºå‰ΩøÁî®ÊóßÁöÑÁÆÄÂçïÊòæÁ§∫
            if (!professionalMemoryLeakDetection.status.isLeaking && memoryLeakDetection.memoryHistory.length >= 10) {
                const timeSpan = (now - memoryLeakDetection.memoryHistory[0].time) / 60000;
                const memoryIncrease = currentMemory - memoryLeakDetection.memoryHistory[0].memory;
                const growthRate = memoryIncrease / timeSpan;
                
                const leakRateEl = document.getElementById('leakRate');
                if (leakRateEl && !professionalMemoryLeakDetection.status.isLeaking) {
                    leakRateEl.textContent = `Â¢ûÈïøÁéá: ${growthRate.toFixed(2)} MB/min`;
                }
            }
        }
        
        // ================== ÊµãËØïÂú∫ÊôØËá™Âä®ÂåñÂäüËÉΩ ==================
        
        // ÂêØÂä®ÊµãËØïÂú∫ÊôØ
        function startTestScenario() {
            const scenarioType = document.getElementById('scenarioType').value;
            const udid = document.getElementById('udid').value;
            const bundleId = document.getElementById('bundleId').value;
            
            console.log(`üß™ ÂêØÂä®ÊµãËØïÂú∫ÊôØ: ${scenarioType}`);
            
            // ÊòæÁ§∫Áä∂ÊÄÅÈù¢Êùø
            const statusPanel = document.getElementById('scenarioStatus');
            const resultsPanel = document.getElementById('scenarioResults');
            statusPanel.style.display = 'block';
            resultsPanel.style.display = 'block';
            
            // Êõ¥Êñ∞Áä∂ÊÄÅ
            updateScenarioStatus('üîÑ', 'Ê≠£Âú®ÂêØÂä®ÊµãËØï...', 0);
            clearScenarioLog();
            
            // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
            document.getElementById('startScenarioBtn').disabled = true;
            document.getElementById('stopScenarioBtn').disabled = false;
            
            // ÂèëÈÄÅÂêØÂä®ËØ∑Ê±ÇÂà∞ÂêéÁ´Ø
            socket.emit('start_test_scenario', {
                scenario_type: scenarioType,
                udid: udid,
                bundle_id: bundleId
            });
            
            addScenarioLog(`üìã ÂºÄÂßãÊâßË°åÊµãËØïÂú∫ÊôØ: ${getScenarioDisplayName(scenarioType)}`);
        }
        
        // ÂÅúÊ≠¢ÊµãËØïÂú∫ÊôØ
        function stopTestScenario() {
            console.log('‚èπÔ∏è ÂÅúÊ≠¢ÊµãËØïÂú∫ÊôØ');
            
            // ÂèëÈÄÅÂÅúÊ≠¢ËØ∑Ê±ÇÂà∞ÂêéÁ´Ø
            socket.emit('stop_test_scenario');
            
            // Êõ¥Êñ∞Áä∂ÊÄÅ
            updateScenarioStatus('‚èπÔ∏è', 'Ê≠£Âú®ÂÅúÊ≠¢ÊµãËØï...', 0);
            
            // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
            document.getElementById('startScenarioBtn').disabled = false;
            document.getElementById('stopScenarioBtn').disabled = true;
            
            addScenarioLog('‚èπÔ∏è Áî®Êà∑ÊâãÂä®ÂÅúÊ≠¢ÊµãËØï');
        }
        
        // Êõ¥Êñ∞ÊµãËØïÂú∫ÊôØÁä∂ÊÄÅ
        function updateScenarioStatus(icon, text, progress) {
            document.getElementById('scenarioStatusIcon').textContent = icon;
            document.getElementById('scenarioStatusText').textContent = text;
            document.getElementById('scenarioProgress').style.width = progress + '%';
        }
        
        // Ê∑ªÂä†ÊµãËØïÊó•Âøó
        function addScenarioLog(message) {
            const logContainer = document.getElementById('scenarioLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Ê∏ÖÁ©∫ÊµãËØïÊó•Âøó
        function clearScenarioLog() {
            document.getElementById('scenarioLog').innerHTML = '';
        }
        
        // Ëé∑ÂèñÂú∫ÊôØÊòæÁ§∫ÂêçÁß∞
        function getScenarioDisplayName(scenarioType) {
            const names = {
                'app_launch': 'Â∫îÁî®ÂêØÂä®ÊµãËØï',
                'memory_stress': 'ÂÜÖÂ≠òÂéãÂäõÊµãËØï', 
                'ui_interaction': 'ÁïåÈù¢‰∫§‰∫íÊµãËØï',
                'background_switch': 'ÂêéÂè∞ÂàáÊç¢ÊµãËØï'
            };
            return names[scenarioType] || scenarioType;
        }
        
        // ================== Socket.IO ÊµãËØïÂú∫ÊôØ‰∫ã‰ª∂Â§ÑÁêÜ ==================
        
        // ÊµãËØïÂú∫ÊôØÂêØÂä®ÊàêÂäü
        socket.on('scenario_started', function(data) {
            console.log('‚úÖ ÊµãËØïÂú∫ÊôØÂêØÂä®ÊàêÂäü:', data);
            updateScenarioStatus('‚úÖ', 'ÊµãËØïÂú∫ÊôØÂ∑≤ÂêØÂä®', 10);
            addScenarioLog(`‚úÖ ÊµãËØïÂú∫ÊôØÂêØÂä®ÊàêÂäü: ${getScenarioDisplayName(data.type)}`);
        });
        
        // ÊµãËØïÂú∫ÊôØÂÅúÊ≠¢
        socket.on('scenario_stopped', function(data) {
            console.log('‚èπÔ∏è ÊµãËØïÂú∫ÊôØÂ∑≤ÂÅúÊ≠¢:', data);
            updateScenarioStatus('‚èπÔ∏è', 'ÊµãËØïÂ∑≤ÂÅúÊ≠¢', 0);
            addScenarioLog('‚èπÔ∏è ÊµãËØïÂú∫ÊôØÂ∑≤ÂÅúÊ≠¢');
            
            // ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
            document.getElementById('startScenarioBtn').disabled = false;
            document.getElementById('stopScenarioBtn').disabled = true;
        });
        
        // ÊµãËØïÂú∫ÊôØÈîôËØØ
        socket.on('scenario_error', function(data) {
            console.error('‚ùå ÊµãËØïÂú∫ÊôØÈîôËØØ:', data);
            updateScenarioStatus('‚ùå', `ÈîôËØØ: ${data.message}`, 0);
            addScenarioLog(`‚ùå ÈîôËØØ: ${data.message}`);
            
            // ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
            document.getElementById('startScenarioBtn').disabled = false;
            document.getElementById('stopScenarioBtn').disabled = true;
        });
        
        // ÊµãËØïÂú∫ÊôØ‰∫ã‰ª∂ÔºàÂÆûÊó∂Êõ¥Êñ∞Ôºâ
        socket.on('scenario_event', function(data) {
            console.log('üìä ÊµãËØïÂú∫ÊôØ‰∫ã‰ª∂:', data);
            
            switch(data.type) {
                case 'test_start':
                    updateScenarioStatus('üöÄ', data.message, 20);
                    addScenarioLog(`üöÄ ${data.message}`);
                    break;
                case 'progress':
                    updateScenarioStatus('üîÑ', data.message, data.progress || 50);
                    addScenarioLog(`üîÑ ${data.message}`);
                    break;
                case 'launch_result':
                    addScenarioLog(`‚ö° ${data.message}`);
                    break;
                case 'manual_prompt':
                    updateScenarioStatus('üëÜ', data.message, 50);
                    addScenarioLog(`üëÜ ${data.message}`);
                    break;
                case 'manual_success':
                    addScenarioLog(`‚úÖ ${data.message}`);
                    break;
                case 'test_complete':
                    updateScenarioStatus('‚úÖ', data.message, 100);
                    addScenarioLog(`üéâ ${data.message}`);
                    
                    // 5ÁßíÂêéÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                    setTimeout(() => {
                        document.getElementById('startScenarioBtn').disabled = false;
                        document.getElementById('stopScenarioBtn').disabled = true;
                    }, 5000);
                    break;
                case 'error':
                    updateScenarioStatus('‚ùå', data.message, 0);
                    addScenarioLog(`‚ùå ${data.message}`);
                    
                    // ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
                    document.getElementById('startScenarioBtn').disabled = false;
                    document.getElementById('stopScenarioBtn').disabled = true;
                    break;
            }
        });
        
        // ÊµãËØïÊ†áËÆ∞‰∫ã‰ª∂ÔºàÂú®ÂõæË°®‰∏äÊ∑ªÂä†Ê†áËÆ∞Ôºâ
        socket.on('test_marker', function(data) {
            console.log('üè∑Ô∏è ÊµãËØïÊ†áËÆ∞:', data);
            
            // Âú®ÂõæË°®‰∏äÊ∑ªÂä†ÊµãËØïÊ†áËÆ∞
            const timestamp = new Date().toLocaleTimeString();
            addScenarioLog(`üè∑Ô∏è ${data.message} (${timestamp})`);
            
            // ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†Âú®ÂõæË°®‰∏äÊòæÁ§∫Ê†áËÆ∞ÁöÑÈÄªËæë
            // ‰æãÂ¶ÇÂú®ÂΩìÂâçÊó∂Èó¥ÁÇπÊ∑ªÂä†ÂûÇÁõ¥Á∫øÊàñÊ†áËÆ∞
        });
        
        // ÁõëÊéßÂêØÂä®Êó∂ÂêØÁî®ÊµãËØïÂú∫ÊôØÊåâÈíÆ
        socket.on('monitoring_started', function(data) {
            if (data.status === 'success') {
                document.getElementById('startScenarioBtn').disabled = false;
                addScenarioLog('üì± ÊÄßËÉΩÁõëÊéßÂ∑≤ÂêØÂä®ÔºåÂèØ‰ª•ÂºÄÂßãÊµãËØïÂú∫ÊôØ');
            }
        });
        
        // ÁõëÊéßÂÅúÊ≠¢Êó∂Á¶ÅÁî®ÊµãËØïÂú∫ÊôØÊåâÈíÆ
        socket.on('monitoring_stopped', function(data) {
            document.getElementById('startScenarioBtn').disabled = true;
            document.getElementById('stopScenarioBtn').disabled = true;
            updateScenarioStatus('‚è∏Ô∏è', 'ÁõëÊéßÂ∑≤ÂÅúÊ≠¢', 0);
            addScenarioLog('‚è∏Ô∏è ÊÄßËÉΩÁõëÊéßÂ∑≤ÂÅúÊ≠¢ÔºåÊµãËØïÂú∫ÊôØÂäüËÉΩÊöÇÂÅú');
        });
    </script>
</body>
</html>
